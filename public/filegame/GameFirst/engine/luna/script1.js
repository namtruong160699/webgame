window.pc = { extend: function(t, e) { let i, n; for (i in e) n = e[i], Array.isArray(n) ? t[i] = pc.extend([], n) : n instanceof RegExp || n instanceof Date || n instanceof Function || n instanceof Float32Array ? t[i] = n : t[i] = "object" == typeof n && null !== n ? pc.extend({}, n) : n; return t } }, (() => {
        "use strict";
        var t = {},
            e = {};

        function i(n) { if (e[n]) return e[n].exports; var s = e[n] = { exports: {} }; return t[n](s, s.exports, i), s.exports }
        i.m = t, i.x = t => {}, i.d = (t, e) => { for (var n in e) i.o(e, n) && !i.o(t, n) && Object.defineProperty(t, n, { enumerable: !0, get: e[n] }) }, i.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e), (() => {
            var t = { 5: 0 },
                e = [],
                n = t => {},
                s = (s, r) => { for (var o, a, [c, h, l, u] = r, d = 0, p = []; d < c.length; d++) a = c[d], i.o(t, a) && t[a] && p.push(t[a][0]), t[a] = 0; for (o in h) i.o(h, o) && (i.m[o] = h[o]); for (l && l(i), s && s(r); p.length;) p.shift()(); return u && e.push.apply(e, u), n() },
                r = self.webpackChunk = self.webpackChunk || [];

            function o() {
                for (var n, s = 0; s < e.length; s++) {
                    for (var r = e[s], o = !0, a = 1; a < r.length; a++) {
                        var c = r[a];
                        0 !== t[c] && (o = !1)
                    }
                    o && (e.splice(s--, 1), n = i(i.s = r[0]))
                }
                return 0 === e.length && (i.x(), i.x = t => {}), n
            }
            r.forEach(s.bind(null, 0)), r.push = s.bind(null, r.push.bind(r));
            var a = i.x;
            i.x = () => (i.x = a || (t => {}), (n = o)())
        })();
        i.x()
    })(), (self.webpackChunk = self.webpackChunk || []).push([
        [0], {
            12: (t, e, i) => {
                "use strict";
                i.d(e, { a: () => c, b: () => u, c: () => n });
                const n = { EVENT_MOUSEDOWN: "mousedown", EVENT_MOUSEMOVE: "mousemove", EVENT_MOUSEUP: "mouseup", EVENT_MOUSEWHEEL: "mousewheel", EVENT_TOUCHSTART: "touchstart", EVENT_TOUCHEND: "touchend", EVENT_TOUCHMOVE: "touchmove", EVENT_TOUCHCANCEL: "touchcancel", KEY_BACKSPACE: 8, KEY_TAB: 9, KEY_RETURN: 13, KEY_ENTER: 13, KEY_SHIFT: 16, KEY_CONTROL: 17, KEY_ALT: 18, KEY_PAUSE: 19, KEY_CAPS_LOCK: 20, KEY_ESCAPE: 27, KEY_SPACE: 32, KEY_PAGE_UP: 33, KEY_PAGE_DOWN: 34, KEY_END: 35, KEY_HOME: 36, KEY_LEFT: 37, KEY_UP: 38, KEY_RIGHT: 39, KEY_DOWN: 40, KEY_PRINT_SCREEN: 44, KEY_INSERT: 45, KEY_DELETE: 46, KEY_0: 48, KEY_1: 49, KEY_2: 50, KEY_3: 51, KEY_4: 52, KEY_5: 53, KEY_6: 54, KEY_7: 55, KEY_8: 56, KEY_9: 57, KEY_SEMICOLON: 59, KEY_EQUAL: 61, KEY_A: 65, KEY_B: 66, KEY_C: 67, KEY_D: 68, KEY_E: 69, KEY_F: 70, KEY_G: 71, KEY_H: 72, KEY_I: 73, KEY_J: 74, KEY_K: 75, KEY_L: 76, KEY_M: 77, KEY_N: 78, KEY_O: 79, KEY_P: 80, KEY_Q: 81, KEY_R: 82, KEY_S: 83, KEY_T: 84, KEY_U: 85, KEY_V: 86, KEY_W: 87, KEY_X: 88, KEY_Y: 89, KEY_Z: 90, KEY_WINDOWS: 91, KEY_CONTEXT_MENU: 93, KEY_NUMPAD_0: 96, KEY_NUMPAD_1: 97, KEY_NUMPAD_2: 98, KEY_NUMPAD_3: 99, KEY_NUMPAD_4: 100, KEY_NUMPAD_5: 101, KEY_NUMPAD_6: 102, KEY_NUMPAD_7: 103, KEY_NUMPAD_8: 104, KEY_NUMPAD_9: 105, KEY_MULTIPLY: 106, KEY_ADD: 107, KEY_SEPARATOR: 108, KEY_SUBTRACT: 109, KEY_DECIMAL: 110, KEY_DIVIDE: 111, KEY_F1: 112, KEY_F2: 113, KEY_F3: 114, KEY_F4: 115, KEY_F5: 116, KEY_F6: 117, KEY_F7: 118, KEY_F8: 119, KEY_F9: 120, KEY_F10: 121, KEY_F11: 122, KEY_F12: 123, KEY_COMMA: 188, KEY_PERIOD: 190, KEY_SLASH: 191, KEY_OPEN_BRACKET: 219, KEY_BACK_SLASH: 220, KEY_CLOSE_BRACKET: 221, KEY_META: 224, MOUSEBUTTON_NONE: -1, MOUSEBUTTON_LEFT: 0, MOUSEBUTTON_MIDDLE: 1, MOUSEBUTTON_RIGHT: 2, PAD_1: 0, PAD_2: 1, PAD_3: 2, PAD_4: 3, PAD_FACE_1: 0, PAD_FACE_2: 1, PAD_FACE_3: 2, PAD_FACE_4: 3, PAD_L_SHOULDER_1: 4, PAD_R_SHOULDER_1: 5, PAD_L_SHOULDER_2: 6, PAD_R_SHOULDER_2: 7, PAD_SELECT: 8, PAD_START: 9, PAD_L_STICK_BUTTON: 10, PAD_R_STICK_BUTTON: 11, PAD_UP: 12, PAD_DOWN: 13, PAD_LEFT: 14, PAD_RIGHT: 15, PAD_VENDOR: 16, PAD_L_STICK_X: 0, PAD_L_STICK_Y: 1, PAD_R_STICK_X: 2, PAD_R_STICK_Y: 3 };
                var s = i(0);

                function r(t) { return "string" == typeof t ? t.toUpperCase().charCodeAt(0) : t }
                const o = { 9: "Tab", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 27: "Escape", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 46: "Delete", 91: "Win" };
                class a {
                    constructor(t, e) {
                        const i = t._getTargetCoords(e);
                        this.x = NaN, this.y = NaN, i && (this.x = i.x, this.y = i.y), this.wheel = e instanceof WheelEvent ? -e.deltaY : 0, this.dx = this.x - t._lastX, this.dy = this.y - t._lastY, this.button = n.MOUSEBUTTON_NONE, e instanceof MouseEvent && ("mousedown" === e.type || "mouseup" === e.type) && (this.button = e.button), this.buttons = t._buttons.slice(0), this.element = e.target, this.ctrlKey = e.ctrlKey || !1, this.altKey = e.altKey || !1, this.shiftKey = e.shiftKey || !1, this.metaKey = e.metaKey || !1, this.event = e
                    }
                }
                class c {
                    constructor(t) { this._lastX = 0, this._lastY = 0, this._buttons = [!1, !1, !1], this._lastbuttons = [!1, !1, !1], this._upHandler = this._handleUp.bind(this), this._downHandler = this._handleDown.bind(this), this._moveHandler = this._handleMove.bind(this), this._wheelHandler = this._handleWheel.bind(this), this._target = null, this._attached = !1, this.attach(t), this.events = new s.a(this) }
                    _contextMenuHandler(t) { t.preventDefault() }
                    attach(t) { this._target = t, this._attached || (this._attached = !0, window.addEventListener("mouseup", this._upHandler, !1), window.addEventListener("mousedown", this._downHandler, !1), window.addEventListener("mousemove", this._moveHandler, !1), window.addEventListener("wheel", this._wheelHandler, !1)) }
                    detach() { this._attached && (this._attached = !1, this._target = null, window.removeEventListener("mouseup", this._upHandler), window.removeEventListener("mousedown", this._downHandler), window.removeEventListener("mousemove", this._moveHandler), window.removeEventListener("wheel", this._wheelHandler)) }
                    disableContextMenu() { this._target && this._target.addEventListener("contextmenu", this._contextMenuHandler) }
                    enableContextMenu() { this._target && this._target.removeEventListener("contextmenu", this._contextMenuHandler) }
                    update() { this._lastbuttons[0] = this._buttons[0], this._lastbuttons[1] = this._buttons[1], this._lastbuttons[2] = this._buttons[2] }
                    isPressed(t) { return this._buttons[t] }
                    wasPressed(t) { return this._buttons[t] && !this._lastbuttons[t] }
                    wasReleased(t) { return !this._buttons[t] && this._lastbuttons[t] }
                    _handleUp(t) {
                        this._buttons[t.button] = !1;
                        const e = new a(this, t);
                        Number.isNaN(e.x) || this.events.fire(n.EVENT_MOUSEUP, e)
                    }
                    _handleDown(t) {
                        this._buttons[t.button] = !0;
                        const e = new a(this, t);
                        Number.isNaN(e.x) || this.events.fire(n.EVENT_MOUSEDOWN, e)
                    }
                    _handleMove(t) {
                        const e = new a(this, t);
                        Number.isNaN(e.x) || (this.events.fire(n.EVENT_MOUSEMOVE, e), this._lastX = e.x, this._lastY = e.y)
                    }
                    _handleWheel(t) {
                        const e = new a(this, t);
                        Number.isNaN(e.x) || this.events.fire(n.EVENT_MOUSEWHEEL, e)
                    }
                    _getTargetCoords(t) {
                        const e = this._target.getBoundingClientRect(),
                            i = Math.floor(e.left),
                            n = Math.floor(e.top);
                        return t.clientX < i || t.clientX >= i + this._target.clientWidth || t.clientY < n || t.clientY >= n + this._target.clientHeight ? null : { x: t.clientX - i, y: t.clientY - n }
                    }
                }
                class h {
                    constructor(t, e) {
                        const i = function(t, e) {
                            let i = 0,
                                n = 0;
                            for (; !(e instanceof HTMLElement);) e = e.parentNode;
                            let s = e;
                            do { i += s.offsetLeft - s.scrollLeft, n += s.offsetTop - s.scrollTop, s = s.offsetParent } while (s);
                            return { x: t.pageX - i, y: t.pageY - n }
                        }(t, e);
                        this.id = t.identifier, this.x = i.x, this.y = i.y, this.target = e, this.touch = t
                    }
                }
                class l {
                    constructor(t, e) { if (this.element = t.target || e, this.event = t, this.touches = [], this.changedTouches = [], t) { let e, i = t.touches.length; for (e = 0; e < i; e++) this.touches.push(new h(t.touches[e], this.element)); for (i = t.changedTouches.length, e = 0; e < i; e++) this.changedTouches.push(new h(t.changedTouches[e], this.element)) } }
                    getTouchById(t, e) {
                        let i;
                        const n = e.length;
                        for (i = 0; i < n; i++)
                            if (e[i].id === t) return e[i];
                        return null
                    }
                }
                class u {
                    constructor(t) { this._element = null, this._startHandler = this._handleTouchStart.bind(this), this._endHandler = this._handleTouchEnd.bind(this), this._moveHandler = this._handleTouchMove.bind(this), this._cancelHandler = this._handleTouchCancel.bind(this), this.attach(t), this.events = new s.a(this) }
                    attach(t) { this._element && this.detach(), this._element = t, this._element.addEventListener("touchstart", this._startHandler, !1), this._element.addEventListener("touchend", this._endHandler, !1), this._element.addEventListener("touchmove", this._moveHandler, !1), this._element.addEventListener("touchcancel", this._cancelHandler, !1) }
                    detach() { this._element && (this._element.removeEventListener("touchstart", this._startHandler, !1), this._element.removeEventListener("touchend", this._endHandler, !1), this._element.removeEventListener("touchmove", this._moveHandler, !1), this._element.removeEventListener("touchcancel", this._cancelHandler, !1)), this._element = null }
                    _handleTouchStart(t) { this.events.fire("touchstart", new l(t)) }
                    _handleTouchEnd(t) { this.events.fire("touchend", new l(t)) }
                    _handleTouchMove(t) { t.preventDefault(), this.events.fire("touchmove", new l(t)) }
                    _handleTouchCancel(t) { this.events.fire("touchcancel", new l(t)) }
                }
                Object.assign(pc, n), pc.Keyboard = class {
                    constructor(t) { this._element = null, this._keyDownHandler = this._handleKeyDown.bind(this), this._keyUpHandler = this._handleKeyUp.bind(this), this.events = new s.a(this), this._keymap = {}, this._lastmap = {}, t && this.attach(t) }
                    attach(t) { this._element && this.detach(), this._element = t, this._element.addEventListener("keydown", this._keyDownHandler, !1), this._element.addEventListener("keyup", this._keyUpHandler, !1) }
                    detach() { this._element.removeEventListener("keydown", this._keyDownHandler), this._element.removeEventListener("keyup", this._keyUpHandler), this._element = null }
                    toKeyIdentifier(t) { t = r(t); const e = o[t.toString()]; if (e) return e; let i = t.toString(16).toUpperCase(); const n = i.length; for (let t = 0; t < 4 - n; t++) i = "0" + i; return "U+" + i }
                    _handleKeyDown(t) {
                        const e = t.keyCode || t.charCode;
                        if (void 0 === e) return;
                        const i = this.toKeyIdentifier(e);
                        this._keymap[i] = !0
                    }
                    _handleKeyUp(t) {
                        const e = t.keyCode || t.charCode;
                        if (void 0 === e) return;
                        const i = this.toKeyIdentifier(e);
                        delete this._keymap[i]
                    }
                    update() { this._lastmap = Object.assign({}, this._keymap) }
                    isPressed(t) {
                        const e = r(t),
                            i = this.toKeyIdentifier(e);
                        return !!this._keymap[i]
                    }
                    wasPressed(t) {
                        const e = r(t),
                            i = this.toKeyIdentifier(e);
                        return !!this._keymap[i] && !this._lastmap[i]
                    }
                    wasReleased(t) {
                        const e = r(t),
                            i = this.toKeyIdentifier(e);
                        return !this._keymap[i] && !!this._lastmap[i]
                    }
                    anyKey() { return Object.keys(this._keymap).length > 0 }
                    anyKeyDown() {
                        for (const t in this._keymap)
                            if (this._keymap.hasOwnProperty(t) && !this._lastmap.hasOwnProperty(t)) return !0;
                        return !1
                    }
                }, pc.Mouse = c, pc.Touch = h, pc.TouchDevice = u, pc.TouchEvent = l
            }
        }
    ]), (self.webpackChunk = self.webpackChunk || []).push([
        [4], {
            0: (t, e, i) => {
                "use strict";
                i.d(e, { a: () => h, b: () => s, c: () => c });
                let n = 0;

                function s() { return "id:" + n++ }
                let r = 0,
                    o = 0;
                const a = window.performance && window.performance.now ? () => window.performance.now() : Date.now;
                const c = { pause: function() { o = a() }, resume: function() { r += a() - o, o = 0 }, now: function() { return o || a() - r } };
                class h {
                    constructor(t) { this.defaultScope = t, this._callbacks = {}, this._callbackActive = {} }
                    on(t, e, i = null) { return this._callbacks[t] || (this._callbacks[t] = []), this._callbackActive[t] && this._callbackActive[t] === this._callbacks[t] && (this._callbackActive[t] = this._callbackActive[t].slice()), this._callbacks[t].push({ callback: e, scope: i || this.defaultScope }), this }
                    off(t = null, e = null) {
                        if (!this._callbacks) return this;
                        if (this._callbackActive)
                            if (t) this._callbackActive[t] && this._callbackActive[t] === this._callbacks[t] && (this._callbackActive[t] = this._callbackActive[t].slice());
                            else
                                for (const t in this._callbackActive) this._callbacks[t] && this._callbacks[t] === this._callbackActive[t] && (this._callbackActive[t] = this._callbackActive[t].slice());
                        if (t)
                            if (e) { const i = this._callbacks[t]; if (!i) return this; let n = i.length; for (; n--;) i[n].callback === e && i.splice(n, 1) } else this._callbacks[t] && delete this._callbacks[t];
                        else this._callbacks = null;
                        return this
                    }
                    fire(t, ...e) {
                        if (!t || !this._callbacks || !this._callbacks[t]) return this;
                        let i;
                        this._callbackActive || (this._callbackActive = {}), this._callbackActive[t] ? (this._callbackActive[t] === this._callbacks[t] && (this._callbackActive[t] = this._callbackActive[t].slice()), i = this._callbacks[t].slice()) : this._callbackActive[t] = this._callbacks[t];
                        for (let n = 0;
                            (i || this._callbackActive[t]) && n < (i || this._callbackActive[t]).length; n++) { const s = (i || this._callbackActive[t])[n]; if (s.callback.call(s.scope, ...e), s.callback.once) { const e = this._callbacks[t].indexOf(s); - 1 !== e && (this._callbackActive[t] === this._callbacks[t] && (this._callbackActive[t] = this._callbackActive[t].slice()), this._callbacks[t].splice(e, 1)) } }
                        return i || (this._callbackActive[t] = null), this
                    }
                    once(t, e, i) { return e.once = !0, this.on(t, e, i), this }
                }
                const l = navigator.userAgent;
                let u = !1,
                    d = !1,
                    p = !1,
                    _ = !1;
                /(windows|mac os|linux|cros)/i.test(l) && (u = !0), /android/i.test(l) ? (u = !1, d = !0, p = !0) : /ip([ao]d|hone)/i.test(l) && (u = !1, d = !0, _ = !0);
                const f = { desktop: u, mobile: d, ios: _, android: p };
                i(6);
                const m = new Uint32Array(2048),
                    y = new Uint32Array(64),
                    g = new Uint32Array(64),
                    E = { aliceblue: "#f0f8ff", antiquewhite: "#faebd7", aqua: "#00ffff", aquamarine: "#7fffd4", azure: "#f0ffff", beige: "#f5f5dc", bisque: "#ffe4c4", black: "#000000", blanchedalmond: "#ffebcd", blue: "#0000ff", blueviolet: "#8a2be2", brown: "#a52a2a", burlywood: "#deb887", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", cornflowerblue: "#6495ed", cornsilk: "#fff8dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkgray: "#a9a9a9", darkgreen: "#006400", darkkhaki: "#bdb76b", darkmagenta: "#8b008b", darkolivegreen: "#556b2f", darkorange: "#ff8c00", darkorchid: "#9932cc", darkred: "#8b0000", darksalmon: "#e9967a", darkseagreen: "#8fbc8f", darkslateblue: "#483d8b", darkslategray: "#2f4f4f", darkturquoise: "#00ced1", darkviolet: "#9400d3", deeppink: "#ff1493", deepskyblue: "#00bfff", dimgray: "#696969", dodgerblue: "#1e90ff", firebrick: "#b22222", floralwhite: "#fffaf0", forestgreen: "#228b22", fuchsia: "#ff00ff", gainsboro: "#dcdcdc", ghostwhite: "#f8f8ff", gold: "#ffd700", goldenrod: "#daa520", gray: "#808080", green: "#008000", greenyellow: "#adff2f", honeydew: "#f0fff0", hotpink: "#ff69b4", indianred: "#cd5c5c", indigo: "#4b0082", ivory: "#fffff0", khaki: "#f0e68c", lavender: "#e6e6fa", lavenderblush: "#fff0f5", lawngreen: "#7cfc00", lemonchiffon: "#fffacd", lightblue: "#add8e6", lightcoral: "#f08080", lightcyan: "#e0ffff", lightgoldenrodyellow: "#fafad2", lightgray: "#d3d3d3", lightgreen: "#90ee90", lightpink: "#ffb6c1", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", lightskyblue: "#87cefa", lightslategray: "#778899", lightsteelblue: "#b0c4de", lightyellow: "#ffffe0", lime: "#00ff00", limegreen: "#32cd32", linen: "#faf0e6", magenta: "#ff00ff", maroon: "#800000", mediumaquamarine: "#66cdaa", mediumblue: "#0000cd", mediumorchid: "#ba55d3", mediumpurple: "#9370db", mediumseagreen: "#3cb371", mediumslateblue: "#7b68ee", mediumspringgreen: "#00fa9a", mediumturquoise: "#48d1cc", mediumvioletred: "#c71585", midnightblue: "#191970", mintcream: "#f5fffa", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", navajowhite: "#ffdead", navy: "#000080", oldlace: "#fdf5e6", olive: "#808000", olivedrab: "#6b8e23", orange: "#ffa500", orangered: "#ff4500", orchid: "#da70d6", alegoldenrod: "#eee8aa", palegreen: "#98fb98", paleturquoise: "#afeeee", palevioletred: "#db7093", papayawhip: "#ffefd5", peachpuff: "#ffdab9", peru: "#cd853f", pink: "#ffc0cb", plum: "#dda0dd", powderblue: "#b0e0e6", purple: "#800080", red: "#ff0000", rosybrown: "#bc8f8f", royalblue: "#4169e1", saddlebrown: "#8b4513", salmon: "#fa8072", sandybrown: "#f4a460", seagreen: "#2e8b57", seashell: "#fff5ee", sienna: "#a0522d", silver: "#c0c0c0", skyblue: "#87ceeb", slateblue: "#6a5acd", slategray: "#708090", snow: "#fffafa", springgreen: "#00ff7f", steelblue: "#4682b4", tan: "#d2b48c", teal: "#008080", thistle: "#d8bfd8", tomato: "#ff6347", turquoise: "#40e0d0", violet: "#ee82ee", wheat: "#f5deb3", white: "#ffffff", whitesmoke: "#f5f5f5", yellow: "#ffff00", yellowgreen: "#9acd32" };
                m[0] = 0;
                for (let t = 1; t < 1024; ++t) {
                    let e = t << 13,
                        i = 0;
                    for (; 0 == (8388608 & e);) i -= 8388608, e <<= 1;
                    e &= -8388609, i += 947912704, m[t] = e | i
                }
                for (let t = 1024; t < 2048; ++t) m[t] = 939524096 + (t - 1024 << 13);
                g[0] = 0;
                for (let t = 1; t < 31; ++t) g[t] = t << 23;
                g[31] = 1199570944, g[32] = 2147483648;
                for (let t = 33; t < 63; ++t) g[t] = 2147483648 + (t - 32 << 23);
                g[63] = 3347054592, y[0] = 0;
                for (let t = 1; t < 64; ++t) y[t] = 32 === t ? 0 : 1024;
                pc.guid = { create: s }, pc.time = c, pc.Events = h, pc.platform = f, pc.Conversion = {
                    fromFloat16ToFloat32: function(t) {
                        const e = new Float32Array(t.length),
                            i = new Uint32Array(e.buffer);
                        for (let e = 0; e < t.length; e++) {
                            const n = t[e],
                                s = n >> 10;
                            i[e] = m[y[s] + (1023 & n)] + g[s]
                        }
                        return e
                    },
                    tryParseHtmlString: function(t, e) { if ("#" === t[0]) return e.fromString(t), !0; let i = t.toLowerCase(); return !(!/^[a-z]+$/.test(i) || (i = E[i], !i)) && (e.fromString(i), !0) }
                }
            },
            6: (t, e, i) => {
                "use strict";
                i.d(e, { a: () => C, b: () => S, c: () => u, d: () => P, e: () => r, f: () => c });
                const n = Math.PI / 180,
                    s = 180 / Math.PI;

                function r(t, e, i) { return t >= i ? i : t <= e ? e : t }

                function o(t) { return [t >> 16 & 255, t >> 8 & 255, 255 & t] }

                function a(t) { return [t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, 255 & t] }

                function c(t, e, i) { return t + (e - t) * r(i, 0, 1) }

                function h(t) { return t < 0 ? -1 : 1 }
                const l = { tmpVec21: null, tmpVec22: null, diff: null };
                class u {
                    constructor(t = 0, e = 0) { this.x = t, this.y = e, this._data = null }
                    add(t) { return this.x += t.x, this.y += t.y, this }
                    add2(t, e) { return this.x = t.x + e.x, this.y = t.y + e.y, this }
                    clone() { return (new u).copy(this) }
                    copy(t) { return this.x = t.x, this.y = t.y, this }
                    dot(t) { return this.x * t.x + this.y * t.y }
                    equals(t) { const e = l.diff; return e.copy(this), e.sub(t), e.lengthSq() < 999999943962493e-25 }
                    length() { return Math.sqrt(this.x * this.x + this.y * this.y) }
                    lengthSq() { return this.x * this.x + this.y * this.y }
                    lerp(t, e, i) { return i = r(i, 0, 1), this.x = t.x + i * (e.x - t.x), this.y = t.y + i * (e.y - t.y), this }
                    lerpUnclamped(t, e, i) { return this.x = t.x + i * (e.x - t.x), this.y = t.y + i * (e.y - t.y), this }
                    mul(t) { return this.x *= t.x, this.y *= t.y, this }
                    mul2(t, e) { return this.x = t.x * e.x, this.y = t.y * e.y, this }
                    normalize() {
                        const t = this.x * this.x + this.y * this.y;
                        if (t > 0) {
                            const e = 1 / Math.sqrt(t);
                            this.x *= e, this.y *= e
                        }
                        return this
                    }
                    scale(t) { return this.x *= t, this.y *= t, this }
                    set(t, e) { return this.x = t, this.y = e, this }
                    sub(t) { return this.x -= t.x, this.y -= t.y, this }
                    sub2(t, e) { return this.x = t.x - e.x, this.y = t.y - e.y, this }
                    toString() { return "[" + this.x + ", " + this.y + "]" }
                    setFromMax(t, e) { return t > this.x && (this.x = t), e > this.y && (this.y = e), this }
                    strictEquals(t) { return t instanceof u && this.equals(t) }
                    div(t) { return this.x /= t.x, this.y /= t.y, this }
                    $getType() { return u }
                    getitem(t) {
                        switch (t) {
                            case 0:
                                return this.x;
                            case 1:
                                return this.y;
                            default:
                                return NaN
                        }
                    }
                    iget(t) { return this.getitem(t) }
                    setitem(t, e) {
                        switch (t) {
                            case 0:
                                this.x = e;
                                break;
                            case 1:
                                this.y = e
                        }
                    }
                    iset(t, e) { this.setitem(t, e) }
                    getHashCode() { return this.x ^ this.y }
                    hash() { return this.getHashCode() }
                    $clone(t = new u) { return t.copy(this), t }
                    fromVector3(t) { return this.x = t.x, this.y = t.y, this }
                    fromVector4(t) { return this.x = t.x, this.y = t.y, this }
                    get data() { return this._data || (this._data = new Float32Array(2)), this._data[0] = this.x, this._data[1] = this.y, this._data }
                }
                l.tmpVec21 = new u, l.tmpVec22 = new u, l.diff = new u, u.ctor = u, u.$kind = "struct", u.kEpsilon = 1e-5, u.kEpsilonNormalSqrt = 1e-15, u.angle = (t, e) => { const { tmpVec21: i, tmpVec22: n } = l; return i.copy(t).normalize(), n.copy(e).normalize(), Math.acos(r(i.dot(n), -1, 1)) * s }, u.signedAngle = (t, e) => u.angle(t, e) * h(t.x * e.y - t.y * e.x), u.lengthClamp = (t, e) => t.lengthSq() > e * e ? t.clone().normalize().scale(e) : t.clone(), u.reflect = (t, e) => {
                    const { tmpVec21: i } = l;
                    i.copy(e);
                    const n = -2 * i.dot(t);
                    return i.scale(n), i.add(t).clone()
                }, u.moveTowards = (t, e, i) => {
                    const n = l.tmpVec21.copy(e).sub(t),
                        s = n.length();
                    return s <= i || s < 1401298e-51 ? e.clone() : t.clone().add(n.scale(1 / s * i))
                }, u.smoothDamp = (t, e, i, n, s, r) => {
                    const o = 2 / (n = Math.max(1e-4, n)),
                        a = o * r,
                        c = 1 / (1 + a + .479999989271164 * a * a + .234999999403954 * a * a * a),
                        h = t.clone().sub(e.clone()),
                        l = e.clone(),
                        d = s * n,
                        p = u.lengthClamp(h.clone(), d);
                    e = t.clone().sub(p.clone());
                    const _ = i.v.clone().add(p.clone().scale(o)).scale(r);
                    i.v = i.v.clone().sub(_.clone().scale(o)).scale(c);
                    let f = e.clone().add(p.clone().add(_.clone()).scale(c));
                    return l.clone().sub(t.clone()).dot(f.clone().sub(l.clone())) > 0 && (f = l.clone(), i.v = f.clone().sub(l.clone()).scale(1 / r)), f.clone()
                }, u.equals = (t, e) => null === t && null === e || t && e && t.equals(e), u.getDefaultValue = () => new u, u.FromVector3 = t => new u(t.x, t.y), u.FromVector4 = t => new u(t.x, t.y);
                const d = new u(1, 1);
                d._data = new Float32Array(2), Object.freeze(d), u.ONE = d;
                const p = new u(1, 0);
                p._data = new Float32Array(2), Object.freeze(p), u.RIGHT = p;
                const _ = new u(0, 1);
                _._data = new Float32Array(2), Object.freeze(_), u.UP = _;
                const f = new u(0, 0);
                f._data = new Float32Array(2), Object.freeze(f), u.ZERO = f;
                const m = { tmpVec41: null, diff: null };
                class y {
                    constructor(t = 0, e = 0, i = 0, n = 0) { this.x = t, this.y = e, this.z = i, this.w = n, this._data = null }
                    add(t) { return this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this }
                    add2(t, e) { return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this }
                    clone() { return (new y).copy(this) }
                    copy(t) { return this.x = t.x, this.y = t.y, this.z = t.z, this.w = t.w, this }
                    dot(t) { return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w }
                    equals(t) { const e = m.diff; return e.copy(this), e.sub(t), e.lengthSq() < 999999943962493e-25 }
                    length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w) }
                    lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w }
                    lerp(t, e, i) { return this.x = t.x + i * (e.x - t.x), this.y = t.y + i * (e.y - t.y), this.z = t.z + i * (e.z - t.z), this.w = t.w + i * (e.w - t.w), this }
                    mul(t) { return this.x *= t.x, this.y *= t.y, this.z *= t.z, this.w *= t.w, this }
                    mul2(t, e) { return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this.w = t.w * e.w, this }
                    normalize() {
                        const t = this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
                        if (t > 0) {
                            const e = 1 / Math.sqrt(t);
                            this.x *= e, this.y *= e, this.z *= e, this.w *= e
                        }
                        return this
                    }
                    scale(t) { return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this }
                    set(t, e, i, n) { return this.x = t, this.y = e, this.z = i, this.w = n, this }
                    setFromArray(t, e = 0) { return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this }
                    sub(t) { return this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this }
                    sub2(t, e) { return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this }
                    toString() { return "[" + this.x + ", " + this.y + ", " + this.z + ", " + this.w + "]" }
                    project(t) { const e = (this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w) / (t.x * t.x + t.y * t.y + t.z * t.z + t.w * t.w); return this.x = t.x * e, this.y = t.y * e, this.z = t.z * e, this.w = t.w * e, this }
                    getitem(t) {
                        switch (t) {
                            case 0:
                                return this.x;
                            case 1:
                                return this.y;
                            case 2:
                                return this.z;
                            case 3:
                                return this.w;
                            default:
                                return NaN
                        }
                    }
                    iget(t) { return this.getitem(t) }
                    setitem(t, e) {
                        switch (t) {
                            case 0:
                                this.x = e;
                                break;
                            case 1:
                                this.y = e;
                                break;
                            case 2:
                                this.z = e;
                                break;
                            case 3:
                                this.w = e
                        }
                    }
                    iset(t, e) { this.setitem(t, e) }
                    strictEquals(t) { return t instanceof y && this.equals(t) }
                    lerpUnclamped(t, e, i) { return this.x = t.x + i * (e.x - t.x), this.y = t.y + i * (e.y - t.y), this.z = t.z + i * (e.z - t.z), this.w = t.w + i * (e.w - t.w), this }
                    hash() { return this.x ^ this.y ^ this.z ^ this.w }
                    getHashCode() { return this.hash() }
                    fromVector2(t) { return this.x = t.x, this.y = t.y, this.z = 0, this.w = 0, this }
                    fromVector3(t) { return this.x = t.x, this.y = t.y, this.z = t.z, this.w = 0, this }
                    $getType() { return y }
                    $clone(t = new y) { return t.copy(this), t }
                    get data() { return this._data || (this._data = new Float32Array(4)), this._data[0] = this.x, this._data[1] = this.y, this._data[2] = this.z, this._data[3] = this.w, this._data }
                }
                m.tmpVec41 = new y, m.diff = new y, y.ctor = y, y.$kind = "struct", y.distance = (t, e) => m.tmpVec41.copy(t).sub(e).length(), y.moveTowards = (t, e, i) => {
                    const n = m.tmpVec41.copy(e).sub(t),
                        s = n.length();
                    return s <= i || s < 1401298e-51 ? e.clone() : t.clone().add(n.scale(1 / s * i))
                }, y.equals = (t, e) => null === t && null === e || null !== t && null !== e && t.equals(e), y.getDefaultValue = () => new y, y.FromVector2 = t => new y(t.x, t.y, 0, 0), y.FromVector3 = t => new y(t.x, t.y, t.z, 0);
                const g = new y(1, 1, 1, 1);
                g._data = new Float32Array(4), Object.freeze(g), y.ONE = g;
                const E = new y(0, 0, 0, 0);
                E._data = new Float32Array(4), Object.freeze(E), y.ZERO = E;
                class A {
                    constructor() {
                        const t = new Float32Array(9);
                        t[0] = t[4] = t[8] = 1, this.data = t
                    }
                    clone() { return (new A).copy(this) }
                    copy(t) {
                        const e = t.data,
                            i = this.data;
                        return i[0] = e[0], i[1] = e[1], i[2] = e[2], i[3] = e[3], i[4] = e[4], i[5] = e[5], i[6] = e[6], i[7] = e[7], i[8] = e[8], this
                    }
                    set(t) { const e = this.data; return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], this }
                    equals(t) {
                        const e = this.data,
                            i = t.data;
                        return e[0] === i[0] && e[1] === i[1] && e[2] === i[2] && e[3] === i[3] && e[4] === i[4] && e[5] === i[5] && e[6] === i[6] && e[7] === i[7] && e[8] === i[8]
                    }
                    isIdentity() { const t = this.data; return 1 === t[0] && 0 === t[1] && 0 === t[2] && 0 === t[3] && 1 === t[4] && 0 === t[5] && 0 === t[6] && 0 === t[7] && 1 === t[8] }
                    setIdentity() { const t = this.data; return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, this }
                    toString() { let t = "["; for (let e = 0; e < 9; e++) t += this.data[e], t += 9 !== e ? ", " : ""; return t += "]", t }
                    transpose() { const t = this.data; let e; return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this }
                }
                A.IDENTITY = Object.freeze(new A), A.ZERO = Object.freeze((new A).set([0, 0, 0, 0, 0, 0, 0, 0, 0]));
                const b = { _tmpVec31: null, _tmpVec32: null, _tmpVec33: null, _tmpQuat1: null, _tmpQuat2: null, get tmpVec31() { return this._tmpVec31 = this._tmpVec31 || new P, this._tmpVec31 }, get tmpVec32() { return this._tmpVec32 = this._tmpVec32 || new P, this._tmpVec32 }, get tmpVec33() { return this._tmpVec33 = this._tmpVec33 || new P, this._tmpVec33 }, get tmpQuat1() { return this._tmpQuat1 = this._tmpQuat1 || new S, this._tmpQuat1 }, get tmpQuat2() { return this._tmpQuat2 = this._tmpQuat2 || new S, this._tmpQuat2 } };
                class C {
                    constructor() { this.data = new Float32Array(16), this.data[0] = this.data[5] = this.data[10] = this.data[15] = 1 }
                    add2(t, e) {
                        const i = t.data,
                            n = e.data,
                            s = this.data;
                        return s[0] = i[0] + n[0], s[1] = i[1] + n[1], s[2] = i[2] + n[2], s[3] = i[3] + n[3], s[4] = i[4] + n[4], s[5] = i[5] + n[5], s[6] = i[6] + n[6], s[7] = i[7] + n[7], s[8] = i[8] + n[8], s[9] = i[9] + n[9], s[10] = i[10] + n[10], s[11] = i[11] + n[11], s[12] = i[12] + n[12], s[13] = i[13] + n[13], s[14] = i[14] + n[14], s[15] = i[15] + n[15], this
                    }
                    add(t) { return this.add2(this, t) }
                    clone() { return (new C).copy(this) }
                    copy(t) {
                        const e = t.data,
                            i = this.data;
                        return i[0] = e[0], i[1] = e[1], i[2] = e[2], i[3] = e[3], i[4] = e[4], i[5] = e[5], i[6] = e[6], i[7] = e[7], i[8] = e[8], i[9] = e[9], i[10] = e[10], i[11] = e[11], i[12] = e[12], i[13] = e[13], i[14] = e[14], i[15] = e[15], this
                    }
                    equals(t) {
                        const e = this.data,
                            i = t.data;
                        return e[0] === i[0] && e[1] === i[1] && e[2] === i[2] && e[3] === i[3] && e[4] === i[4] && e[5] === i[5] && e[6] === i[6] && e[7] === i[7] && e[8] === i[8] && e[9] === i[9] && e[10] === i[10] && e[11] === i[11] && e[12] === i[12] && e[13] === i[13] && e[14] === i[14] && e[15] === i[15]
                    }
                    isIdentity() { const t = this.data; return 1 === t[0] && 0 === t[1] && 0 === t[2] && 0 === t[3] && 0 === t[4] && 1 === t[5] && 0 === t[6] && 0 === t[7] && 0 === t[8] && 0 === t[9] && 1 === t[10] && 0 === t[11] && 0 === t[12] && 0 === t[13] && 0 === t[14] && 1 === t[15] }
                    mul2(t, e) {
                        let i, n, s, r;
                        const o = t.data,
                            a = e.data,
                            c = this.data,
                            h = o[0],
                            l = o[1],
                            u = o[2],
                            d = o[3],
                            p = o[4],
                            _ = o[5],
                            f = o[6],
                            m = o[7],
                            y = o[8],
                            g = o[9],
                            E = o[10],
                            A = o[11],
                            b = o[12],
                            C = o[13],
                            T = o[14],
                            S = o[15];
                        return i = a[0], n = a[1], s = a[2], r = a[3], c[0] = h * i + p * n + y * s + b * r, c[1] = l * i + _ * n + g * s + C * r, c[2] = u * i + f * n + E * s + T * r, c[3] = d * i + m * n + A * s + S * r, i = a[4], n = a[5], s = a[6], r = a[7], c[4] = h * i + p * n + y * s + b * r, c[5] = l * i + _ * n + g * s + C * r, c[6] = u * i + f * n + E * s + T * r, c[7] = d * i + m * n + A * s + S * r, i = a[8], n = a[9], s = a[10], r = a[11], c[8] = h * i + p * n + y * s + b * r, c[9] = l * i + _ * n + g * s + C * r, c[10] = u * i + f * n + E * s + T * r, c[11] = d * i + m * n + A * s + S * r, i = a[12], n = a[13], s = a[14], r = a[15], c[12] = h * i + p * n + y * s + b * r, c[13] = l * i + _ * n + g * s + C * r, c[14] = u * i + f * n + E * s + T * r, c[15] = d * i + m * n + A * s + S * r, this
                    }
                    mul(t) { return this.mul2(this, t) }
                    transformPoint(t, e = new P) {
                        const i = this.data,
                            n = t.x,
                            s = t.y,
                            r = t.z;
                        return e.x = n * i[0] + s * i[4] + r * i[8] + i[12], e.y = n * i[1] + s * i[5] + r * i[9] + i[13], e.z = n * i[2] + s * i[6] + r * i[10] + i[14], e
                    }
                    transformVector(t, e = new P) {
                        const i = this.data,
                            n = t.x,
                            s = t.y,
                            r = t.z;
                        return e.x = n * i[0] + s * i[4] + r * i[8], e.y = n * i[1] + s * i[5] + r * i[9], e.z = n * i[2] + s * i[6] + r * i[10], e
                    }
                    transformVec4(t, e = new y) {
                        const i = this.data,
                            n = t.x,
                            s = t.y,
                            r = t.z,
                            o = t.w;
                        return e.x = n * i[0] + s * i[4] + r * i[8] + o * i[12], e.y = n * i[1] + s * i[5] + r * i[9] + o * i[13], e.z = n * i[2] + s * i[6] + r * i[10] + o * i[14], e.w = n * i[3] + s * i[7] + r * i[11] + o * i[15], e
                    }
                    setLookAt(t, e, i) {
                        const n = b.tmpVec31,
                            s = b.tmpVec32,
                            r = b.tmpVec33;
                        if (r.sub2(e, t), r.length() < 1e-6) return this.setIdentity();
                        r.normalize(), s.copy(i).normalize(), n.cross(s, r).normalize(), s.cross(r, n);
                        const o = this.data;
                        return o[0] = n.x, o[1] = n.y, o[2] = n.z, o[3] = 0, o[4] = s.x, o[5] = s.y, o[6] = s.z, o[7] = 0, o[8] = r.x, o[9] = r.y, o[10] = r.z, o[11] = 0, o[12] = t.x, o[13] = t.y, o[14] = t.z, o[15] = 1, this
                    }
                    setFrustum(t, e, i, n, s, r) {
                        const o = 2 * s,
                            a = e - t,
                            c = n - i,
                            h = r - s,
                            l = this.data;
                        return l[0] = o / a, l[1] = 0, l[2] = 0, l[3] = 0, l[4] = 0, l[5] = o / c, l[6] = 0, l[7] = 0, l[8] = -(e + t) / a, l[9] = -(n + i) / c, l[10] = (-r - s) / h, l[11] = -1, l[12] = 0, l[13] = 0, l[14] = -o * r / h, l[15] = 0, this
                    }
                    setPerspective(t, e, i, n, s = !1) { let r, o; return s ? (r = i * Math.tan(t * Math.PI / 360), o = r / e) : (o = i * Math.tan(t * Math.PI / 360), r = o * e), this.setFrustum(-r, r, -o, o, i, n) }
                    setOrtho(t, e, i, n, s, r) { const o = this.data; return o[0] = 2 / (e - t), o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = 2 / (n - i), o[6] = 0, o[7] = 0, o[8] = 0, o[9] = 0, o[10] = -2 / (r - s), o[11] = 0, o[12] = -(e + t) / (e - t), o[13] = -(n + i) / (n - i), o[14] = -(r + s) / (r - s), o[15] = 1, this }
                    setFromAxisAngle(t, e) {
                        e *= n;
                        const i = t.x,
                            s = t.y,
                            r = t.z,
                            o = Math.cos(e),
                            a = Math.sin(e),
                            c = 1 - o,
                            h = c * i,
                            l = c * s,
                            u = this.data;
                        return u[0] = h * i + o, u[1] = h * s + a * r, u[2] = h * r - a * s, u[3] = 0, u[4] = h * s - a * r, u[5] = l * s + o, u[6] = l * r + a * i, u[7] = 0, u[8] = h * r + a * s, u[9] = l * r - i * a, u[10] = c * r * r + o, u[11] = 0, u[12] = 0, u[13] = 0, u[14] = 0, u[15] = 1, this
                    }
                    setTranslate(t, e, i) { const n = this.data; return n[0] = 1, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = 1, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[10] = 1, n[11] = 0, n[12] = t, n[13] = e, n[14] = i, n[15] = 1, this }
                    setScale(t, e, i) { const n = this.data; return n[0] = t, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = e, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[10] = i, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, this }
                    invert() {
                        const t = this.data,
                            e = t[0],
                            i = t[1],
                            n = t[2],
                            s = t[3],
                            r = t[4],
                            o = t[5],
                            a = t[6],
                            c = t[7],
                            h = t[8],
                            l = t[9],
                            u = t[10],
                            d = t[11],
                            p = t[12],
                            _ = t[13],
                            f = t[14],
                            m = t[15],
                            y = e * o - i * r,
                            g = e * a - n * r,
                            E = e * c - s * r,
                            A = i * a - n * o,
                            b = i * c - s * o,
                            C = n * c - s * a,
                            T = h * _ - l * p,
                            S = h * f - u * p,
                            M = h * m - d * p,
                            x = l * f - u * _,
                            P = l * m - d * _,
                            O = u * m - d * f,
                            R = y * O - g * P + E * x + A * M - b * S + C * T;
                        if (0 === R) this.setIdentity();
                        else {
                            const v = 1 / R;
                            t[0] = (o * O - a * P + c * x) * v, t[1] = (-i * O + n * P - s * x) * v, t[2] = (_ * C - f * b + m * A) * v, t[3] = (-l * C + u * b - d * A) * v, t[4] = (-r * O + a * M - c * S) * v, t[5] = (e * O - n * M + s * S) * v, t[6] = (-p * C + f * E - m * g) * v, t[7] = (h * C - u * E + d * g) * v, t[8] = (r * P - o * M + c * T) * v, t[9] = (-e * P + i * M - s * T) * v, t[10] = (p * b - _ * E + m * y) * v, t[11] = (-h * b + l * E - d * y) * v, t[12] = (-r * x + o * S - a * T) * v, t[13] = (e * x - i * S + n * T) * v, t[14] = (-p * A + _ * g - f * y) * v, t[15] = (h * A - l * g + u * y) * v
                        }
                        return this
                    }
                    set(t) { const e = this.data; return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], this }
                    setFromArray(t, e = 0) { const i = this.data; for (let n = 0; n < 16; n++) i[n] = t[e + n]; return this }
                    setIdentity() { const t = this.data; return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this }
                    setTRS(t, e, i) {
                        const n = t.x,
                            s = t.y,
                            r = t.z,
                            o = e.x,
                            a = e.y,
                            c = e.z,
                            h = e.w,
                            l = i.x,
                            u = i.y,
                            d = i.z,
                            p = o + o,
                            _ = a + a,
                            f = c + c,
                            m = o * p,
                            y = o * _,
                            g = o * f,
                            E = a * _,
                            A = a * f,
                            b = c * f,
                            C = h * p,
                            T = h * _,
                            S = h * f,
                            M = this.data;
                        return M[0] = (1 - (E + b)) * l, M[1] = (y + S) * l, M[2] = (g - T) * l, M[3] = 0, M[4] = (y - S) * u, M[5] = (1 - (m + b)) * u, M[6] = (A + C) * u, M[7] = 0, M[8] = (g + T) * d, M[9] = (A - C) * d, M[10] = (1 - (m + E)) * d, M[11] = 0, M[12] = n, M[13] = s, M[14] = r, M[15] = 1, this
                    }
                    transpose() { let t; const e = this.data; return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this }
                    invertTo3x3(t) {
                        const e = this.data,
                            i = t.data,
                            n = e[0],
                            s = e[1],
                            r = e[2],
                            o = e[4],
                            a = e[5],
                            c = e[6],
                            h = e[8],
                            l = e[9],
                            u = e[10],
                            d = u * a - c * l,
                            p = -u * s + r * l,
                            _ = c * s - r * a,
                            f = -u * o + c * h,
                            m = u * n - r * h,
                            y = -c * n + r * o,
                            g = l * o - a * h,
                            E = -l * n + s * h,
                            A = a * n - s * o,
                            b = n * d + s * f + r * g;
                        if (0 === b) return this;
                        const C = 1 / b;
                        return i[0] = C * d, i[1] = C * p, i[2] = C * _, i[3] = C * f, i[4] = C * m, i[5] = C * y, i[6] = C * g, i[7] = C * E, i[8] = C * A, this
                    }
                    getTranslation(t = new P) { return t.set(this.data[12], this.data[13], this.data[14]) }
                    getX(t = new P) { return t.set(this.data[0], this.data[1], this.data[2]) }
                    getY(t = new P) { return t.set(this.data[4], this.data[5], this.data[6]) }
                    getZ(t = new P) { return t.set(this.data[8], this.data[9], this.data[10]) }
                    getScale(t = new P) {
                        const e = b.tmpVec31,
                            i = b.tmpVec32,
                            n = b.tmpVec33;
                        return this.getX(e), this.getY(i), this.getZ(n), t.set(e.length(), i.length(), n.length()), t
                    }
                    setFromEulerAngles(t, e, i) {
                        t *= n, e *= n, i *= n;
                        const s = Math.sin(-t),
                            r = Math.cos(-t),
                            o = Math.sin(-e),
                            a = Math.cos(-e),
                            c = Math.sin(-i),
                            h = Math.cos(-i),
                            l = this.data;
                        return l[0] = a * h, l[1] = -a * c, l[2] = o, l[3] = 0, l[4] = r * c + h * s * o, l[5] = r * h - s * o * c, l[6] = -a * s, l[7] = 0, l[8] = s * c - r * h * o, l[9] = h * s + r * o * c, l[10] = r * a, l[11] = 0, l[12] = 0, l[13] = 0, l[14] = 0, l[15] = 1, this
                    }
                    getEulerAngles(t = new P) {
                        const e = b.tmpVec31;
                        this.getScale(e);
                        const i = e.x,
                            n = e.y,
                            r = e.z,
                            o = this.data,
                            a = Math.asin(-o[2] / i),
                            c = .5 * Math.PI;
                        let h = 0,
                            l = 0;
                        return a < c ? a > -c ? (h = Math.atan2(o[6] / n, o[10] / r), l = Math.atan2(o[1] / i, o[0] / i)) : (l = 0, h = -Math.atan2(o[4] / n, o[5] / n)) : (l = 0, h = Math.atan2(o[4] / n, o[5] / n)), t.set(h, a, l).scale(s)
                    }
                    toString() { let t, e; for (e = "[", t = 0; t < 16; t += 1) e += this.data[t], e += 15 !== t ? ", " : ""; return e += "]", e }
                    setColumn(t, e) { return this.data[4 * t] = e.x, this.data[4 * t + 1] = e.y, this.data[4 * t + 2] = e.z, this.data[4 * t + 3] = e.w, this }
                    getColumn(t) {
                        switch (t) {
                            case 0:
                                return new y(this.data[0], this.data[1], this.data[2], this.data[3]);
                            case 1:
                                return new y(this.data[4], this.data[5], this.data[6], this.data[7]);
                            case 2:
                                return new y(this.data[8], this.data[9], this.data[10], this.data[11]);
                            case 3:
                                return new y(this.data[12], this.data[13], this.data[14], this.data[15]);
                            default:
                                return null
                        }
                    }
                    getRow(t) {
                        switch (t) {
                            case 0:
                                return new y(this.data[0], this.data[4], this.data[8], this.data[12]);
                            case 1:
                                return new y(this.data[1], this.data[5], this.data[9], this.data[13]);
                            case 2:
                                return new y(this.data[2], this.data[6], this.data[10], this.data[14]);
                            case 3:
                                return new y(this.data[3], this.data[7], this.data[11], this.data[15]);
                            default:
                                return null
                        }
                    }
                    scale(t) { for (let e = 0; e < 16; e++) this.data[e] *= t }
                    determinant() {
                        const t = this.data,
                            e = t[0],
                            i = t[1],
                            n = t[2],
                            s = t[3],
                            r = t[4],
                            o = t[5],
                            a = t[6],
                            c = t[7],
                            h = t[8],
                            l = t[9],
                            u = t[10],
                            d = t[11],
                            p = t[12],
                            _ = t[13],
                            f = t[14],
                            m = t[15];
                        return (e * o - i * r) * (u * m - d * f) - (e * a - n * r) * (l * m - d * _) + (e * c - s * r) * (l * f - u * _) + (i * a - n * o) * (h * m - d * p) - (i * c - s * o) * (h * f - u * p) + (n * c - s * a) * (h * _ - l * p)
                    }
                    getRotation(t = new S) { return t.setFromMat4(this), t }
                    multiplyInverse(t) {
                        const e = b.tmpVec31,
                            i = b.tmpVec32,
                            n = b.tmpQuat1,
                            s = b.tmpQuat2;
                        s.setFromMat4(this).conjugate(), n.setFromMat4(t), t.getTranslation(i), this.getTranslation(e), i.sub(e), s.transformVector(i, i), s.mul(n), this.setTRS(i, s, P.ONE)
                    }
                    transformVectorInverse(t, e = new P) {
                        const i = b.tmpQuat1,
                            n = b.tmpVec31;
                        return i.setFromMat4(this), this.getTranslation(n), e.sub2(t, n), i.transformVectorInverse(e, e), e
                    }
                    setRotation(t) { return this.setTRS(P.ZERO, t, P.ONE) }
                    setTranslation(t) { const e = this.data; return e[12] = t.x, e[13] = t.y, e[14] = t.z, this }
                    setPerspective_Unity(t, e, i, n, s = !1) { return this.setPerspective(t, e, i, n, s), this.data[8] *= -1, this.data[9] *= -1, this.data[10] *= -1, this.data[11] *= -1, this }
                    multiplyPoint(t, e = new P) {
                        const i = this.data,
                            n = t.x,
                            s = t.y,
                            r = t.z;
                        e.x = n * i[0] + s * i[4] + r * i[8] + i[12], e.y = n * i[1] + s * i[5] + r * i[9] + i[13], e.z = n * i[2] + s * i[6] + r * i[10] + i[14];
                        const o = 1 / (n * i[3] + s * i[7] + r * i[11] + i[15]);
                        return e.scale(o), e
                    }
                    setData(t, e, i, n, s, r, o, a, c, h, l, u, d, p, _, f) { return this.data[0] = t, this.data[1] = e, this.data[2] = i, this.data[3] = n, this.data[4] = s, this.data[5] = r, this.data[6] = o, this.data[7] = a, this.data[8] = c, this.data[9] = h, this.data[10] = l, this.data[11] = u, this.data[12] = d, this.data[13] = p, this.data[14] = _, this.data[15] = f, this }
                    validTRS() { return !(Math.abs(this.data[3]) > 1e-5 || Math.abs(this.data[7]) > 1e-5 || Math.abs(this.data[11]) > 1e-5 || Math.abs(this.data[15] - 1) > 1e-5) && Math.abs(this.determinant()) >= 1e-5 }
                    decomposeProjection() { const t = new UnityEngine.FrustumPlanes.ctor; return t.zFar = (this.data[15] - this.data[14]) / (this.data[11] - this.data[10]), t.zNear = (this.data[15] + this.data[14]) / (this.data[11] + this.data[10]), t.left = (this.data[11] + this.data[8]) / (this.data[3] + this.data[0]) * t.zNear, t.right = (this.data[11] - this.data[8]) / (this.data[3] - this.data[0]) * t.zNear, t.top = (this.data[11] - this.data[9]) / (this.data[7] - this.data[5]) * t.zNear, t.bottom = (this.data[11] + this.data[9]) / (this.data[7] + this.data[5]) * t.zNear, t }
                    transformPlane(t) {
                        const e = this.clone().invert(),
                            i = t.normal.x,
                            n = t.normal.y,
                            s = t.normal.z,
                            r = t.distance;
                        return new UnityEngine.Plane.$ctor1(new P(e.e00 * i + e.e10 * n + e.e20 * s + e.e30 * r, e.e01 * i + e.e11 * n + e.e21 * s + e.e31 * r, e.e02 * i + e.e12 * n + e.e22 * s + e.e32 * r), e.e03 * i + e.e13 * n + e.e23 * s + e.e33 * r)
                    }
                    strictEquals(t) { return t instanceof C && this.equals(t) }
                    $clone(t = new C) { return t.copy(this), t }
                    equalsWithEpsilon(t, e = 1e-6) {
                        const i = this.data,
                            n = t.data;
                        for (let t = 0; t < 16; t++)
                            if (Math.abs(i[t] - n[t]) >= e) return !1;
                        return !0
                    }
                    get e00() { return this.data[0] }
                    set e00(t) { this.data[0] = t }
                    get e10() { return this.data[1] }
                    set e10(t) { this.data[1] = t }
                    get e20() { return this.data[2] }
                    set e20(t) { this.data[2] = t }
                    get e30() { return this.data[3] }
                    set e30(t) { this.data[3] = t }
                    get e01() { return this.data[4] }
                    set e01(t) { this.data[4] = t }
                    get e11() { return this.data[5] }
                    set e11(t) { this.data[5] = t }
                    get e21() { return this.data[6] }
                    set e21(t) { this.data[6] = t }
                    get e31() { return this.data[7] }
                    set e31(t) { this.data[7] = t }
                    get e02() { return this.data[8] }
                    set e02(t) { this.data[8] = t }
                    get e12() { return this.data[9] }
                    set e12(t) { this.data[9] = t }
                    get e22() { return this.data[10] }
                    set e22(t) { this.data[10] = t }
                    get e32() { return this.data[11] }
                    set e32(t) { this.data[11] = t }
                    get e03() { return this.data[12] }
                    set e03(t) { this.data[12] = t }
                    get e13() { return this.data[13] }
                    set e13(t) { this.data[13] = t }
                    get e23() { return this.data[14] }
                    set e23(t) { this.data[14] = t }
                    get e33() { return this.data[15] }
                    set e33(t) { this.data[15] = t }
                    get singular() { return 0 === this.determinant() }
                    getitem(t) { return this.data[t] }
                    iget(t) { return this.getitem(t) }
                    setitem(t, e) { this.data[t] = e }
                    iset(t, e) { this.setitem(t, e) }
                    getitem$1(t, e) { return this.data[t + 4 * e] }
                    ijget(t, e) { return this.getitem$1(t, e) }
                    setitem$1(t, e, i) { this.data[t + 4 * e] = i }
                    ijset(t, e, i) { this.setitem$1(t, e, i) }
                    getHashCode() { let t = this.data[0]; for (let e = 0; e < this.data.length; e++) t ^= this.data[e]; return t }
                    hash() { return this.getHashCode() }
                }
                C.ctor = C, C.$kind = "struct", C.fromArray = t => { const e = new C; return e.data = t, e }, C.getDefaultValue = () => new C, C.mat3FromMat4 = (t, e) => { t.data[0] = e.data[0], t.data[1] = e.data[1], t.data[2] = e.data[2], t.data[3] = e.data[4], t.data[4] = e.data[5], t.data[5] = e.data[6], t.data[6] = e.data[8], t.data[7] = e.data[9], t.data[8] = e.data[10] }, C.inverse3DAffine = (t, e) => { e.v = t.clone().invert() }, C.setFrustumUnity = (t, e, i, n, s, r) => {
                    const o = 2 * s,
                        a = e - t,
                        c = n - i,
                        h = s - r,
                        l = new C;
                    return l.data[0] = o / a, l.data[1] = 0, l.data[2] = 0, l.data[3] = 0, l.data[4] = 0, l.data[5] = o / c, l.data[6] = 0, l.data[7] = 0, l.data[8] = (e + t) / a, l.data[9] = (n + i) / c, l.data[10] = (r + s) / h, l.data[11] = -1, l.data[12] = 0, l.data[13] = 0, l.data[14] = o * r / h, l.data[15] = 0, l
                }, C.setLookAtUnity = (t, e, i) => {
                    const n = new C,
                        s = new P,
                        r = new P,
                        o = new P;
                    if (o.sub2(e, t), o.length() < 1e-6) return n.setIdentity();
                    o.normalize(), r.copy(i).normalize(), s.cross(r, o).normalize(), r.cross(o, s), n.data[0] = -s.x, n.data[1] = s.y, n.data[2] = -s.z, n.data[3] = 0, n.data[4] = r.x, n.data[5] = r.y, n.data[6] = r.z, n.data[7] = 0, n.data[8] = -o.x, n.data[9] = -o.y, n.data[10] = -o.z, n.data[11] = 0, n.data[12] = t.x, n.data[13] = t.y, n.data[14] = t.z, n.data[15] = 1
                }, C.equals = (t, e) => null === t && null === e || null !== t && null !== e && t.equals(e), C.IDENTITY = Object.freeze(new C), C.ZERO = Object.freeze((new C).set([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]));
                const T = { _tmpVec31: null, get tmpVec31() { return this._tmpVec31 = this._tmpVec31 || new P, this._tmpVec31 } };
                class S {
                    constructor(t = 0, e = 0, i = 0, n = 1) { this.x = t, this.y = e, this.z = i, this.w = n }
                    clone() { return new S(this.x, this.y, this.z, this.w) }
                    conjugate() { return this.x *= -1, this.y *= -1, this.z *= -1, this }
                    copy(t) { return this.x = t.x, this.y = t.y, this.z = t.z, this.w = t.w, this }
                    equals(t) { return this.dot(t) > .999998986721039 }
                    dot(t) { return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w }
                    negate() { return this.x *= -1, this.y *= -1, this.z *= -1, this.w *= -1, this }
                    transformVectorInverse(t, e = new P) {
                        const i = 2 * t.x,
                            n = 2 * t.y,
                            s = 2 * t.z,
                            r = this.w * this.w - .5,
                            o = this.x * i + this.y * n + this.z * s;
                        return e.x = i * r - (this.y * s - this.z * n) * this.w + this.x * o, e.y = n * r - (this.z * i - this.x * s) * this.w + this.y * o, e.z = s * r - (this.x * n - this.y * i) * this.w + this.z * o, e
                    }
                    extractAxes(t, e, i) {
                        const n = this.x,
                            s = this.y,
                            r = this.z,
                            o = this.w,
                            a = n + n,
                            c = s + s,
                            h = r + r,
                            l = a * n,
                            u = c * s,
                            d = h * r,
                            p = a * s,
                            _ = a * r,
                            f = a * o,
                            m = c * r,
                            y = c * o,
                            g = h * o;
                        t.set(1 - u - d, p + g, _ - y), e.set(p - g, 1 - l - d, m + f), i.set(_ + y, m - f, 1 - l - u)
                    }
                    getAxisAngle(t) { let e = 2 * Math.acos(this.w); const i = Math.sin(e / 2); return 0 !== i ? (t.x = this.x / i, t.y = this.y / i, t.z = this.z / i, (t.x < 0 || t.y < 0 || t.z < 0) && (t.x *= -1, t.y *= -1, t.z *= -1, e *= -1)) : (t.x = 1, t.y = 0, t.z = 0), e * s }
                    getEulerAngles(t = new P) {
                        let e, i, n;
                        const r = this.x,
                            o = this.y,
                            a = this.z,
                            c = this.w,
                            h = 2 * (c * o - r * a);
                        return h <= -.99999 ? (e = 2 * Math.atan2(r, c), i = -Math.PI / 2, n = 0) : h >= .99999 ? (e = 2 * Math.atan2(r, c), i = Math.PI / 2, n = 0) : (e = Math.atan2(2 * (c * r + o * a), 1 - 2 * (r * r + o * o)), i = Math.asin(h), n = Math.atan2(2 * (c * a + r * o), 1 - 2 * (o * o + a * a))), t.set(e, i, n).scale(s)
                    }
                    getUnityEulerAngles() {
                        const t = new C,
                            e = new P,
                            i = new P(1, 0, 0),
                            n = new P(0, 1, 0),
                            o = new P(0, 0, 1);
                        this.transformVector(i, i), this.transformVector(n, n), this.transformVector(o, o), t.data[0] = i.x, t.data[1] = i.y, t.data[2] = i.z, t.data[4] = n.x, t.data[5] = n.y, t.data[6] = n.z, t.data[8] = o.x, t.data[9] = o.y, t.data[10] = o.z, t.data[15] = 1;
                        const a = t.data,
                            c = a[0],
                            h = a[8],
                            l = a[1],
                            u = a[5],
                            d = a[9],
                            p = a[2],
                            _ = a[10];
                        return e.x = Math.asin(-r(d, -1, 1)), Math.abs(d) < .99999 ? (e.y = Math.atan2(h, _), e.z = Math.atan2(l, u)) : (e.y = Math.atan2(-p, c), e.z = 0), e.scale(s), e
                    }
                    invert() { return this.conjugate().normalize() }
                    length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w) }
                    lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w }
                    mul(t) {
                        const e = this.x,
                            i = this.y,
                            n = this.z,
                            s = this.w,
                            r = t.x,
                            o = t.y,
                            a = t.z,
                            c = t.w;
                        return this.x = s * r + e * c + i * a - n * o, this.y = s * o + i * c + n * r - e * a, this.z = s * a + n * c + e * o - i * r, this.w = s * c - e * r - i * o - n * a, this
                    }
                    mul2(t, e) {
                        const i = t.x,
                            n = t.y,
                            s = t.z,
                            r = t.w,
                            o = e.x,
                            a = e.y,
                            c = e.z,
                            h = e.w;
                        return this.x = r * o + i * h + n * c - s * a, this.y = r * a + n * h + s * o - i * c, this.z = r * c + s * h + i * a - n * o, this.w = r * h - i * o - n * a - s * c, this
                    }
                    nearest(t, e = new S) {
                        const i = (this.x - t.x) * (this.x - t.x) + (this.y - t.y) * (this.y - t.y) + (this.z - t.z) * (this.z - t.z) + (this.w - t.w) * (this.w - t.w),
                            n = (this.x + t.x) * (this.x + t.x) + (this.y + t.y) * (this.y + t.y) + (this.z + t.z) * (this.z + t.z) + (this.w + t.w) * (this.w + t.w);
                        return e.copy(t), i > n && (e.x *= -1, e.y *= -1, e.z *= -1, e.w *= -1), e
                    }
                    normalize() { let t = this.length(); return 0 === t ? (this.x = this.y = this.z = 0, this.w = 1) : (t = 1 / t, this.x *= t, this.y *= t, this.z *= t, this.w *= t), this }
                    set(t, e, i, n) { return this.x = t, this.y = e, this.z = i, this.w = n, this }
                    fromTo(t, e) {
                        const i = t.length(),
                            n = t.x / i,
                            s = t.y / i,
                            r = t.z / i,
                            o = e.length(),
                            a = e.x / o,
                            c = e.y / o,
                            h = e.z / o;
                        this.w = Math.cos(Math.acos(n * a + s * c + r * h) / 2);
                        const l = Math.sqrt(1 - this.w * this.w);
                        if (this.x = (s * h - c * r) * l, this.y = (r * a - h * n) * l, this.z = (n * c - a * s) * l, this.lengthSq() < Number.EPSILON) {
                            const t = Math.abs(e.x),
                                i = Math.abs(e.y),
                                n = Math.abs(e.z),
                                s = t < i ? t < n ? P.RIGHT : P.FORWARD : i < n ? P.UP : P.FORWARD;
                            this.x = e.y * s.z - s.y * e.z, this.y = e.z * s.x - s.z * e.x, this.z = e.x * s.y - s.x * e.y;
                            const r = 1 / this.length();
                            this.x *= r, this.y *= r, this.z *= r
                        }
                        return this
                    }
                    setFromAxisAngle(t, e) {
                        const { tmpVec31: i } = T;
                        if (t.equalsWithEpsilon(P.ZERO)) return this.x = 0, this.y = 0, this.z = 0, this.w = 1, this;
                        e *= .5 * n, i.copy(t).normalize();
                        const s = Math.sin(e),
                            r = Math.cos(e);
                        return this.x = s * i.x, this.y = s * i.y, this.z = s * i.z, this.w = r, this
                    }
                    setFromEulerAngles(t, e, i) {
                        const s = .5 * n;
                        t *= s, e *= s, i *= s;
                        const r = Math.sin(t),
                            o = Math.cos(t),
                            a = Math.sin(e),
                            c = Math.cos(e),
                            h = Math.sin(i),
                            l = Math.cos(i);
                        return this.x = r * c * l - o * a * h, this.y = o * a * l + r * c * h, this.z = o * c * h - r * a * l, this.w = o * c * l + r * a * h, this
                    }
                    setFromMat4(t) {
                        let e, i, n = t.data[0],
                            s = t.data[1],
                            r = t.data[2],
                            o = t.data[4],
                            a = t.data[5],
                            c = t.data[6],
                            h = t.data[8],
                            l = t.data[9],
                            u = t.data[10],
                            d = 1 / Math.sqrt(n * n + s * s + r * r),
                            p = 1 / Math.sqrt(o * o + a * a + c * c),
                            _ = 1 / Math.sqrt(h * h + l * l + u * u);
                        d = Number.isFinite(d) ? d : 1, p = Number.isFinite(p) ? p : 1, _ = Number.isFinite(_) ? _ : 1, n *= d, s *= d, r *= d, o *= p, a *= p, c *= p, h *= _, l *= _, u *= _;
                        const f = n + a + u;
                        return f >= 0 ? (e = Math.sqrt(f + 1), this.w = .5 * e, e = .5 / e, this.x = (c - l) * e, this.y = (h - r) * e, this.z = (s - o) * e) : n > a ? n > u ? (i = n - (a + u) + 1, i = Math.sqrt(i), this.x = .5 * i, i = .5 / i, this.w = (c - l) * i, this.y = (s + o) * i, this.z = (r + h) * i) : (i = u - (n + a) + 1, i = Math.sqrt(i), this.z = .5 * i, i = .5 / i, this.w = (s - o) * i, this.x = (h + r) * i, this.y = (l + c) * i) : a > u ? (i = a - (u + n) + 1, i = Math.sqrt(i), this.y = .5 * i, i = .5 / i, this.w = (h - r) * i, this.z = (c + l) * i, this.x = (o + s) * i) : (i = u - (n + a) + 1, i = Math.sqrt(i), this.z = .5 * i, i = .5 / i, this.w = (s - o) * i, this.x = (h + r) * i, this.y = (l + c) * i), this
                    }
                    slerp(t, e, i) { return i = r(i, 0, 1), this.slerpUnclamped(t, e, i) }
                    slerpUnclamped(t, e, i) {
                        let n, s, r, o;
                        const a = t.x,
                            c = t.y,
                            h = t.z,
                            l = t.w;
                        n = e.x, s = e.y, r = e.z, o = e.w;
                        let u = l * o + a * n + c * s + h * r;
                        if (u < 0 && (o = -o, n = -n, s = -s, r = -r, u = -u), Math.abs(u) >= 1) return this.w = l, this.x = a, this.y = c, this.z = h, this;
                        const d = Math.acos(u),
                            p = Math.sqrt(1 - u * u);
                        if (Math.abs(p) < .001) return this.w = .5 * l + .5 * o, this.x = .5 * a + .5 * n, this.y = .5 * c + .5 * s, this.z = .5 * h + .5 * r, this;
                        const _ = Math.sin((1 - i) * d) / p,
                            f = Math.sin(i * d) / p;
                        return this.w = l * _ + o * f, this.x = a * _ + n * f, this.y = c * _ + s * f, this.z = h * _ + r * f, this
                    }
                    transformVector(t, e = new P) {
                        const i = t.x,
                            n = t.y,
                            s = t.z,
                            r = this.x,
                            o = this.y,
                            a = this.z,
                            c = this.w,
                            h = c * i + o * s - a * n,
                            l = c * n + a * i - r * s,
                            u = c * s + r * n - o * i,
                            d = -r * i - o * n - a * s;
                        return e.x = h * c + d * -r + l * -a - u * -o, e.y = l * c + d * -o + u * -r - h * -a, e.z = u * c + d * -a + h * -o - l * -r, e
                    }
                    toString() { return "[" + this.x + ", " + this.y + ", " + this.z + ", " + this.w + "]" }
                    setLookAt(t, e) { if (t.equals(P.ZERO)) return this.copy(S.IDENTITY); const i = (new C).setLookAt(P.ZERO, t, e); return this.setFromMat4(i), this }
                    getitem(t) {
                        switch (t) {
                            case 0:
                                return this.x;
                            case 1:
                                return this.y;
                            case 2:
                                return this.z;
                            case 3:
                                return this.w;
                            default:
                                return NaN
                        }
                    }
                    iget(t) { return this.getitem(t) }
                    setitem(t, e) {
                        switch (t) {
                            case 0:
                                this.x = e;
                                break;
                            case 1:
                                this.y = e;
                                break;
                            case 2:
                                this.z = e;
                                break;
                            case 3:
                                this.w = e
                        }
                    }
                    iset(t, e) { this.setitem(t, e) }
                    setFromEulerAngles_Unity(t, e, i) {
                        const s = t * n * .5,
                            r = e * n * .5,
                            o = i * n * .5,
                            a = Math.sin(s),
                            c = Math.cos(s),
                            h = Math.sin(r),
                            l = Math.cos(r),
                            u = Math.sin(o),
                            d = Math.cos(o);
                        return this.x = l * a * d + h * c * u, this.y = h * c * d - l * a * u, this.z = l * c * u - h * a * d, this.w = l * c * d + h * a * u, this
                    }
                    getEulerAngles_Unity(t = new P) {
                        const e = this,
                            i = e.x * e.x + e.y * e.y + e.z * e.z + e.w * e.w,
                            n = e.x * e.w - e.y * e.z;
                        return n > .4995 * i ? (t.x = Math.PI / 2, t.y = 2 * Math.atan2(e.y, e.x), t.z = 0) : n < -.4995 * i ? (t.x = -Math.PI / 2, t.y = -2 * Math.atan2(e.y, e.x), t.z = 0) : (t.x = Math.asin(2 * (e.w * e.x - e.y * e.z)), t.y = Math.atan2(2 * e.w * e.y + 2 * e.z * e.x, 1 - 2 * (e.x * e.x + e.y * e.y)), t.z = Math.atan2(2 * e.w * e.z + 2 * e.x * e.y, 1 - 2 * (e.z * e.z + e.x * e.x))), t.x *= s, t.y *= s, t.z *= s, t.x += t.x < 0 ? 360 : 0, t.y += t.y < 0 ? 360 : 0, t.z += t.z < 0 ? 360 : 0, t
                    }
                    getPositiveEulerAngles() { return this.getEulerAngles_Unity() }
                    fromToRotation(t, e) {
                        const i = new P;
                        i.cross(t, e);
                        const n = new S;
                        return n.x = i.x, n.y = i.y, n.z = i.z, n.w = Math.sqrt(t.lengthSq() * e.lengthSq()) + t.dot(e), n.normalize()
                    }
                    strictEquals(t) { return t instanceof S && this.equals(t) }
                    approximatelyEquals(t, e = 1e-5) { return Math.abs(this.x - t.x) < e && Math.abs(this.y - t.y) < e && Math.abs(this.z - t.z) < e && Math.abs(this.w - t.w) < e }
                    toAngleAxis(t, e) {
                        const i = this.$clone().normalize();
                        t.v = 2 * Math.acos(i.w) * s;
                        const n = Math.sqrt(1 - i.w * i.w);
                        n < 1e-4 ? (e.v.x = 1, e.v.z = e.v.y = 0) : (e.v.x = i.x / n, e.v.y = i.y / n, e.v.z = i.z / n)
                    }
                    $clone(t = new S) { return t.copy(this), t }
                    get xyz() { return new P(this.x, this.y, this.z) }
                }
                S.ctor = S, S.$kind = "struct", S.getDefaultValue = () => new S, S.rotateTowards = (t, e, i) => { const n = S.angle(t, e); if (n < 1401298e-51) return e; return (new S).slerpUnclamped(t, e, Math.min(1, i / n)) }, S.angle = (t, e) => { const i = t.dot(e); let n = 0; return i < .999998986721039 && (n = 2 * Math.acos(Math.min(Math.abs(i), 1)) * s), n }, S.IDENTITY = Object.freeze(new S), S.ZERO = Object.freeze(new S(0, 0, 0, 0));
                const M = { tmpVec31: null, tmpVec32: null, diff: null, _tmpQuat1: null, _tmpQuat2: null, get tmpQuat1() { return this._tmpQuat1 = this._tmpQuat1 || new S, this._tmpQuat1 }, get tmpQuat2() { return this._tmpQuat2 = this._tmpQuat2 || new S, this._tmpQuat2 } };

                function x(t) { return Math.abs(t) > 1e-5 ? 1 / t : 0 }
                class P {
                    constructor(t = 0, e = 0, i = 0) { this.x = t, this.y = e, this.z = i, this._data = null }
                    add(t) { return this.x += t.x, this.y += t.y, this.z += t.z, this }
                    add2(t, e) { return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this }
                    clone() { return (new P).copy(this) }
                    copy(t) { return this.x = t.x, this.y = t.y, this.z = t.z, this }
                    cross(t, e) {
                        const i = t.x,
                            n = t.y,
                            s = t.z,
                            r = e.x,
                            o = e.y,
                            a = e.z;
                        return this.x = n * a - o * s, this.y = s * r - a * i, this.z = i * o - r * n, this
                    }
                    dot(t) { return this.x * t.x + this.y * t.y + this.z * t.z }
                    equals(t, e = 999999943962493e-25) { const i = M.diff; return i.copy(this), i.sub(t), i.lengthSq() < e }
                    length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z) }
                    lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z }
                    lerp(t, e, i) { return i = r(i, 0, 1), this.x = t.x + i * (e.x - t.x), this.y = t.y + i * (e.y - t.y), this.z = t.z + i * (e.z - t.z), this }
                    lerpUnclamped(t, e, i) { return this.x = t.x + i * (e.x - t.x), this.y = t.y + i * (e.y - t.y), this.z = t.z + i * (e.z - t.z), this }
                    mul(t) { return this.x *= t.x, this.y *= t.y, this.z *= t.z, this }
                    mul2(t, e) { return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this }
                    normalize() {
                        const t = this.x * this.x + this.y * this.y + this.z * this.z;
                        if (t > 0) {
                            const e = 1 / Math.sqrt(t);
                            this.x *= e, this.y *= e, this.z *= e
                        }
                        return this
                    }
                    project(t) { const e = (this.x * t.x + this.y * t.y + this.z * t.z) / (t.x * t.x + t.y * t.y + t.z * t.z); return this.x = t.x * e, this.y = t.y * e, this.z = t.z * e, this }
                    scale(t) { return this.x *= t, this.y *= t, this.z *= t, this }
                    set(t, e, i = 0) { return this.x = t, this.y = e, this.z = i, this }
                    sub(t) { return this.x -= t.x, this.y -= t.y, this.z -= t.z, this }
                    sub2(t, e) { return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this }
                    toString() { return "[" + this.x + ", " + this.y + ", " + this.z + "]" }
                    slerp(t, e, i) {
                        i = r(i, 0, 1);
                        const n = t.length();
                        if (n < Number.EPSILON) return this.copy(t);
                        const s = e.length();
                        if (s < Number.EPSILON) return this.copy(e);
                        const o = 1 - i,
                            a = t.dot(e) / (n * s);
                        if (a <= -1 || a >= 1) return this.copy(t).normalize().scale(o * n + i * s);
                        const c = Math.acos(a);
                        if (c < Number.EPSILON) return this.copy(t);
                        const h = Math.sin(c),
                            l = Math.sin(o * c) / h,
                            u = Math.sin(i * c) / h;
                        return this.set(t.x * l + e.x * u, t.y * l + e.y * u, t.z * l + e.z * u).normalize().scale(o * n + i * s)
                    }
                    slerpUnclamped(t, e, i) {
                        const n = t.length();
                        if (n < Number.EPSILON) return this.copy(t);
                        const s = e.length();
                        if (s < Number.EPSILON) return this.copy(e);
                        const r = 1 - i,
                            o = t.dot(e) / (n * s);
                        if (o <= -1 || o >= 1) return this.copy(t).normalize().scale(r * n + i * s);
                        const a = Math.acos(o);
                        if (a < Number.EPSILON) return this.copy(t);
                        const c = Math.sin(a),
                            h = Math.sin(r * a) / c,
                            l = Math.sin(i * a) / c;
                        return this.set(t.x * h + e.x * l, t.y * h + e.y * l, t.z * h + e.z * l).normalize().scale(r * n + i * s)
                    }
                    abs(t) { return t ? (t.x = this.x < 0 ? -this.x : this.x, t.y = this.y < 0 ? -this.y : this.y, t.z = this.z < 0 ? -this.z : this.z, t) : (this.x < 0 && (this.x = -this.x), this.y < 0 && (this.y = -this.y), this.z < 0 && (this.z = -this.z), this) }
                    strictEquals(t) { return t instanceof P && this.equals(t) }
                    approximatelyEquals(t, e = 1e-5) { return Math.abs(this.x - t.x) < e && Math.abs(this.y - t.y) < e && Math.abs(this.z - t.z) < e }
                    invertSafe() { return this.x = x(this.x), this.y = x(this.y), this.z = x(this.z), this }
                    $getType() { return P }
                    getitem(t) {
                        switch (t) {
                            case 0:
                                return this.x;
                            case 1:
                                return this.y;
                            case 2:
                                return this.z;
                            default:
                                return NaN
                        }
                    }
                    iget(t) { return this.getitem(t) }
                    setitem(t, e) {
                        switch (t) {
                            case 0:
                                this.x = e;
                                break;
                            case 1:
                                this.y = e;
                                break;
                            case 2:
                                this.z = e
                        }
                    }
                    iset(t, e) { this.setitem(t, e) }
                    getHashCode() { return this.x ^ this.y ^ this.z }
                    hash() { return this.getHashCode() }
                    $clone(t = new P) { return t.copy(this), t }
                    fromVector2(t) { return this.x = t.x, this.y = t.y, this.z = 0, this }
                    fromVector4(t) { return this.x = t.x, this.y = t.y, this.z = t.z, this }
                    equalsWithEpsilon(t, e = 1e-6) { return Math.abs(this.x - t.x) < e && Math.abs(this.y - t.y) < e && Math.abs(this.z - t.z) < e }
                    get data() { return this._data || (this._data = new Float32Array(3)), this._data[0] = this.x, this._data[1] = this.y, this._data[2] = this.z, this._data }
                }
                M.tmpVec31 = new P, M.tmpVec32 = new P, M.diff = new P, P.ctor = P, P.$kind = "struct", P.kEpsilon = 1e-5, P.kEpsilonNormalSqrt = 1e-15, P.REVERSED_Z = new P(1, 1, -1), P.cachedNegativeInfinity = new P(-1 / 0, -1 / 0, -1 / 0), P.cachedPositiveInfinity = new P(1 / 0, 1 / 0, 1 / 0), P.cachedForward = new P(0, 0, 1), P.cachedBack = new P(0, 0, -1), P.cachedOne = new P(1, 1, 1);
                const O = new P(0, 0, 1);
                O._data = new Float32Array(3), Object.freeze(O), P.BACK = O;
                const R = new P(0, -1, 0);
                R._data = new Float32Array(3), Object.freeze(R), P.DOWN = R;
                const v = new P(0, 0, -1);
                v._data = new Float32Array(3), Object.freeze(v), P.FORWARD = v;
                const D = new P(-1, 0, 0);
                D._data = new Float32Array(3), Object.freeze(D), P.LEFT = D;
                const w = new P(1, 1, 1);
                w._data = new Float32Array(3), Object.freeze(w), P.ONE = w;
                const I = new P(1, 0, 0);
                I._data = new Float32Array(3), Object.freeze(I), P.RIGHT = I;
                const F = new P(0, 1, 0);
                F._data = new Float32Array(3), Object.freeze(F), P.UP = F;
                const L = new P(0, 0, 0);
                L._data = new Float32Array(3), Object.freeze(L), P.ZERO = L, P.distance = (t, e) => M.tmpVec31.copy(t).sub(e).length(), P.projectOnPlane = (t, e, i = new P) => { const { tmpVec31: n, tmpVec32: s } = M; return n.copy(t), s.copy(t), n.sub(s.project(e)), i.copy(n), i }, P.smoothDamp = (t, e, i, n, s, r) => {
                    const o = 2 / (n = Math.max(1e-4, n)),
                        a = o * r,
                        c = 1 / (1 + a + .479999989271164 * a * a + .234999999403954 * a * a * a),
                        h = t.clone().sub(e.clone()),
                        l = e.clone(),
                        u = s * n,
                        d = P.clampMagnitude(h.clone(), u);
                    e = t.clone().sub(d.clone());
                    const p = i.v.clone().add(d.clone().scale(o)).scale(r);
                    i.v = i.v.clone().sub(p.clone().scale(o)).scale(c);
                    let _ = e.clone().add(d.clone().add(p.clone()).scale(c));
                    return l.clone().sub(t.clone()).dot(_.clone().sub(l.clone())) > 0 && (_ = l.clone(), i.v = _.clone().sub(l.clone()).scale(1 / r)), _.clone()
                }, P.clampMagnitude = (t, e) => t.length() > Math.abs(e) ? t.clone().normalize().scale(e) : t.clone(), P.reflect = (t, e) => { const { tmpVec31: i } = M; return i.copy(e), i.scale(-2 * t.dot(e)).add(t), i.clone() }, P.moveTowards = (t, e, i) => {
                    const n = M.tmpVec31.copy(e).sub(t),
                        s = n.length();
                    return s <= i || s < 1401298e-51 ? e.clone() : t.clone().add(n.scale(1 / s * i))
                }, P.orthoNormalize = (t, e, i) => { t.normalize(), e.cross(t, e), e.cross(e, t), e.normalize(), i.cross(t, e) }, P.signedAngle = (t, e, i) => {
                    const { tmpVec31: n, tmpVec32: o } = M;
                    n.copy(t).normalize(), o.copy(e).normalize();
                    const a = r(o.dot(n), -1, 1);
                    n.cross(t, e);
                    const c = i.dot(n);
                    return Math.acos(a) * h(c) * s
                }, P.rotateTowards = (t, e, i, n) => {
                    const { tmpVec31: r, tmpVec32: o, tmpQuat1: a, tmpQuat2: c } = M, l = r.cross(t, e), u = a.setLookAt(t, l), d = c.setLookAt(e, l), p = S.rotateTowards(u, d, i * s);
                    r.set(0, 0, 1);
                    const _ = p.transformVector(r, o),
                        f = e.length() - t.length(),
                        m = t.length() + h(f) * Math.min(Math.abs(f), n);
                    return _.normalize(), _.mul(new P(m, m, m)), _.clone()
                }, P.angle = (t, e) => { const { tmpVec31: i, tmpVec32: n } = M; return Math.acos(r(i.copy(t).normalize().dot(n.copy(e).normalize()), -1, 1)) * s }, P.equals = (t, e) => null === t && null === e || !!t && !!e && t.equals(e), P.getDefaultValue = () => new P, P.FromVector2 = t => new P(t.x, t.y, 0), P.FromVector4 = t => new P(t.x, t.y, t.z);
                const B = 1e-5;
                class U {
                    constructor(t = 0, e = 0, i = 0, n = 1) { this.r = t, this.g = e, this.b = i, this.a = n, this._data = null }
                    get data() { return this._data || (this._data = new Float32Array(4)), this._data[0] = this.r, this._data[1] = this.g, this._data[2] = this.b, this._data[3] = this.a, this._data }
                    clone() { return new U(this.r, this.g, this.b, this.a) }
                    copy(t) { return this.r = t.r, this.g = t.g, this.b = t.b, this.a = t.a, this }
                    set(t, e, i, n = 1) { return this.r = t, this.g = e, this.b = i, this.a = n, this }
                    setFromArray(t, e = 0) { return this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this.a = t[e + 3], this }
                    fromString(t) { const e = parseInt(t.replace("#", "0x"), 16); let i; return t.length > 7 ? i = a(e) : (i = o(e), i[3] = 255), this.set(i[0] / 255, i[1] / 255, i[2] / 255, i[3] / 255), this }
                    toString(t = !1) {
                        let e = "#" + ((1 << 24) + (Math.round(255 * this.r) << 16) + (Math.round(255 * this.g) << 8) + Math.round(255 * this.b)).toString(16).slice(1);
                        if (t) {
                            const t = Math.round(255 * this.a).toString(16);
                            this.a < 16 / 255 ? e += "0" + t : e += t
                        }
                        return e
                    }
                    getitem(t) {
                        switch (t) {
                            case 0:
                                return this.r;
                            case 1:
                                return this.g;
                            case 2:
                                return this.b;
                            case 3:
                                return this.a;
                            default:
                                return NaN
                        }
                    }
                    setitem(t, e) {
                        switch (t) {
                            case 0:
                                this.r = e;
                                break;
                            case 1:
                                this.g = e;
                                break;
                            case 2:
                                this.b = e;
                                break;
                            case 3:
                                this.a = e
                        }
                    }
                    premultiply() { return this.r *= this.a, this.g *= this.a, this.b *= this.a, this }
                    mul(t) { return this.r *= t.r, this.g *= t.g, this.b *= t.b, this.a *= t.a, this }
                    mul2(t, e) { return this.r = t.r * e.r, this.g = t.g * e.g, this.b = t.b * e.b, this.a = t.a * e.a, this }
                    scale(t) { return this.r *= t, this.g *= t, this.b *= t, this.a *= t, this }
                    toLinear() { return this.r = U.gammaToLinear(this.r), this.g = U.gammaToLinear(this.g), this.b = U.gammaToLinear(this.b), this }
                    equals(t) { return Math.abs(this.r - t.r) < B && Math.abs(this.g - t.g) < B && Math.abs(this.b - t.b) < B && Math.abs(this.a - t.a) < B }
                    getHashCode() { return this.r ^ this.g ^ this.b ^ this.a }
                    hash() { return this.getHashCode() }
                    strictEquals(t) { return t instanceof U && this.equals(t) }
                    lerpTo(t, e) { this.r = t.r * e + this.r * (1 - e), this.g = t.g * e + this.g * (1 - e), this.b = t.b * e + this.b * (1 - e), this.a = t.a * e + this.a * (1 - e) }
                    grayscale() { return .29899999499321 * this.r + .587000012397766 * this.g + .114 * this.b }
                    linear() { return new U(UnityEngine.Mathf.GammaToLinearSpace(this.r), UnityEngine.Mathf.GammaToLinearSpace(this.g), UnityEngine.Mathf.GammaToLinearSpace(this.b), this.a) }
                    gamma() { return new U(UnityEngine.Mathf.LinearToGammaSpace(this.r), UnityEngine.Mathf.LinearToGammaSpace(this.g), UnityEngine.Mathf.LinearToGammaSpace(this.b), this.a) }
                    maxColorComponent() { return Math.max(Math.max(this.r, this.g), this.b) }
                    $getType() { return U }
                    $clone(t = new U) { return t.copy(this), t }
                }
                U.ctor = U, U.$kind = "struct", U.gammaToLinear = t => t <= .04045 ? t / 12.92 : t < 1 ? Math.pow((t + .055) / 1.055, 2.4) : Math.pow(t, 2.2), U.hsvToRGB = (t, e, i, n) => {
                    let s = 0,
                        o = 0,
                        a = 0;
                    const c = Math.floor(6 * t),
                        h = 6 * t - c;
                    switch (c % 6) {
                        case 0:
                            s = i, o = i * (1 - (1 - h) * e), a = i * (1 - e);
                            break;
                        case 1:
                            s = i * (1 - h * e), o = i, a = i * (1 - e);
                            break;
                        case 2:
                            s = i * (1 - e), o = i, a = i * (1 - (1 - h) * e);
                            break;
                        case 3:
                            s = i * (1 - e), o = i * (1 - h * e), a = i;
                            break;
                        case 4:
                            s = i * (1 - (1 - h) * e), o = i * (1 - e), a = i;
                            break;
                        case 5:
                            s = i, o = i * (1 - e), a = i * (1 - h * e)
                    }
                    return n || (s = r(s, 0, 1), o = r(o, 0, 1), a = r(a, 0, 1)), new U(s, o, a, 1)
                }, U.rgbToHSV = (t, e, i, n) => { t.b > t.g && t.b > t.r ? U.rgbToHSVHelper(4, t.b, t.r, t.g, e, i, n) : t.g > t.r ? U.rgbToHSVHelper(2, t.g, t.b, t.r, e, i, n) : U.rgbToHSVHelper(0, t.r, t.g, t.b, e, i, n) }, U.rgbToHSVHelper = (t, e, i, n, s, r, o) => {
                    if (o.v = e, 0 !== o.v) {
                        const e = i <= n ? i : n,
                            a = o.v - e;
                        if (0 !== a ? (r.v = a / o.v, s.v = t + (i - n) / a) : (r.v = 0, s.v = t + (i - n)), s.v /= 6, s.v >= 0) return;
                        ++s.v
                    } else r.v = 0, s.v = 0
                }, U.lerp = (t, e, i) => U.lerpUnclamped(t, e, r(i, 0, 1)), U.lerpUnclamped = (t, e, i) => new U(UnityEngine.Mathf.LerpUnclamped(t.r, e.r, i), UnityEngine.Mathf.LerpUnclamped(t.g, e.g, i), UnityEngine.Mathf.LerpUnclamped(t.b, e.b, i), UnityEngine.Mathf.LerpUnclamped(t.a, e.a, i)), U.equals = (t, e) => null === t && null === e || null !== t && null !== e && t.equals(e), U.getDefaultValue = () => new U;
                var N = i(0);
                const k = 3,
                    z = 1e-5,
                    V = { x: 0, y: 1, z: 2, w: 3 },
                    j = { r: 0, g: 1, b: 2, a: 3 };
                class G { constructor(t, e, i, n, s = 0, r = 0, o = 0) { this.time = t, this.value = e, this.inTangent = i, this.outTangent = n, this.leftConstant = r === k || 7 === s || 71 === s || 103 === s, this.rightConstant = o === k || 97 === s || 101 === s || 103 === s } }
                class H {
                    constructor(t) {
                        this.id = (0, N.b)(), this.path = t.path, this.componentType = t.componentType, this.property = t.property, this.targetsLocalEulerAnglesRaw = !1, this.targetObject = null, this.targetProperty = null, this.isVectorProperty = !1, this.vectorPropertyIndex = -1, this.isMaterialPropertyCurve = !1, this.objectCurve = !1, this.keys = [], this.componentType && 0 !== this.componentType.indexOf("UnityEngine.") && (this.property = this.property.substring(0, 1).toLowerCase() + this.property.substring(1));
                        const e = this.property ? this.property.split(".") : [];
                        if (this.property && e.length > 1 ? (this.targetObject = e[0], this.targetProperty = e[1], "localEulerAnglesRaw" === this.targetObject ? this.targetsLocalEulerAnglesRaw = !0 : "blendShape" === this.targetObject && (this.targetProperty = this.property.substring(11, this.property.length))) : (this.targetProperty = this.property, this.targetObject = null), this.keyId = this.path + ":" + this.componentType + "." + this.property, this.componentType) {
                            this.isMaterialPropertyCurve = this.componentType.indexOf("Renderer") >= 0 && "material" === this.targetObject;
                            const t = this.property.split(".");
                            if (this.isVectorProperty = t.length > 2, this.isVectorProperty) {
                                const e = t[t.length - 1],
                                    i = j.hasOwnProperty(e) ? j : V;
                                this.vectorPropertyIndex = i[e]
                            } else this.vectorPropertyIndex = -1
                        }
                        if (t.keyframes) this.keys = t.keyframes;
                        else if (t.keys_flow) {
                            const e = t.keys_flow;
                            this.keys = [];
                            for (let t = 0; t < e.length; t += 7) this.keys.push(new G(e[t], e[t + 1], e[t + 2], e[t + 3], e[t + 4], e[t + 5], e[t + 6]))
                        } else {
                            if (this.keys = [], t.keys)
                                for (let e = 0; e < t.keys.length; e++) {
                                    const i = t.keys[e];
                                    this.keys.push(new G(i[0], i[1], i[2], i[3], i[4], i[5], i[6]))
                                }
                            if (t.objectReferenceKeys)
                                for (let e = 0; e < t.objectReferenceKeys.length; e++) {
                                    const i = t.objectReferenceKeys[e];
                                    this.keys.push(new G(i[0], i[1], i[2], i[3], i[4], i[5], i[6]))
                                }
                            this.objectCurve = !!t.objectReferenceKeys
                        }
                    }
                    setValue(t, e) { 0 !== this.keys.length && (t >= this.keys.length ? this.keys[this.keys.length - 1].value = e : this.keys[t].value = e) }
                    getValue(t) { return 0 === this.keys.length ? -1 : t >= this.keys.length ? this.keys[this.keys.length - 1].value : this.keys[t].value }
                    findKeyIndexAt(t) {
                        if (t <= this.keys[0].time) return 0;
                        if (t >= this.keys[this.keys.length - 1].time) return this.keys.length - 2;
                        for (let e = 0; e < this.keys.length - 1; e++)
                            if (this.keys[e + 1].time - t > z) return e;
                        return -1
                    }
                    sample(t, e) {
                        const i = t.getOrCreateKey(this, this.keyId);
                        i.set(this.value(e, i))
                    }
                    value(t, e) {
                        if (0 === this.keys.length) return 0;
                        if (1 === this.keys.length) return this.keys[0].value;
                        if (this.keys[this.keys.length - 1].time - t <= z) return e && (e.idx = 0), this.keys[this.keys.length - 1].value;
                        let i = null,
                            n = null;
                        if (2 === this.keys.length) i = this.keys[0], n = this.keys[1];
                        else {
                            e && null != e.idx && (i = this.keys[e.idx], n = this.keys[e.idx + 1], (i.time > t || n.time < t) && (e.idx = null));
                            let s = null;
                            e ? (null == e.idx && (e.idx = this.findKeyIndexAt(t)), s = e.idx) : s = this.findKeyIndexAt(t), i = this.keys[s], n = this.keys[s + 1]
                        }
                        if (n.time - t <= z) return e && this.keys.length > e.idx && e.idx++, n.value;
                        if (null == i.outTangent || null == n.inTangent || t < i.time) return i.value;
                        if (t >= n.time) return n.value;
                        if (i.rightConstant || n.leftConstant || i.outTangent === 1 / 0 || n.inTangent === 1 / 0) return i.value;
                        const s = n.time - i.time,
                            r = (t - i.time) / s;
                        if (this.objectCurve) return r < n.value ? i.value : n.value;
                        const o = i.outTangent * s,
                            a = n.inTangent * s,
                            c = r * r,
                            h = c * r,
                            l = h - 2 * c + r,
                            u = h - c,
                            d = -2 * h + 3 * c;
                        return (2 * h - 3 * c + 1) * i.value + l * o + u * a + d * n.value
                    }
                    clone() { return new H({ keyframes: [...this.keys], path: this.path, componentType: this.componentType, property: this.property }) }
                    _keysAt(t) {
                        if (1 === this.keys.length) return this.keys;
                        if (t >= this.keys[this.keys.length - 1].time) return [this.keys[this.keys.length - 1]];
                        if (t <= this.keys[0].time) return [this.keys[0]];
                        for (let e = 0; e < this.keys.length; e++)
                            if (this.keys[e].time > t) return [this.keys[e - 1], this.keys[e]];
                        return null
                    }
                }
                H.createLinear = function(t, e, i, n) {
                    return new H({
                        keys: [
                            [t, e, 0, 0],
                            [i, n, 0, 0]
                        ]
                    })
                }, H.createEaseInOut = function(t, e, i, n) {
                    return new H(t === i ? {
                        keys: [
                            [t, e, 0, 0]
                        ]
                    } : {
                        keys: [
                            [t, e, 0, 0],
                            [i, n, 0, 0]
                        ]
                    })
                };
                class X {
                    constructor(t, e, i) { this.x = t, this.y = e, this.z = i }
                    dot2(t, e) { return this.x * t + this.y * e }
                }
                const Q = [new X(1, 1, 0), new X(-1, 1, 0), new X(1, -1, 0), new X(-1, -1, 0), new X(1, 0, 1), new X(-1, 0, 1), new X(1, 0, -1), new X(-1, 0, -1), new X(0, 1, 1), new X(0, -1, 1), new X(0, 1, -1), new X(0, -1, -1)],
                    Y = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180],
                    K = new Array(512),
                    W = new Array(512);

                function q(t) { return t * t * t * (t * (6 * t - 15) + 10) }

                function J(t, e, i) { return (1 - i) * t + i * e }! function(t) {
                    t > 0 && t < 1 && (t *= 65536), (t = Math.floor(t)) < 256 && (t |= t << 8);
                    for (let e = 0; e < 256; e++) {
                        let i;
                        i = 1 & e ? Y[e] ^ 255 & t : Y[e] ^ t >> 8 & 255, K[e] = K[e + 256] = i, W[e] = W[e + 256] = Q[i % 12]
                    }
                }(0), pc.Vec3 = P, pc.Quat = S, pc.Mat4 = C, pc.Vec4 = y, pc.Mat3 = A, pc.Vec2 = u, pc.math = { RAD_TO_DEG: s, DEG_TO_RAD: n, clamp: r, intToBytes24: o, intToBytes32: a, lerp: c, powerOfTwo: function(t) { return 0 !== t && !(t & t - 1) }, random: function(t, e) { const i = e - t; return Math.random() * i + t }, smoothstep: function(t, e, i) { return i <= t ? 0 : i >= e ? 1 : (i = (i - t) / (e - t)) * i * (3 - 2 * i) }, smootherstep: function(t, e, i) { return i <= t ? 0 : i >= e ? 1 : (i = (i - t) / (e - t)) * i * i * (i * (6 * i - 15) + 10) }, sign: h }, pc.Color = U, pc.AnimationCurve = H, pc.Keyframe = G, pc.noise = {
                    perlin2: function(t, e) {
                        let i = Math.floor(t),
                            n = Math.floor(e);
                        t -= i, e -= n, i &= 255, n &= 255;
                        const s = W[i + K[n]].dot2(t, e),
                            r = W[i + K[n + 1]].dot2(t, e - 1),
                            o = W[i + 1 + K[n]].dot2(t - 1, e),
                            a = W[i + 1 + K[n + 1]].dot2(t - 1, e - 1),
                            c = q(t);
                        return J(J(s, o, c), J(r, a, c), q(e))
                    }
                }
            }
        },
        0, [
            [0, 5]
        ]
    ]), (self.webpackChunk = self.webpackChunk || []).push([
        [3], {},
        0, [
            [6, 5, 4]
        ]
    ]), (self.webpackChunk = self.webpackChunk || []).push([
        [2], {},
        0, [
            [12, 0, 5, 4]
        ]
    ]), (self.webpackChunk = self.webpackChunk || []).push([
        [1],
        [, (t, e, i) => {
            "use strict";
            i.d(e, { a: () => h });
            var n = i(0),
                s = i(8),
                r = i(3),
                o = i(5),
                a = (i(7), i(4));
            let c = !1;
            class h extends s.a {
                constructor(t, e, i = !1) {
                    if (t instanceof r.a && (e = t, t = "Untitled"), super(t), this._app = e, !e && (this._app = r.a.getApplication(), !this._app)) throw new Error("Couldn't find current application");
                    this.$id = null, this.objectJson = null, this.isPrefab = !0 === i, this.getGuid(), this["__UnityEngine.Transform"] = null, this["__UnityEngine.RectTransform"] = null, this["__UnityEngine.GameObject"] = null, this._destroying = !1, this._cullingLayer = 0, this._beingDestroyed = !1, this._destroyed = !1, this._magicMethods = null, this._eventHanders = null
                }
                sendMessageToScripts(t, e, i) {
                    const n = this._unityComponents.monoBehaviour;
                    if (0 !== n.length && t)
                        for (let s = 0; s < n.length; s++) {
                            const r = n[s].code;
                            if (r !== i) try {
                                if (r && r[t]) {
                                    const i = r[t].apply(r, e);
                                    i && "Bridge.GeneratorEnumerator" === i.$$fullname && new UnityEngine.Coroutine(i, r.handle)
                                }
                            } catch (t) { console.error(t) }
                        }
                }
                _elementDimesionsChange() { for (let t = 0; t < this._dimensionListeners.length; t++) { this._dimensionListeners[t].OnRectTransformDimensionsChange() } }
                sendPhysicsEvent(t, e) {
                    if (!this._magicMethods) return !1;
                    const i = this._magicMethods[t];
                    if (!i) return !1;
                    for (let n = 0; n < i.length; n++) {
                        const s = i[n];
                        try {
                            const i = s.code[t].call(s.code, e);
                            i && "Bridge.GeneratorEnumerator" === i.$$fullname && new UnityEngine.Coroutine(i, s.code.handle)
                        } catch (t) { console.error(t) }
                    }
                    return !0
                }
                removeOrReparent(t, e = !1) {
                    if (null === t)
                        if (e) {
                            const t = this.getWorldTransform().clone();
                            let e = this.getScene();
                            e || (e = $scene), this.reparent(e.root, -1), this.setLocalTransform(t)
                        } else this.parent.removeChild(this);
                    else this.reparent(t, -1)
                }
                getComponents(t) {
                    const e = [];
                    if (!t)
                        for (const t in this.c) this.c.hasOwnProperty(t) && e.push(this.c[t]);
                    for (const t in this._unityComponents) { if (!this._unityComponents.hasOwnProperty(t)) continue; const i = this._unityComponents[t]; for (const t in i) i.hasOwnProperty(t) && e.push(i[t]) }
                    return e
                }
                getUnityComponents(t) {
                    const e = [],
                        i = this._unityComponents;
                    if (!i) return e;
                    for (let n = 0, s = t.length; n < s; ++n) { const s = t[n]; if (!i.hasOwnProperty(s)) continue; const r = i[s]; for (const t in r) r.hasOwnProperty(t) && e.push(r[t]) }
                    return e
                }
                getUnityComponent(t) { return this._unityComponents && this._unityComponents[t][0] || null }
                collectAllUnityComponents() { let t = this.getUnityComponents(a.a); const e = this.allChildren(); for (let i = 0; i < e.length; i++) { t = e[i].getUnityComponents(a.a).concat(t) } return t }
                addComponent(t, e) { const i = this._app.systems[t]; if (!i) throw new Error("addComponent: System " + t + " doesn't exist"); return this.c[t] ? (DEBUG && console.warn("addComponent: Entity already has " + t + " component. (Check for components duplicates, e.g. SkinnedMesh & MeshFilter are both 'Models')"), null) : i.addComponent(this, e) }
                addUnityComponentFromDeserialization(t, e) { this._app.systems[t].addComponent(this, e) }
                addUnityComponent(t, e) {
                    const i = [];
                    if (LunaUnity.Application.Instance.app.systems.unitymanager.disableCallbacks(), this._app.systems[t].addComponent(this, e), i.push(e), !c) {
                        c = !0, o.a.addRequiredComponents(this, e.code, i), LunaUnity.Application.Instance.app.systems.unitymanager.enableCallbacks();
                        for (let t = i.length - 1; t >= 0; t--) {
                            const e = i[t];
                            e instanceof o.a && (e.configureForEntity(this), e.onAttached(), e.onInit(), this.enabled && e.enabled && e._onEntityStateChanged(!0))
                        }
                        c = !1
                    }
                }
                removeComponent(t) {
                    const e = this._app.systems[t];
                    if (!e) throw new Error("removeComponent: System " + t + " doesn't exist");
                    this.c[t] ? e.removeComponent(this) : DEBUG && console.warn("removeComponent: Entity doesn't have " + t + " component")
                }
                getGuid() { return this._guid || this.setGuid((0, n.b)()), this._guid }
                setGuid(t) {
                    const e = this._app._entityIndex;
                    this._guid && delete e[this._guid], this._guid = t, e[this._guid] = this
                }
                _onHierarchyStateChanged(t) {
                    if (super._onHierarchyStateChanged.call(this, t), this._unityComponents)
                        for (let e = 0; e < a.a.length; e++) { const i = this._unityComponents[a.a[e]]; for (let e = 0; e < i.length; e++) i[e]._onEntityStateChanged(t) }
                    let e;
                    const i = this.c;
                    for (const n in i) i.hasOwnProperty(n) && (e = i[n], e.enabled && (t ? e.onEnable() : e.onDisable()))
                }
                findByGuid(t) { if (this._guid === t) return this; const e = this._app._entityIndex[t]; return e && (e === this || e.isDescendantOf(this)) ? e : null }
                destroy() {
                    let t;
                    for (t in this._destroying = !0, this.c) this.c.hasOwnProperty(t) && (this.c[t].enabled = !1);
                    for (t in this.c) this.c.hasOwnProperty(t) && this.c[t].system.removeComponent(this);
                    for (let t = 0; t < a.a.length; t++) { const e = this._unityComponents[a.a[t]]; for (let t = 0; t < e.length; t++) e[t].destroy() }
                    this._parent && this._parent.removeChild(this);
                    const e = this._children;
                    let i = e.shift();
                    for (; i;) i instanceof h && i.destroy(), i._parent = null, i = e.shift();
                    this.events.off(), this._destroying = !1, this._destroyed = !0, this._layoutElements.length = 0, this._layoutControllers.length = 0, this._layoutSelfControllers.length = 0, this._dimensionListeners.length = 0, this._canvasElements.length = 0, this._canvasGroups.length = 0, this._meshModifiers.length = 0
                }
            }
        }, (t, e, i) => {
            "use strict";
            i.d(e, { a: () => s });
            var n = i(0);
            i(3), i(1), i(7);
            class s {
                constructor(t) { this.app = t, this.store = {}, this.ComponentType = null, this.id = "", this.events = new n.a(this) }
                addComponent(t, e) { const i = new this.ComponentType(this, t); return e = e || {}, this.store[t.getGuid()] = { entity: t, data: i.data }, t.c[this.id] = i, this.initializeComponentData(i, e, []), i }
                removeComponent(t, e = null) {
                    const i = this.store[t.getGuid()],
                        n = t.c[this.id];
                    this.events.fire("beforeremove", t, n), delete this.store[t.getGuid()], delete t.c[this.id], this.events.fire("remove", t, i.data)
                }
                initializeComponentData(t, e, i) {
                    e = e || {};
                    for (let n = 0, s = i.length; n < s; n++) {
                        const s = i[n],
                            r = e[s];
                        void 0 !== r && (t[s] = r)
                    }
                    t.enabled && t.entity.enabled && t.onEnable()
                }
                destroy() { this.events.off() }
            }
            s.events = new n.a(null), s.update = t => { s.events.fire("update", t) }, s.destroy = () => { s.events.off("update") }
        }, (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            "use strict";
            __webpack_require__.d(__webpack_exports__, { d: () => FILLMODE_NONE, b: () => FILLMODE_FILL_WINDOW, c: () => FILLMODE_KEEP_ASPECT, e: () => RESOLUTION_AUTO, f: () => RESOLUTION_FIXED, a: () => Application });
            var _math_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6),
                _input_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(12),
                _core_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(0),
                _entity_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(1),
                _system_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(2),
                _registry_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(13),
                _counters_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(10);
            const FILLMODE_NONE = "NONE",
                FILLMODE_FILL_WINDOW = "FILL_WINDOW",
                FILLMODE_KEEP_ASPECT = "KEEP_ASPECT",
                RESOLUTION_AUTO = "AUTO",
                RESOLUTION_FIXED = "FIXED",
                unityAttenuationTextureBase64 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABAAAAAABCAYAAABADtw1AAAA+ElEQVRYCc1RSRLDIAxr///jbqlVqhkNJW4IZtEh8oYsyHUz3L64GxCCgYeBjJh4GhArIyZehjxGDUA9Rb9feNGq5ozBAOaUP0WpM1fmGa1dDJqX4nzGy7VXir0aey3sndWexrgzcqAl9s7X9PJZ5IB6O5KXZmpqEbN7GqgD+Z1SNX3P9v7pRvSPaKRb+HfkTI1e7eyI+TM7cIbw/jVn9rjlLDUjNKAVpRPti3o9PKr2CH3ui35r6no8Y6f6mb1fvTBe0RO9gWf6i9i9igbfNMIPtXr8n2h/9NpLt8cb0DO5p/eRO7gLPOJOM/etsps+Rr8395Y4yssbZyWMID2grNAAAAAASUVORK5CYII=",
                unitySpotTextureBase64 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACABAMAAAAxEHz4AAAAA3NCSVQICAjb4U/gAAAAMFBMVEX///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAv3aB7AAAAEHRSTlMAESIzRFVmd4iZqrvM3e7/dpUBFQAAAAlwSFlzAAALEgAACxIB0t1+/AAAABx0RVh0U29mdHdhcmUAQWRvYmUgRmlyZXdvcmtzIENTNui8sowAAAO9SURBVGiB3VnredpAEEQdGHdg0wGiA4tUgKggiFSASAMB3EAQFQTRgeUO7HRg3IHtDkxm9+70AFk6sfoSf9k/2D9mNDO7iHt0Op+6nC7XhQh9LkcBfgYFY67T4n+bPp6APRfVNxTWIhwFJ7DrefyhKCwZgL8k+MBL64YoriwZGN8juO/74yCY4IMo+pYMjIf0IYGDEBUQyQhWrBgUfuABPg3D+RK1CMMZKCDChkHhhz7gQEdcxDEL/JFisMKPA8CjaBNzbcGxCIOJBYOj8dMQ8DjeJVx3cQyKcKYZqkyg/z3C4/FxnCT3j1wPSQKK5YIY+tdVEmBA4VcR4ID+3qOe8AcoorViqDDBBjwf+E2MpzNa1RNUxFsw+F6VCTbgB8DvEoa/6mKK5A4MgV9hwlEGQuD58a+5YhFgCJWJcgkQ4Hrj6ZLwBv52OLwbCmJYziYwUS6BBSAA5Kfxh7Q0A5JEDB9JIAHD8Xxl8G+HXL0bhvViMiqXoAXAAPwXHp+KQA5k4gMJLCCYR7t7wr8d41nE/unhLloE5RJIwHi62sBAKV4xPCbb9WxCEk4dsAAY2D+f6jcuXvYwoSQce1AJrGI2UI4nBpiI1yqF0wjRAhLwMZ4ZSMJkdBIjHAyGLOC5PAATwwtLGN0ce+AI0YJqAVpCtDiJkSPEDNQI0BIwC8cxkgNEWCtAS6AYiwRw4CHCpE6AkpAgRq/ooXvpcoS1AlgCx+jmCXIOagSQhBIPqgccYR0eEijGoz7QFCkHtQJYAnsoElAEu0cbASSBPORDoAh0D+wIuA+5EJyuisDKgfLAIaQEKgKrHmgC9pCFoCOwdMAeiiGoCNBEKwGQoBt53S1kaBtBFoJJMcvQDg8PxRQdnaFtBOkk9K8u8k2wzjBN0bSBm4Axso2AQsAoZW1ommE+xVYIsi7a4tM2qD5yF783aYJqw0/TRxB4zZpg2uBpAtNF6wh4mLNBaI3Avgk8CBkBD+LtfVOCh19mFJlg05xgmxG4w2+N5khP0g89y0TQbBDNKB4T2OP1KKYEgy/nEXy9+X8IxCG20EbhIIlHWfhlEn+dP8EbSfxSlb/WhT8s//63sYWfd+kCQ7zEkS+ypMs88UKzhaWudLEtXu6LNxziLU8bmy7htk+88RRvfeWbb/H2X3wAIT4CkR/CiI+BxAdR8qMw8WGc/DhQfCApPhKVH8qKj4XlB9Pio3H54bz4ekB+QSG/IhFf0sivieQXVeKrMvllnfy6UH5hKb8y7YgvbY2IFm+eZZffZ6L/Vv0BqFspPs/Tph4AAAAASUVORK5CYII=",
                unityNHxRoughnessBase64 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAABACAMAAADCg1mMAAAAA3NCSVQICAjb4U/gAAABEVBMVEX+/v7v7+/S0tKysrKfn5+ampqHh4d5eXltbW1mZmZkZGRjY2NiYmJeXl5bW1taWlpZWVlTU1NPT09OTk5MTExJSUlISEhHR0dGRkZFRUVERERCQkJBQUE+Pj49PT07Ozs6Ojo5OTk4ODg3Nzc2NjY1NTU0NDQzMzMyMjIxMTEwMDAvLy8uLi4tLS0sLCwrKysqKiopKSkoKCgnJycmJiYlJSUkJCQjIyMiIiIhISEgICAfHx8eHh4dHR0cHBwbGxsaGhoZGRkYGBgXFxcWFhYVFRUUFBQTExMSEhIREREQEBAPDw8ODg4NDQ0MDAwLCwsKCgoJCQkICAgHBwcGBgYFBQUEBAQDAwMCAgIBAQEAAAAUqg0sAAAACXBIWXMAAAsSAAALEgHS3X78AAAAHHRFWHRTb2Z0d2FyZQBBZG9iZSBGaXJld29ya3MgQ1M26LyyjAAABDdJREFUeJzl1wlf2jAcxnF334fbnHNz3hvoB9SqxYJSDkUF5RKGW9//C1n+SZsmpWlTWq72eQe/L2laFgzD+Cfe3/HuYfpbMAxvgsgZpl3sGAHwN4hCYYJZA+lRABmDUApTzZQDGCfC7BT7AEgiBFaYcvUf4dwAxoIwyXJxrjyALIK8wnjbgzST9cm8AKI+CtHXB+8dmi9ApAiR5YdqDg4QoUL4/rDZPX7yALIKIQlGjg8QHQIgGoTRAIK3C5rv2Y0AIKkwIkHAfPnye5d1u91RAcIrBBOQrZcJ77ILBSDHENRAEsA/3jO82yGLAEBGIZiBDIB3vEd5h19UACEUpAgC5Iva2ew2XaQAEgqyBkEABPWu7XZ5u4UXPYA/w0gGYgDXfK/2lrUm2rgARlKQJ3DtF9cPtTfpxgrgp+BvIBLw6hfUO9rvzI0fwIfBz8BPwNnvyOfq+fZbvEkBBFQQGYgF+H5hPdvegE0UwFNB0mBIwA2A6WfqmXjc3qijTR7Ai8EDYZiAFxjqd82n9dBev0GbFoC0gpuBg4ARcOvn6ukvD/HXaFMFEDOIENwJHAIUgPv12d/erL9CmwEAPD8EkQEjwAGw/Uy+WX9N6mtoswKA56PgNHASsAIMgNnP5ZP6S7SZAsDzRHAYMAT0ENhHwD4AtB/O/o1dP5MAZBIIjAF3COgRoAfAuvys/Ksr3F6FzSoAnhCBM+AIOIF223oBkPd+45rM/PErsJkGwBMpOI8Bcwjwy9D+/Cfffbfk7qP9OF/XZx8Azx3BxYC8ES0BmPnlj7986vj8X+CVYcXinADgiREcBOZnMSfg6Cf1xfkCwHNB4AysU2D+K7KfAXwDwpu/BndfCe0cLT93AHhDCNSAvBjNP0j4kxB/CtIr0Hr6dV0/Q9O0+QSAuSLYxwBGzwA9AvbvD79+Pp/LzS8AnsBgMHARsAGs/lwudzznADAewTQw/yxZd6F5DZIrEF9/hcLp6cnJyWEMAPCcCObfBesmINcAuQPgAkCPP/Qryn5cAGDOg4BmPQjkKUDPAAXQNOjPZuMEAGMQGANMgAXgDoAbQNNUVVEymXTcAGD8l5J5FeCLAG4BuAMAAH7/vVQqjgAwDsEiIALVqq4XCqp6iPp3NuMKAGMMCAE8BugerFTQO0A9Osikf22uxRkAZr0dyBsBDgG6BsrlM01V9vd+b639iDuAQQ0wQacDAtXSeV5Vsrs766vLCQAwGANE0GwiAb2QO8qmt36ufEkGgDX0Vuz1Wq2bWqWoHWdTG6tLi8kCIASdZr1WPlMPUuvfP39IGgAQ9PutRq2UV3bXvy2+TR4A2qDXua3pambj68eXiQRAp+D+rnaubC+9e5FMAETQb15q6eU3z5MKgJ6D9sXR6qtnyQUwHjql7ddPEgxgGJ3c+8eJBjBaKwvJBjD0RwkHMJ4mHeBT0gGM/4ecz/SdIIT+AAAAAElFTkSuQmCC",
                _mouseMovementDelta = new _math_index_js__WEBPACK_IMPORTED_MODULE_0__.c;
            class Application {
                constructor(t, e) { this.events = new _core_index_js__WEBPACK_IMPORTED_MODULE_2__.a(this), Application._currentApplication = this, this._time = 0, this.timeScale = 1, this.maxDeltaTime = .1, this.frame = 0, this.autoRender = !0, this.renderNextFrame = !1, this._fillMode = FILLMODE_KEEP_ASPECT, this._resolutionMode = RESOLUTION_FIXED, this.minimumResolution = null, this.paused = !1, this.graphicsDevice = e.graphicsDevice, this.counters = new _counters_js__WEBPACK_IMPORTED_MODULE_6__.a(this.graphicsDevice), this._audioManager = e.audioManager, this._entityIndex = {}, this.scene = new pc.Scene, this.root = new _entity_js__WEBPACK_IMPORTED_MODULE_3__.a(this), this.root._enabledInHierarchy = !0, this.renderer = e.renderer, this.renderer.scene = this.scene, this.keyboard = e.keyboard, this.mouse = new _input_index_js__WEBPACK_IMPORTED_MODULE_1__.a(t), this.touch = "ontouchstart" in window ? new _input_index_js__WEBPACK_IMPORTED_MODULE_1__.b(t) : null, this._targetAspect = null, this.systems = new _registry_js__WEBPACK_IMPORTED_MODULE_5__.a, this._visibilityChangeHandler = this.onVisibilityChange.bind(this), document.addEventListener("visibilitychange", this._visibilityChangeHandler, !1), this.tick = this._tick.bind(this) }
                get audioManager() { return this._audioManager }
                get targetAspect() { return this._targetAspect }
                set targetAspect(t) { this._targetAspect = t, this.setCanvasFillMode(this._fillMode, window.innerWidth, window.innerHeight) }
                start() { this.frame = 0, this.tick(0) }
                _tick(t) {
                    if (!this.graphicsDevice) return;
                    const e = _core_index_js__WEBPACK_IMPORTED_MODULE_2__.c.now();
                    let i = (e - (this._time || e)) / 1e3;
                    i = (0, _math_index_js__WEBPACK_IMPORTED_MODULE_0__.e)(i, 0, this.maxDeltaTime), i *= this.timeScale, this._time = e, UnityEngine.Time.Update(i), window.requestAnimationFrame(this.tick), this.graphicsDevice.contextLost || this.paused || (this.counters.startSection(_counters_js__WEBPACK_IMPORTED_MODULE_6__.a.FRAME), this.update(i), this.counters.startSection(_counters_js__WEBPACK_IMPORTED_MODULE_6__.a.RENDER), (this.autoRender || this.renderNextFrame) && (this.render(), this.renderNextFrame = !1), this.counters.endSection(_counters_js__WEBPACK_IMPORTED_MODULE_6__.a.RENDER), this.events.fire("frameend"), this.counters.endSection(_counters_js__WEBPACK_IMPORTED_MODULE_6__.a.FRAME), this.counters.tick())
                }
                update(t) { this.frame++, this.graphicsDevice.updateClientRect(), _system_js__WEBPACK_IMPORTED_MODULE_4__.a.update(t), this.events.fire("update", t), this.mouse && this.mouse.update(), this.keyboard && this.keyboard.update(), UnityEngine.Input.Update(), UnityEngine.SceneManagement.SceneManager.ProcessAsync() }
                render() { this.graphicsDevice._drawCallsPerFrame = 0, this.events.fire("prerender"), this.scene.syncHierarchy(this.root), this.renderer.renderComposition(), this.events.fire("postrender") }
                syncHierarchy() { this.scene.syncHierarchy(this.root) }
                setCanvasFillMode(t, e, i) {
                    this._fillMode = t;
                    const n = this.resizeCanvas(e, i);
                    this.graphicsDevice.resizeCanvas(n.width, n.height)
                }
                setCanvasResolution(t, e, i) { this._resolutionMode = t, t === RESOLUTION_AUTO && void 0 === e && (e = this.graphicsDevice.canvas.clientWidth, i = this.graphicsDevice.canvas.clientHeight), this.graphicsDevice.resizeCanvas(e, i) }
                onVisibilityChange() { document.hidden ? this._audioManager.suspend() : this._audioManager.resume() }
                resizeCanvas(t, e) {
                    const i = window.innerWidth,
                        n = window.innerHeight;
                    if (this._fillMode === FILLMODE_KEEP_ASPECT) {
                        const s = this._targetAspect || this.graphicsDevice.canvas.width / this.graphicsDevice.canvas.height;
                        s > i / n ? e = (t = i) / s : t = (e = n) * s, this.minimumResolution && (t < this.minimumResolution.x || e < this.minimumResolution.y) && (t = this.minimumResolution.x, e = this.minimumResolution.y)
                    } else this._fillMode === FILLMODE_FILL_WINDOW && (t = i, e = n);
                    return this.graphicsDevice.canvas.style.width = t + "px", this.graphicsDevice.canvas.style.height = e + "px", this._resolutionMode === RESOLUTION_AUTO && this.setCanvasResolution(RESOLUTION_AUTO), { width: t, height: e }
                }
                mimicUnityMouse() { window.UnityEngine.Input.mousePosition = new _math_index_js__WEBPACK_IMPORTED_MODULE_0__.c(0, 0), this.touch ? (this.touch.events.on(_input_index_js__WEBPACK_IMPORTED_MODULE_1__.c.EVENT_TOUCHSTART, this._onTouchStart, this), this.touch.events.on(_input_index_js__WEBPACK_IMPORTED_MODULE_1__.c.EVENT_TOUCHEND, this._onTouchEnd, this), this.touch.events.on(_input_index_js__WEBPACK_IMPORTED_MODULE_1__.c.EVENT_TOUCHMOVE, this._onTouchMove, this), this.touch.events.on(_input_index_js__WEBPACK_IMPORTED_MODULE_1__.c.EVENT_TOUCHCANCEL, this._onTouchEnd, this), UnityEngine.Input.mousePresent = !1, UnityEngine.Input.touchSupported = !0) : (this.mouse.events.on(_input_index_js__WEBPACK_IMPORTED_MODULE_1__.c.EVENT_MOUSEUP, this._onMouseUp, this), this.mouse.events.on(_input_index_js__WEBPACK_IMPORTED_MODULE_1__.c.EVENT_MOUSEDOWN, this._onMouseDown, this), this.mouse.events.on(_input_index_js__WEBPACK_IMPORTED_MODULE_1__.c.EVENT_MOUSEMOVE, this._onMouseMove, this), this.mouse.events.on(_input_index_js__WEBPACK_IMPORTED_MODULE_1__.c.EVENT_MOUSEWHEEL, this._onMouseScroll, this)), this.events.on("prerender", this._updateInputFlags, this), this.events.on("prerender", this._updateScreenCache, this), this.events.on("frameend", this._resetScroll, this) }
                _updateInputFlags() { window.UnityEngine.Input.mouseButtonsUp[0] = !1, window.UnityEngine.Input.mouseButtonsUp[1] = !1, window.UnityEngine.Input.mouseButtonsUp[2] = !1, window.UnityEngine.Input.mouseButtonsDown[0] = !1, window.UnityEngine.Input.mouseButtonsDown[1] = !1, window.UnityEngine.Input.mouseButtonsDown[2] = !1, window.UnityEngine.Input.axes.Insert("Mouse ScrollWheel", 0) }
                _updateScreenCache() { this.renderer._screensRendered = {} }
                _resetScroll() { window.UnityEngine.Input.axes.Insert("Mouse ScrollWheel", 0), window.UnityEngine.Input.mouseScrollDelta = new _math_index_js__WEBPACK_IMPORTED_MODULE_0__.c(0, 0) }
                _onMouseUp(t) {
                    const e = { x: t.x, y: this.graphicsDevice._height - t.y };
                    window.UnityEngine.Input.mouseButtonsUp[t.button] = !0, window.UnityEngine.Input.mouseButtons[t.button] = !1, window.UnityEngine.Input.mouseButtonsDown[t.button] = !1, window.UnityEngine.Input.mousePosition = new _math_index_js__WEBPACK_IMPORTED_MODULE_0__.c(e.x, e.y)
                }
                _onMouseMove(t) {
                    const e = { x: t.x, y: this.graphicsDevice._height - t.y };
                    _mouseMovementDelta.set(e.x - window.UnityEngine.Input.mousePosition.x, -e.y + window.UnityEngine.Input.mousePosition.y), window.UnityEngine.Input.axes.Insert("Mouse X", .1 * _mouseMovementDelta.x), window.UnityEngine.Input.axes.Insert("Mouse Y", .1 * _mouseMovementDelta.y), window.UnityEngine.Input.mousePosition = new _math_index_js__WEBPACK_IMPORTED_MODULE_0__.c(e.x, e.y)
                }
                _onMouseScroll(t) { window.UnityEngine.Input.axes.Insert("Mouse ScrollWheel", .1 * t.wheel), window.UnityEngine.Input.mouseScrollDelta = new _math_index_js__WEBPACK_IMPORTED_MODULE_0__.c(0, t.wheel) }
                _onMouseDown(t) {
                    window.UnityEngine.Input.mouseButtonsDown[t.button] = !0, window.UnityEngine.Input.mouseButtons[t.button] = !0, window.UnityEngine.Input.mouseButtonsUp[t.button] = !1;
                    const e = { x: t.x, y: this.graphicsDevice._height - t.y };
                    window.UnityEngine.Input.mousePosition = new _math_index_js__WEBPACK_IMPORTED_MODULE_0__.c(e.x, e.y)
                }
                _onTouchStart(t) {
                    const e = { x: t.changedTouches[0].x, y: t.changedTouches[0].y, button: 0 };
                    for (let e = 0; e < t.changedTouches.length; e++) {
                        const i = t.changedTouches[e];
                        UnityEngine.Input.OnTouchStart(i.id, i.x, this.graphicsDevice._height - i.y)
                    }
                    return this._onMouseDown(e), !0
                }
                _onTouchEnd(t) {
                    const e = { x: t.changedTouches[0].x, y: t.changedTouches[0].y, button: 0 };
                    for (let e = 0; e < t.changedTouches.length; e++) {
                        const i = t.changedTouches[e];
                        UnityEngine.Input.OnTouchEnd(i.id, i.x, this.graphicsDevice._height - i.y)
                    }
                    return this._onMouseUp(e), !0
                }
                _onTouchMove(t) {
                    const e = { x: t.changedTouches[0].x, y: t.changedTouches[0].y, button: 0 };
                    for (let e = 0; e < t.changedTouches.length; e++) {
                        const i = t.changedTouches[e];
                        UnityEngine.Input.OnTouchMoved(i.id, i.x, this.graphicsDevice._height - i.y)
                    }
                    return this._onMouseMove(e), !0
                }
                getRootObjects() { return this.root.children }
                getMainCamera() {
                    let t = null;
                    for (let e = 0; e < this.systems.camera.cameras.length; e++) {
                        const i = this.systems.camera.cameras[e];
                        if ("MainCamera" === i.entity.tag) return i;
                        null != i.renderTarget || t || (t = i)
                    }
                    return t
                }
                initializeBuiltInTextures() {
                    const t = [
                        ["white", [255, 255, 255, 255]],
                        ["red", [255, 0, 0, 0]],
                        ["gray", [127, 127, 127, 127]],
                        ["bump", [127, 127, 255, 127]],
                        ["black", [0, 0, 0, 0]]
                    ];
                    let e = null;
                    for (let i = 0; i < t.length; i++) {
                        const n = t[i][1],
                            s = new pc.Texture(this.graphicsDevice, { width: 4, height: 4, format: pc.PIXELFORMAT_R8_G8_B8_A8, premultiplyAlpha: !1 }),
                            r = s.lock();
                        for (let t = 0; t < 16; t++) r[4 * t + 0] = n[0], r[4 * t + 1] = n[1], r[4 * t + 2] = n[2], r[4 * t + 3] = n[3];
                        s.unlock(), UnityEngine.Texture2D[t[i][0] + "Texture"] = UnityEngine.Object.FromHandle(UnityEngine.Texture2D, s), e = r
                    }
                    UnityEngine.Texture2D.greyTexture = UnityEngine.Texture2D.grayTexture;
                    const i = new pc.Texture(this.graphicsDevice, { width: 4, height: 4, format: pc.PIXELFORMAT_R8_G8_B8_A8, cubemap: !0, premultiplyAlpha: !1 });
                    i._levels = [
                        [e, e, e, e, e]
                    ], i.upload(), UnityEngine.Cubemap.blackCube = UnityEngine.Object.FromHandle(UnityEngine.Cubemap, i);
                    const n = new pc.Texture(this.graphicsDevice, { width: 1024, height: 1, addressU: pc.ADDRESS_CLAMP_TO_EDGE, addressV: pc.ADDRESS_CLAMP_TO_EDGE, format: pc.PIXELFORMAT_R8_G8_B8_A8, premultiplyAlpha: !1 });
                    let s = document.createElement("IMG");
                    s.src = unityAttenuationTextureBase64, n.setSource(s), UnityEngine.Texture2D.attenuationTexture = UnityEngine.Object.FromHandle(UnityEngine.Texture2D, n);
                    const r = new pc.Texture(this.graphicsDevice, { width: 128, height: 128, addressU: pc.ADDRESS_CLAMP_TO_EDGE, addressV: pc.ADDRESS_CLAMP_TO_EDGE, format: pc.PIXELFORMAT_R8_G8_B8_A8, premultiplyAlpha: !1 });
                    s = document.createElement("IMG"), s.src = unitySpotTextureBase64, r.setSource(s), UnityEngine.Texture2D.spotTexture = UnityEngine.Object.FromHandle(UnityEngine.Texture2D, r);
                    const o = new pc.Texture(this.graphicsDevice, { width: 256, height: 64, addressU: pc.ADDRESS_CLAMP_TO_EDGE, addressV: pc.ADDRESS_CLAMP_TO_EDGE, format: pc.PIXELFORMAT_R8_G8_B8_A8, premultiplyAlpha: !1 });
                    s = document.createElement("IMG"), s.src = unityNHxRoughnessBase64, o.setSource(s), UnityEngine.Texture2D.nhxRoughnessTexture = UnityEngine.Object.FromHandle(UnityEngine.Texture2D, o), pc.UniformDefaultValues[pc.UNIFORMTYPE_TEXTURE2D] = UnityEngine.Texture2D.blackTexture.handle, pc.UniformDefaultValues[pc.UNIFORMTYPE_TEXTURECUBE] = UnityEngine.Cubemap.blackCube.handle, pc.UniformDefaultValues[pc.UNIFORMTYPE_TEXTURE2D_SHADOW] = UnityEngine.Texture2D.blackTexture.handle, pc.UniformDefaultValues[pc.UNIFORMTYPE_TEXTURECUBE_SHADOW] = UnityEngine.Cubemap.blackCube.handle
                }
                installPlayroundOverrides() {
                    const overrides = window.playgroundOverrides || {};
                    for (const className in overrides) {
                        if (!overrides.hasOwnProperty(className)) continue;
                        const classNameString = JSON.stringify(className),
                            backupClassNameString = JSON.stringify("_" + className);
                        let code = "Deserializers[ " + backupClassNameString + " ] = Deserializers[ " + classNameString + "];\n";
                        code += "Deserializers[ " + classNameString + " ] = function () {\n", code += "  var result = Deserializers[ " + backupClassNameString + " ].apply( this, arguments );\n";
                        const fields = overrides[className];
                        for (const t in fields) {
                            if (!fields.hasOwnProperty(t)) continue;
                            const e = fields[t];
                            switch (e[0]) {
                                case "float":
                                case "int":
                                case "string":
                                    code += "  result." + t + " = " + JSON.stringify(e[1]) + "; \n";
                                    break;
                                case "boolean":
                                    code += "  result." + t + " = " + JSON.stringify(!!e[1]) + "; \n";
                                    break;
                                case "color":
                                    code += "  result." + t + " = new pc.Color(" + e.slice(1, 5).join(",") + "); \n";
                                    break;
                                case "vector2":
                                    code += "  result." + t + " = new pc.Vec2(" + e.slice(1, 3).join(",") + "); \n";
                                    break;
                                case "vector3":
                                    code += "  result." + t + " = new pc.Vec3(" + e.slice(1, 4).join(",") + "); \n";
                                    break;
                                case "vector4":
                                    code += "  result." + t + " = new pc.Vec4(" + e.slice(1, 5).join(",") + "); \n";
                                    break;
                                case "enum":
                                    code += "  result." + t + " = " + parseInt(e[1], 10) + "; \n"
                            }
                        }
                        code += "  return result;\n", code += "}", eval("(function() { " + code + "})()")
                    }
                }
                muteAudio() { this.audioManager.volume = 0 }
                unmuteAudio() { this.audioManager.volume = 1 }
                pause() { _core_index_js__WEBPACK_IMPORTED_MODULE_2__.c.pause(), this.paused = !0, this.muteAudio() }
                resume() { this.paused && (_core_index_js__WEBPACK_IMPORTED_MODULE_2__.c.resume(), this.paused = !1, this.unmuteAudio()) }
            }
            Application._currentApplication = null, Application.getApplication = () => Application._currentApplication
        }, (t, e, i) => {
            "use strict";
            i.d(e, { a: () => o, b: () => a });
            var n = i(0),
                s = (i(3), i(2)),
                r = i(9);
            i(1), i(5);
            const o = ["rigidbody", "collider", "joint", "rigidbody2D", "collider2D", "joint2D", "uiBehaviour", "monoBehaviour", "animator", "animation", "particlesystem", "particleSystemRenderer", "reflectionprobe", "videoPlayer", "canvasRenderer", "audiosourceunity", "renderer", "meshFilter", "effector2D"];
            class a extends s.a {
                constructor(t) { super(t), this.id = "unity", this.description = "Supports Unity-like components.", this.creatingPrefabs = !1, this._components = {}, this.app.systems.unitymanager.registerSystem(this), this.queues = { onStart: new r.a, onBeforeUpdates: new r.a, onFixedUpdate: new r.a, onUpdate: new r.a, onPostUpdate: new r.a, onBeforeRender: new r.a, onAfterRender: new r.a, onApplicationFocus: new r.a } }
                addComponent(t, e) { if (e._id) throw new Error("Component already belongs somewhere!"); return e._id = (0, n.b)(), e._entity = t, e.system = this, e.scriptsExecutionOrder = 0, t._unityComponents[this.id].push(e), this._components[e._id] = e, e.onAttached(), t.enabled && e.enabled && e._onEntityStateChanged(!0), e }
                removeComponent(t, e) {
                    this._onComponentDisabled(e);
                    const i = t._unityComponents[e._system.id],
                        n = i.indexOf(e);
                    n < 0 || (i[n] = i[i.length - 1], i.length -= 1)
                }
                onStart(t) { this._invokeQueue("onStart", t, !0) }
                onBeforeUpdates(t) { this._invokeQueue("onBeforeUpdates", t) }
                onFixedUpdate(t) { this._invokeQueue("onFixedUpdate", t) }
                onUpdate(t) { this._invokeQueue("onUpdate", t) }
                onPostUpdate(t) { this._invokeQueue("onPostUpdate", t) }
                onBeforeRender(t) { this._invokeQueue("onBeforeRender", t) }
                onAfterRender(t) { this._invokeQueue("onAfterRender", t) }
                onApplicationFocus(t) { this._invokeQueue("onApplicationFocus", t) }
                _invokeQueue(t, e, i = !1) {
                    const n = this.queues[t];
                    if (0 === n.length) return;
                    const s = n.processing,
                        r = n.getComponents();
                    s || (n.processing = !0), i && n.clear();
                    for (let i = 0; i < r.length; i++) {
                        const n = r[i];
                        n.entity._enabledInHierarchy && !n.callbackActivated(t) && (n.rememberCallback(t), n[t].call(n, e))
                    }
                    i && this.queues[t].length > 0 && this._invokeQueue(t, e, i), s || (this.queues[t].processing = !1)
                }
                _onComponentEnabled(t) { const e = t._queuesToSubscribe(); for (let i = 0; i < e.length; i++) this.queues[e[i]].push(t) }
                _componentShouldStart(t) { this.queues.onStart.push(t) }
                _onComponentDisabled(t) {
                    const e = t._queuesToSubscribe();
                    for (let i = 0; i < e.length; i++) this.queues[e[i]].delete(t._id);
                    this.queues.onStart.delete(t._id)
                }
            }
        }, (t, e, i) => {
            "use strict";
            i.d(e, { a: () => r });
            i(1), i(4);
            let n = 0;
            const s = {};
            class r {
                constructor() { this._enabled = !0, this._destroyed = !1, this.$id = "0", this._id = null, this._entity = null, this._system = null, this._code = null, this.internalExecutionOrder = 0, this.scriptsExecutionOrder = 0, this._scriptsExecutionOrder = 0, this._sortingOrderInQueue = n++, this._activatedCallbacks = { onAwake: !1, onEnable: !1, onStart: !1, onDisable: !0, onDestroy: !1 } }
                get code() { return this._code }
                set code(t) { this._code = t }
                get sortingOrderInQueue() { return parseInt(this.$id, 10) }
                get enabled() { return this._enabled }
                set enabled(t) {
                    const e = this._enabled && this._entity && this._entity.enabled,
                        i = t && this._entity && this._entity.enabled;
                    this._enabled = t, e === i || LunaUnity.Application.Instance.app.systems.unitymanager.callbacksDisabled || (i ? this.onEnable() : this.onDisable())
                }
                get entity() { return this._entity }
                get system() { return this._system }
                set system(t) { this._system = t }
                configureForEntity(t) {}
                onInit(t) { return !this._destroyed && !this._activatedCallbacks.onAwake && (this._activatedCallbacks.onAwake = !0, this._activatedCallbacks.onDestroy = !1, this.onAwake(t), !0) }
                onAwake(t) {}
                onAttached() {}
                onEnable() { return !this._destroyed && !this._activatedCallbacks.onEnable && (this._activatedCallbacks.onEnable = !0, this._activatedCallbacks.onDisable = !1, this._system._onComponentEnabled(this), this._activatedCallbacks.onStart || this._system._componentShouldStart(this), !0) }
                onStart() {}
                onDisable() { return !this._destroyed && !this._activatedCallbacks.onDisable && (this._activatedCallbacks.onDisable = !0, this._activatedCallbacks.onEnable = !1, this._system._onComponentDisabled(this), !0) }
                onDestroy() { return !this._destroyed && !this._activatedCallbacks.onDestroy && (this._activatedCallbacks.onDestroy = !0, !0) }
                rememberCallback(t) { t in this._activatedCallbacks && (this._activatedCallbacks[t] = !0) }
                callbackActivated(t) { return this._activatedCallbacks[t] }
                _onEntityStateChanged(t) { LunaUnity.Application.Instance.app.systems.unitymanager.callbacksDisabled || (t ? this.onEnable() : this.onDisable()) }
                _queuesToSubscribe() { return [] }
                destroy() { this._system && this._entity && this._system.removeComponent(this._entity, this), this._destroyed = !0 }
                toUnityObject() { return this.unityClass ? UnityEngine.Object.FromHandle(this.unityClass, this) : null }
            }
            r.prototype.unityClass = null, r.addRequiredComponents = (t, e, i) => {
                if (!e) return;
                const n = Bridge.getTypeName(e),
                    o = Deserializers.typeNameToIdMap[n];
                if (void 0 === o) return;
                let a;
                s.hasOwnProperty(o) ? a = s[o] : (a = [], a.push(o), r.getAllRequiredComponents(o, a), s[o] = a);
                const c = UnityEngine.Object.FromHandle(UnityEngine.GameObject, t);
                for (let t = 1; t < a.length; t++) {
                    const e = a[t],
                        n = Bridge._getTypeByName(Deserializers.types[e]);
                    if (!c.GetComponent(n)) {
                        const t = c.AddComponent(n);
                        i.push(t.handle)
                    }
                }
            }, r.getAllRequiredComponents = (t, e) => {
                const i = Deserializers.requiredComponents[t];
                if (i && 0 !== i.length)
                    for (let t = 0; t < i.length; t++) {
                        const n = i[t];
                        e.indexOf(n) >= 0 || (e.push(n), r.getAllRequiredComponents(n, e))
                    }
            }
        }, , (t, e, i) => {
            "use strict";
            i.d(e, { a: () => r });
            var n = i(0);
            i(2), i(1);
            let s = 0;
            class r {
                constructor(t, e) { this.id = s++, this.system = t, this.entity = e, this.data = null, this.events = new n.a(this), this.events.on("set_enabled", this.onSetEnabled, this) }
                get enabled() { throw new Error("Should be overwritten") }
                set enabled(t) { throw new Error("Should be overwritten") }
                onSetEnabled(t, e, i) { e !== i && this.entity.enabled && (i ? this.onEnable() : this.onDisable()) }
                onEnable() {}
                onDisable() {}
                destroy() { this.system && this.entity && this.system.removeComponent(this.entity) }
                toUnityObject() { return this.unityClass ? UnityEngine.Object.FromHandle(this.unityClass, this) : null }
            }
            r.prototype.unityClass = null
        }, (t, e, i) => {
            "use strict";
            i.d(e, { a: () => C });
            var n = i(6),
                s = i(0);
            const r = new n.b,
                o = new n.b,
                a = new n.a,
                c = new n.a,
                h = new n.d,
                l = new n.d,
                u = new n.d,
                d = new n.d,
                p = { invRotation: new n.b, invScale: new n.d, invRotationMatrix: new n.a, invScaleMatrix: new n.a },
                _ = { parentLocalRotation: new n.b, rotationMultiplier: new n.d },
                f = { newLocalRotation: new n.b },
                m = { invLocalRotation: new n.b, rotationMultiplier: new n.d },
                y = { currentRSInverse: new n.a },
                g = { newLocalRotation: new n.b },
                E = { tempVector: new n.d },
                A = { tmpVector: new n.d },
                b = { tmpVector: new n.d, tmpMatrix: new n.a, desiredLocalScale: new n.d, desiredWorldPosition: new n.d };
            class C {
                constructor(t = "Untitled") { this.name = t, this.tag = null, this._localPosition = new n.d(0, 0, 0), this._localRotation = new n.b(0, 0, 0, 1), this._localScale = new n.d(1, 1, 1), this._localEulerAngles = new n.d(0, 0, 0), this._localTransform = new n.a, this._position = new n.d(0, 0, 0), this._rotation = new n.b(0, 0, 0, 1), this._eulerAngles = new n.d(0, 0, 0), this._lossyScale = new n.d(1, 1, 1), this._worldTransform = new n.a, this._worldTransformInverse = new n.a, this._hijackedLocalPosition = new n.d, this._hijackedLocalScale = new n.d, this._hijackedLocalEulerAngles = new n.d, this._hijackedLocalRotation = new n.b, this._aabbVer = 0, this._right = null, this._up = null, this._forward = null, this._static = !1, this._parent = null, this._children = [], this._graphDepth = 0, this._cullingLayer = 0, this.layerMask = 0, this._activeSelf = !0, this._enabledInHierarchy = !1, this.hasChanged = !0, this._layoutElements = [], this._layoutControllers = [], this._layoutSelfControllers = [], this._dimensionListeners = [], this._canvasElements = [], this._canvasGroups = [], this._meshModifiers = [], this.isPrefab = !1, this._app = null, this.events = new s.a(this), this._unityComponents = { rigidbody: [], collider: [], joint: [], rigidbody2D: [], collider2D: [], joint2D: [], uiBehaviour: [], monoBehaviour: [], animator: [], animation: [], particlesystem: [], particleSystemRenderer: [], reflectionprobe: [], videoPlayer: [], canvasRenderer: [], audiosourceunity: [], renderer: [], meshFilter: [], effector2D: [] }, this.c = {}, this.flags = 0, this.scene = null }
                get element() { return this.c.element }
                get camera() { return this.c.camera }
                get light() { return this.c.light }
                get screen() { return this.c.screen }
                removeOrReparent(t, e = !1) { t ? this.parent.removeChild(this) : this.reparent(t) }
                destroy() { this.removeOrReparent(null) }
                getLossyScale() { return this.flags & C.Flags.LossyScaleDirty ? (this.flags &= ~C.Flags.LossyScaleDirty, r.copy(this.getRotation()), c.setTRS(n.d.ZERO, r.invert(), n.d.ONE), this.getWorldRotationAndScale(a), c.mul2(c, a), this._lossyScale.set(c.data[0], c.data[5], c.data[10]), this._lossyScale) : this._lossyScale }
                _onInsertChild(t) {
                    t._parent = this, t.element && (this.setupCanvasGroups(t), t.notifyCanvasGroupChanged(t)), t.notifyScreenHierarchyChanged();
                    const e = t._activeSelf && this.enabled;
                    if (t._enabledInHierarchy !== e && (t._enabledInHierarchy = e, t._notifyHierarchyStateChanged(t, e)), t._updateGraphDepth(), t.onParentChanged(), t.events.fire("insert", this), !t.element)
                        for (let e = 0; e < t._children.length; e++) {
                            const i = t._children[e].element;
                            i && i._onInsert(t)
                        }
                    this.notifyTransformChildrenChanged(), t.notifyTransformParentChanged();
                    const i = this._app.systems;
                    i.physics.syncHierarchy(t), i.physics2D.syncHierarchy(t)
                }
                muteTransformModificationCallback() { this.flags |= C.Flags.TransformModificationCallbackMuted }
                unmuteTransformModificationCallback() { this.flags &= ~C.Flags.TransformModificationCallbackMuted, this.flags & C.Flags.TransformModificationCallbackRequested && (this._onModifyTransform(), this.flags &= ~C.Flags.TransformModificationCallbackRequested) }
                _onModifyTransform() {
                    if (this.flags & C.Flags.TransformModificationCallbackMuted) return void(this.flags |= C.Flags.TransformModificationCallbackRequested);
                    if (!this._app) return;
                    const t = this._app.systems;
                    t.physics.syncTransforms(this), t.physics2D.syncTransforms(this)
                }
                lookAt(t, e) { h.copy(t), l.copy(e), a.setLookAt(this.getPosition(), h, l), r.setFromMat4(a), this.setRotation(r) }
                translate(t, e, i) { t instanceof n.d ? h.copy(t) : h.set(t, e, i), h.add(this.getPosition()), this.setPosition(h) }
                translateLocal(t, e, i) { t instanceof n.d ? h.copy(t) : h.set(t, e, i), this.getLocalRotation().transformVector(h, h), h.add(this.getLocalPosition()), this.setLocalPosition(h) }
                rotate(t, e, i) {
                    if (t instanceof n.d ? r.setFromEulerAngles(t.x, t.y, t.z) : r.setFromEulerAngles(t, e, i), null === this._parent) o.mul2(r, this.getLocalRotation()), this.setLocalRotation(o);
                    else {
                        const t = this.getRotation(),
                            e = this._parent.getRotation();
                        o.copy(e).invert().mul2(o, r).mul2(r, t), this.setLocalRotation(o)
                    }
                }
                rotateLocal(t, e, i) { t instanceof n.d ? r.setFromEulerAngles(t.x, t.y, t.z) : r.setFromEulerAngles(t, e, i), r.mul2(this.getLocalRotation(), r), this.setLocalRotation(r) }
                _isOddlyScaled() {
                    const t = this.getWorldTransform().data,
                        e = t[0],
                        i = t[1],
                        n = t[2],
                        s = t[4],
                        r = t[5],
                        o = t[6],
                        a = t[8],
                        c = t[9],
                        h = t[10];
                    return e * (r * h - o * c) - s * (i * h - n * c) + a * (i * o - n * r) < 0
                }
                _sync() { this.flags & C.Flags.HijackedByElementComponent ? this._syncElementComponent() : this._syncGraphNode() }
                _syncElementComponent() {
                    const { tmpVector: t } = A;
                    this.parent && this.parent._sync();
                    const e = this.element,
                        i = e._dirtyRect,
                        s = e._dirtyScreen;
                    let r = this.element._lastSyncAABBVersion !== this.aabbVersion;
                    if (!i && !s && !r) return;
                    this.hasChanged = !0, this.flags &= ~C.Flags.HijackedByElementComponent;
                    const o = e._width,
                        a = e._height;
                    if (i || r) {
                        const i = e._findParentElement();
                        if (i) {
                            const s = i.element;
                            if (e._width = (e._anchors.z - e._anchors.x) * s._width + e._sizeDelta.x, e._height = (e._anchors.w - e._anchors.y) * s._height + e._sizeDelta.y, this._parent === i) {
                                const i = s._width * e._anchors.x,
                                    r = s._width * e._anchors.z,
                                    o = s._height * e._anchors.y,
                                    a = s._height * e._anchors.w;
                                t.set((0, n.f)(i, r, e._pivot.x) + e._anchoredPosition.x, (0, n.f)(o, a, e._pivot.y) + e._anchoredPosition.y, 0), this.setLocalPosition(t.x - s._pivotPoint.x, t.y - s._pivotPoint.y, this.getLocalPosition().z)
                            } else this.setLocalPosition(e._anchoredPosition.x, e._anchoredPosition.y, this.getLocalPosition().z)
                        } else e._width = e._sizeDelta.x, e._height = e._sizeDelta.y, this.setLocalPosition(e._anchoredPosition.x, e._anchoredPosition.y, this.getLocalPosition().z)
                    }
                    if (r = this.element._lastSyncAABBVersion !== this.aabbVersion, r || s || i) {
                        e._pivotPoint.set(e._width * e._pivot.x, e._height * e._pivot.y, 0), this._tryResizeScreen();
                        const t = e.cachedRect;
                        t.m_XMin = -e._pivotPoint.x, t.m_YMin = -e._pivotPoint.y, t.m_Width = e._width, t.m_Height = e._height, t.m_XMax = t.m_XMin + t.m_Width, t.m_YMax = t.m_YMin + t.m_Height, e.events.fire("resize", e._width, e._height)
                    }
                    e._lastSyncAABBVersion = this.aabbVersion, e._dirtyRect = !1, e._dirtyScreen = !1, this.flags |= C.Flags.HijackedByElementComponent;
                    const c = e._width !== o,
                        h = e._height !== a;
                    i || !c && !h || e.triggerOnElementDimesionsChange(c, h)
                }
                _tryResizeScreen() {
                    const t = this.element,
                        { tmpMatrix: e, tmpVector: i, desiredLocalScale: s, desiredWorldPosition: r } = b,
                        o = this.screen;
                    if (!(o && !o._findParentScreen())) return;
                    const a = o.resolution;
                    switch (o.screenType) {
                        case pc.SCREEN_TYPE_SCREEN:
                            { t._width = a.x / o.scale, t._height = a.y / o.scale, r.set(.5 * a.x, .5 * a.y, 0), this.setPosition(r), i.set(o.scale, o.scale, o.scale), e.setTRS(n.d.ZERO, this.getRotation(), i), this.setWorldRotationAndScale(e); const s = this.getLocalPosition();t._anchoredPosition.set(s.x, s.y), t._pivotPoint.set(.5 * t._width, .5 * t._height, 0); break }
                        case pc.SCREEN_TYPE_CAMERA:
                            { const e = o.camera._component.entity;t._width = a.x / o.scale, t._height = a.y / o.scale, t._sizeDelta.copy(a), s.set(1, 1, 1), s.scale(o._planeHeight / t._height), i.set(0, 0, o._screenDistance), e.transformPoint(i, i, !0), this.setPosition(i), this.setRotation(e.getRotation()), this.setLocalScale(s); const n = this.getLocalPosition();t._anchoredPosition.set(n.x, n.y), t._pivotPoint.set(.5 * t._width, .5 * t._height, 0); break }
                        case pc.SCREEN_TYPE_WORLD:
                            t._width = t._sizeDelta.x, t._height = t._sizeDelta.y, this.setLocalPosition(t._anchoredPosition.x, t._anchoredPosition.y, this.getLocalPosition().z)
                    }
                    t._sizeDelta.set(t._width, t._height)
                }
                _syncGraphNode() { this.parent && this.parent._sync() }
                findByNameImmediate(t) { for (let e = 0; e < this._children.length; e++) { const i = this._children[e]; if (i.name === t) return i } return null }
                findByNameEnabled(t) { return t ? this.findByNamesEnabledInternal(t.split("/"), 0) : null }
                findByNamesEnabledInternal(t, e) {
                    if (!this.enabled) return null;
                    if (this.scene || this.name !== t[e]) e = 0;
                    else {
                        if (e === t.length - 1) return this;
                        e++
                    }
                    for (let i = 0; i < this._children.length; i++) { const n = this._children[i].findByNamesEnabledInternal(t, e); if (null !== n) return n }
                    return null
                }
                getWorldRotationAndScale(t = new n.a) {
                    if (t.setTRS(n.d.ZERO, this.getLocalRotation(), this.getLocalScale()), this.parent) {
                        const e = this.parent.getWorldRotationAndScale();
                        t.mul2(e, t)
                    }
                    return t
                }
                getWorldRotationAndScaleInverse(t = new n.a, e = null) {
                    const { invRotation: i, invRotationMatrix: s, invScale: r, invScaleMatrix: o } = p;
                    if (i.copy(this.getLocalRotation()).invert(), s.setRotation(i), r.copy(e || this.getLocalScale()).invertSafe(), o.setScale(r.x, r.y, r.z), t.mul2(o, s), this.parent) {
                        const e = this.parent.getWorldRotationAndScaleInverse();
                        t.mul2(t, e)
                    }
                    return t
                }
                setWorldRotationAndScale(t) {
                    const { currentRSInverse: e } = y;
                    this.getWorldRotationAndScaleInverse(e, n.d.ONE), e.mul2(e, t), this.setLocalScale(e.data[0], e.data[5], e.data[10])
                }
                getLocalRotationAndScale(t = new n.a) { return t.setTRS(n.d.ZERO, this.getLocalRotation(), this.getLocalScale()), t }
                setParent(t, e) {
                    if (e) {
                        const e = this.getPosition().clone(),
                            i = this.getRotation().clone(),
                            n = this.getWorldRotationAndScale();
                        this.removeOrReparent(t, !0), this.muteTransformModificationCallback(), this.setPosition(e), this.setRotation(i), this.setWorldRotationAndScale(n), this.unmuteTransformModificationCallback()
                    } else {
                        const e = this.getLocalScale().clone(),
                            i = this.getLocalPosition(),
                            n = this.getLocalRotation().clone();
                        this.removeOrReparent(t, !0), this.muteTransformModificationCallback(), this.setLocalScale(e), this.setLocalPosition(i), this.setLocalRotation(n), this.unmuteTransformModificationCallback()
                    }
                    if (this.element) {
                        const t = pc.UIUtils.findParentScreen(this);
                        this.reparentElementRecursive(t)
                    }
                }
                reparentElementRecursive(t) {
                    if (this.element) {
                        const e = this._unityComponents ? this._unityComponents.canvasRenderer[0] : null;
                        e && e.reparentCanvas(t)
                    }
                    const e = this.children;
                    for (let i = 0; i < e.length; i++) { e[i].reparentElementRecursive(t) }
                }
                isParentOf(t) { const e = t._graphDepth - this._graphDepth; if (e <= 0 || e >= t._graphDepth || null === t.parent) return !1; let i = t; for (let t = 0; t < e; t++) i = i.parent; return i === this }
                isChildOf(t) { return t.isParentOf(this) }
                _notifyHierarchyStateChanged(t, e) { t._onHierarchyStateChanged(e); const i = t._children; for (let t = 0, n = i.length; t < n; t++) i[t]._activeSelf && this._notifyHierarchyStateChanged(i[t], e) }
                _elementDimesionsChange() {}
                _onHierarchyStateChanged(t) { this._enabledInHierarchy = t }
                findByTag(t) { return this._findByTag(t) }
                _findByTag(t) {
                    const e = [];
                    for (let i = 0; i < this._children.length; i++) {
                        const n = this._children[i];
                        if (!n._enabledInHierarchy) continue;
                        n.tag === t && e.push(n);
                        const s = n._findByTag(t);
                        s.length && e.push(...s)
                    }
                    return e
                }
                findByName(t) { if (this.name === t) return this; for (let e = 0; e < this._children.length; e++) { const i = this._children[e].findByName(t); if (null !== i) return i } return null }
                getRoot() { return this.root }
                getParent() { return this._parent }
                parents() { const t = []; let e = this.parent; for (; null != e;) t.push(e), e = e.parent; return t }
                allChildren(t = []) { for (let e = 0; e < this.children.length; e++) t.push(this.children[e]), this.children[e].allChildren(t); return t }
                getScene() { const t = this.parent; return t ? t.scene ? t.scene : t.getScene() : null }
                isDescendantOf(t) {
                    let e = this._parent;
                    for (; e;) {
                        if (e === t) return !0;
                        e = e._parent
                    }
                    return !1
                }
                isAncestorOf(t) { return t.isDescendantOf(this) }
                getChildren() { return this._children }
                getEulerAngles() { return this.flags & C.Flags.EulerAnglesDirty && (this.getRotation().getEulerAngles_Unity(this._eulerAngles), this.flags &= ~C.Flags.EulerAnglesDirty), this._eulerAngles }
                setEulerAngles(t, e, i) { t instanceof n.d ? r.setFromEulerAngles_Unity(t.x, t.y, t.z) : r.setFromEulerAngles_Unity(t, e, i), this.setRotation(r) }
                getLocalEulerAngles() { return this.flags & C.Flags.LocalEulersAnglesDirty && (this.getLocalRotation().getEulerAngles_Unity(this._localEulerAngles), this.flags &= ~C.Flags.LocalEulersAnglesDirty), this._localEulerAngles }
                setLocalEulerAngles(t, e, i) {
                    const { newLocalRotation: s } = g;
                    t instanceof n.d ? s.setFromEulerAngles_Unity(t.x, t.y, t.z) : s.setFromEulerAngles_Unity(t, e, i), this.setLocalRotation(s)
                }
                getLocalPosition() { return this.flags & C.Flags.HijackedByElementComponent ? this.getLocalPositionElementComponent() : this.getLocalPositionGraphNode() }
                getLocalPositionGraphNode() { return this._localPosition }
                getLocalPositionElementComponent() { return this.element.getRect(), this.getLocalPositionGraphNode() }
                setLocalPosition(t, e, i) { this.flags & C.Flags.HijackedByElementComponent ? this.setLocalPositionElementComponent(t, e, i) : this.setLocalPositionGraphNode(t, e, i) }
                setLocalPositionGraphNode(t, e, i) { t instanceof n.d ? l.copy(t) : l.set(t, e, i), this._localPosition.approximatelyEquals(l, Number.EPSILON) || (this._localPosition.copy(l), this.onLocalPositionChanged(), this._onModifyTransform()) }
                setLocalPositionElementComponent(t, e, i) {
                    const { tempVector: s } = E;
                    s.copy(this.getLocalPositionElementComponent()), t instanceof n.d ? (this.setLocalPositionGraphNode(s.x, s.y, t.z), s.sub2(t, s)) : (this.setLocalPositionGraphNode(s.x, s.y, i), s.x = t - s.x, s.y = e - s.y), this.element._anchoredPosition.add(s), this.element.dirtifyRect()
                }
                getLocalRotation() { return this._localRotation }
                setLocalRotation(t, e, i, s) { t instanceof n.b ? r.copy(t) : r.set(t, e, i, s), r.normalize(), this._localRotation.approximatelyEquals(r, Number.EPSILON) || (this._localRotation.copy(r), this.onLocalRotationChanged(), this._onModifyTransform()) }
                getLocalScale() { return this._localScale }
                setLocalScale(t, e, i) { t instanceof n.d ? h.copy(t) : h.set(t, e, i), this._localScale.approximatelyEquals(h, Number.EPSILON) || (this._localScale.copy(h), this.onLocalScaleChanged(), this._onModifyTransform()) }
                getLocalScaleSign(t) {
                    const e = this.getLocalScale();
                    t.set(Math.sign(e.x) || 1, Math.sign(e.y) || 1, Math.sign(e.z) || 1)
                }
                getLocalScaleRotationMultipliers(t) {
                    this.getLocalScaleSign(t);
                    const e = t.x,
                        i = t.y,
                        n = t.z,
                        s = i * n,
                        r = e * n,
                        o = e * i;
                    t.set(s, r, o)
                }
                getLocalTransform() { return this.flags & C.Flags.LocalTransformDirty ? (this.flags &= ~C.Flags.LocalTransformDirty, this._localTransform.setTRS(this.getLocalPosition(), this.getLocalRotation(), this.getLocalScale()), this._localTransform) : this._localTransform }
                setLocalTransform(t) { this.muteTransformModificationCallback(), this.setLocalPosition(t.getTranslation()), this.setLocalRotation(t.getRotation()), this.setLocalScale(t.getScale()), this.unmuteTransformModificationCallback() }
                getPosition() {
                    if (!(this.flags & C.Flags.PositionDirty)) return this._position;
                    this.flags &= ~C.Flags.PositionDirty, this._position.copy(this.getLocalPosition());
                    let t = this.parent;
                    for (; t;) this._position.mul(t.getLocalScale()), t.getLocalRotation().transformVector(this._position, this._position), this._position.add(t.getLocalPosition()), t = t.parent;
                    return this._position
                }
                setPosition(t, e, i) { t instanceof n.d ? u.copy(t) : u.set(t, e, i), this.parent && this.parent.transformPointInverse(u, u), this.setLocalPosition(u) }
                getRotation() {
                    if (!(this.flags & C.Flags.RotationDirty)) return this._rotation;
                    this.flags &= ~C.Flags.RotationDirty;
                    const { parentLocalRotation: t, rotationMultiplier: e } = _;
                    this._rotation.copy(this.getLocalRotation());
                    let i = this.parent;
                    for (; i;) {
                        i.getLocalScaleRotationMultipliers(e);
                        const n = e.x,
                            s = e.y,
                            r = e.z;
                        t.copy(i.getLocalRotation()), t.x *= n, t.y *= s, t.z *= r, this._rotation.mul2(t, this._rotation), this._rotation.x *= n, this._rotation.y *= s, this._rotation.z *= r, i = i.parent
                    }
                    return this._rotation
                }
                setRotation(t, e, i, s) {
                    const { newLocalRotation: r } = f;
                    t instanceof n.b ? r.copy(t) : r.set(t, e, i, s), this.parent ? this.setLocalRotation(this.parent.transformQuaternionInverse(r)) : this.setLocalRotation(r)
                }
                getWorldTransform() { return this.flags & C.Flags.WorldTransformDirty ? (this.flags &= ~C.Flags.WorldTransformDirty, this.parent ? this._worldTransform.mul2(this._parent.getWorldTransform(), this.getLocalTransform()) : this._worldTransform.copy(this.getLocalTransform()), this._worldTransform) : this._worldTransform }
                setWorldTransform(t) {
                    this.muteTransformModificationCallback(), this.setPosition(t.getTranslation()), this.setRotation(t.getRotation());
                    const e = t.clone();
                    e.data[12] = e.data[13] = e.data[14] = 0, this.setWorldRotationAndScale(e), this.unmuteTransformModificationCallback()
                }
                getWorldTransformInverse() { return this.flags & C.Flags.WorldTransformInverseDirty ? (this.flags &= ~C.Flags.WorldTransformInverseDirty, this._worldTransformInverse.copy(this.getWorldTransform()).invert(), this._worldTransformInverse) : this._worldTransformInverse }
                transformPoint(t, e = new n.d, i = !1) { e.copy(t); let s = this; for (; s;) i || e.mul(s.getLocalScale()), s.getLocalRotation().transformVector(e, e), e.add(s.getLocalPosition()), s = s.parent; return e }
                transformPointInverse(t, e = new n.d) { return this.parent ? this.parent.transformPointInverse(t, e) : e.copy(t), e.sub(this.getLocalPosition()), r.copy(this.getLocalRotation()).invert().transformVector(e, e), e.mul(l.copy(this.getLocalScale()).invertSafe()), e }
                transformVector(t, e = new n.d) { e.copy(t); let i = this; for (; i;) e.mul(i.getLocalScale()), i.getLocalRotation().transformVector(e, e), i = i.parent; return e }
                transformVectorInverse(t, e = new n.d) { return this.parent ? this.parent.transformVectorInverse(t, e) : e.copy(t), r.copy(this.getLocalRotation()).invert().transformVector(e, e), e.mul(l.copy(this.getLocalScale()).invertSafe()), e }
                transformDirection(t, e = new n.d) { e.copy(t), this.getLocalRotation().transformVector(e, e); let i = this.parent; for (; i;) i.getLocalScaleSign(d), e.x *= d.x, e.y *= d.y, e.z *= d.z, i.getLocalRotation().transformVector(e, e), i = i.parent; return e }
                transformDirectionInverse(t, e = new n.d, i = !1) {
                    if (this.parent ? this.parent.transformDirectionInverse(t, e, !0) : e.copy(t), r.copy(this.getLocalRotation()).invert().transformVector(e, e), i) {
                        const t = this.getLocalScale(),
                            i = Math.sign(t.x) || 1,
                            n = Math.sign(t.y) || 1,
                            s = Math.sign(t.z) || 1;
                        e.x *= i, e.y *= n, e.z *= s
                    }
                    return e
                }
                transformQuaternionInverse(t, e = new n.b) { const { invLocalRotation: i, rotationMultiplier: s } = m; return this.parent ? this.parent.transformQuaternionInverse(t, e) : e.copy(t), i.copy(this.getLocalRotation()).invert(), e.mul2(i, e), this.getLocalScaleRotationMultipliers(s), e.x *= s.x, e.y *= s.y, e.z *= s.z, e }
                hijackLocalPosition() { return this.flags & C.Flags.LocalPositionHijacked || (this.flags |= C.Flags.LocalPositionHijacked, this._hijackedLocalPosition.copy(this.getLocalPosition())), this._hijackedLocalPosition }
                hijackLocalScale() { return this.flags & C.Flags.LocalScaleHijacked || (this.flags |= C.Flags.LocalScaleHijacked, this._hijackedLocalScale.copy(this.getLocalScale())), this._hijackedLocalScale }
                hijackLocalEulerAngles() { return this.flags & C.Flags.LocalEulerAnglesHijacked || (this.flags |= C.Flags.LocalEulerAnglesHijacked, this._hijackedLocalEulerAngles.copy(this.getEulerAngles())), this._hijackedLocalEulerAngles }
                hijackLocalRotation() { return this.flags & C.Flags.LocalRotationHijacked || (this.flags |= C.Flags.LocalRotationHijacked, this._hijackedLocalRotation.copy(this.getLocalRotation())), this._hijackedLocalRotation }
                releaseHijackedProperties() { this.flags & C.Flags.LocalPositionHijacked && (this.flags &= ~C.Flags.LocalPositionHijacked, this.setLocalPosition(this._hijackedLocalPosition)), this.flags & C.Flags.LocalScaleHijacked && (this.flags &= ~C.Flags.LocalScaleHijacked, this.setLocalScale(this._hijackedLocalScale)), this.flags & C.Flags.LocalRotationHijacked && (this.flags &= ~C.Flags.LocalRotationHijacked, this.setLocalRotation(this._hijackedLocalRotation)), this.flags & C.Flags.LocalEulerAnglesHijacked && (this.flags &= ~C.Flags.LocalEulerAnglesHijacked, this.setLocalEulerAngles(this._hijackedLocalEulerAngles)) }
                reparent(t, e) {
                    this.notifyBeforeTransformParentChanged();
                    const i = this._parent;
                    if (this.element && this.element._nearestScreen && (this.element._nearestScreen.canvasMeshInstance.renderersDirty = !0), i)
                        if (i !== t) i.removeChild(this, !0), i.notifyTransformChildrenChanged();
                        else if (t) return void t.moveChildIndex(this, e);
                    t && (e >= 0 ? t.insertChild(this, e) : t.addChild(this)), this._app.scene.addDirty(this)
                }
                addChild(t) {
                    if (null !== t._parent) throw new Error("GraphNode is already parented");
                    this._children.push(t), this._onInsertChild(t)
                }
                insertChild(t, e) {
                    if (null !== t._parent) throw new Error("GraphNode is already parented");
                    this._children.splice(e, 0, t), this._onInsertChild(t)
                }
                moveChildIndex(t, e) {
                    if (e < 0) {
                        const e = this._children.indexOf(t);
                        this._children.push(this._children.splice(e, 1)[0])
                    } else {
                        const i = this._children.indexOf(t);
                        this._children.splice(i, 1), this._children.splice(e, 0, t)
                    }
                    t.onParentChanged(), this.element && this.element.triggerOnElementDimesionsChange(!0, !0)
                }
                setupCanvasGroups(t) {
                    let e = t.parent;
                    for (; e && e.element && 0 === t._parent.element._canvasGroups.length;) e = e.parent;
                    e && e.element && t._parent.element._canvasGroups.length > 0 && (t.element._canvasGroups = t._parent.element._canvasGroups.slice()), this.setupCanvasGroupsInChildren(t, t.element._canvasGroups)
                }
                setupCanvasGroupsInChildren(t, e) { if (t.element) { t.element._canvasGroups = e.slice(); for (let e = 0; e < t._canvasGroups.length; e++) t.element._canvasGroups.unshift(t._canvasGroups[e]); for (let e = 0; e < t.children.length; e++) this.setupCanvasGroupsInChildren(t.children[e], t.element._canvasGroups) } }
                notifyScreenHierarchyChanged() {
                    const t = pc.UIUtils.findParentScreen(this.parent);
                    this.notifyScreenChanged(t), this.tryReparentScreen(t, this.children)
                }
                tryReparentScreen(t, e) {
                    for (let i = 0; i < e.length; i++) {
                        const n = e[i];
                        n.screen ? n.screen.setParentScreen(t, !0) : n.tryReparentScreen(t, n.children)
                    }
                }
                _updateGraphDepth() { this._parent ? this._graphDepth = this._parent._graphDepth + 1 : this._graphDepth = 0; for (let t = 0, e = this._children.length; t < e; t++) this._children[t]._updateGraphDepth() }
                removeChild(t, e = !1) {
                    t.notifyScreenHierarchyChanged(), e || t._notifyHierarchyStateChanged(t, !1);
                    for (let e = 0; e < this._children.length; ++e)
                        if (this._children[e] === t) return this._children.splice(e, 1), t._parent = null, void t.notifyScreenHierarchyChanged()
                }
                syncHierarchy() {
                    if (!this.enabled) return;
                    this._sync();
                    const t = this._children;
                    for (let e = 0, i = t.length; e < i; e++) t[e].syncHierarchy()
                }
                notifyCanvasGroupChanged(t) {
                    if (this.isPrefab) return;
                    const e = t._unityComponents.monoBehaviour,
                        i = t._unityComponents.canvasRenderer[0];
                    for (let t = 0; t < e.length; t++) { e[t].onCanvasGroupChanged() }
                    i && i.onCanvasGroupChanged();
                    const n = t.children;
                    for (let t = 0; t < n.length; t++) this.notifyCanvasGroupChanged(n[t])
                }
                notifyScreenChanged(t) {
                    if (this.isPrefab) return;
                    this.screen && (t = this.screen);
                    const e = this._unityComponents.canvasRenderer[0];
                    e && e.onScreenChanged(t);
                    const i = this.children;
                    for (let e = 0; e < i.length; e++) i[e].notifyScreenChanged(t)
                }
                notifyBeforeTransformParentChanged() { if (this.isPrefab) return; const t = this._unityComponents.monoBehaviour; for (let e = 0; e < t.length; e++) { t[e].onBeforeTransformParentChanged() } }
                notifyTransformParentChanged() { if (this.isPrefab) return; const t = this._unityComponents.monoBehaviour; for (let e = 0; e < t.length; e++) { t[e].onTransformParentChanged() } }
                notifyTransformChildrenChanged() { if (this.isPrefab) return; const t = this._unityComponents.monoBehaviour; for (let e = 0; e < t.length; e++) { t[e].onTransformChildrenChanged() } }
                onLocalRotationChanged() {
                    this.flags |= C.Flags.LocalEulersAnglesDirty, this.flags |= C.Flags.LossyScaleDirty, this.flags & C.Flags.LocalTransformDirty || (this.flags |= C.Flags.LocalTransformDirty, this.onLocalTransformChanged()), this.flags & C.Flags.RotationDirty || (this.flags |= C.Flags.RotationDirty, this.onRotationChanged());
                    for (const t of this.children) t.onParentLocalRotationChanged();
                    this.increaseTransformVersion()
                }
                onLocalScaleChanged() {
                    this.flags |= C.Flags.LossyScaleDirty, this.flags & C.Flags.LocalTransformDirty || (this.flags |= C.Flags.LocalTransformDirty, this.onLocalTransformChanged());
                    for (const t of this.children) t.onParentLocalScaleChanged();
                    this.increaseTransformVersion()
                }
                onLocalPositionChanged() {
                    this.flags |= C.Flags.PositionDirty, this.flags & C.Flags.LocalTransformDirty || (this.flags |= C.Flags.LocalTransformDirty, this.onLocalTransformChanged());
                    for (const t of this.children) t.onParentLocalPositionChanged();
                    this.increaseTransformVersion()
                }
                onRotationChanged() { this.flags |= C.Flags.EulerAnglesDirty, this.flags |= C.Flags.LossyScaleDirty, this.increaseTransformVersion() }
                onLocalTransformChanged() { this.flags & C.Flags.WorldTransformDirty || (this.flags |= C.Flags.WorldTransformDirty, this.onWorldTransformChanged()), this.increaseTransformVersion() }
                onWorldTransformChanged() {
                    this.flags |= C.Flags.WorldTransformInverseDirty;
                    for (const t of this.children) t.onParentWorldTransformChanged();
                    this.increaseTransformVersion()
                }
                onParentLocalRotationChanged() {
                    this.flags |= C.Flags.LossyScaleDirty, this.flags |= C.Flags.PositionDirty, this.flags & C.Flags.RotationDirty || (this.flags |= C.Flags.RotationDirty, this.onRotationChanged());
                    for (const t of this.children) t.onParentLocalRotationChanged();
                    this.increaseTransformVersion()
                }
                onParentLocalScaleChanged() {
                    this.flags |= C.Flags.LossyScaleDirty, this.flags |= C.Flags.PositionDirty, this.flags & C.Flags.RotationDirty || (this.flags |= C.Flags.RotationDirty, this.onRotationChanged());
                    for (const t of this.children) t.onParentLocalScaleChanged();
                    this.increaseTransformVersion()
                }
                onParentLocalPositionChanged() {
                    this.flags |= C.Flags.PositionDirty;
                    for (const t of this.children) t.onParentLocalPositionChanged();
                    this.increaseTransformVersion()
                }
                onParentWorldTransformChanged() { this.flags & C.Flags.WorldTransformDirty || (this.flags |= C.Flags.WorldTransformDirty, this.onWorldTransformChanged()), this.increaseTransformVersion() }
                onParentChanged() { this.onParentLocalPositionChanged(), this.onParentLocalRotationChanged(), this.onParentLocalScaleChanged(), this.onParentWorldTransformChanged() }
                increaseTransformVersion() { this._aabbVer++, this.flags & C.Flags.HijackedByElementComponent && this._app.scene.addDirty(this) }
                get static() { return this._static }
                set static(t) { this._static = t }
                get right() { return this._right || (this._right = new n.d), this.getWorldTransform().getX(this._right).normalize() }
                get up() { return this._up || (this._up = new n.d), this.getWorldTransform().getY(this._up).normalize() }
                get forward() { return this._forward || (this._forward = new n.d), this.getWorldTransform().getZ(this._forward).normalize() }
                get aabbVersion() { return this._aabbVer }
                get enabled() { return this._activeSelf && this._enabledInHierarchy }
                set enabled(t) { this._activeSelf !== t && (this._activeSelf = t, t && this._app.scene.addDirty(this), this._parent && !this._parent.enabled || this._notifyHierarchyStateChanged(this, t)) }
                get activeSelf() { return this._activeSelf }
                get parent() { return this._parent }
                get root() { let t = this._parent; if (!t) return this; for (; t._parent;) t = t._parent; return t }
                get children() { return this._children }
                get graphDepth() { return this._graphDepth }
                get cullingLayer() { return this._cullingLayer }
                set cullingLayer(t) { this._cullingLayer = t, this.layerMask = 1 << t }
                get lossyScale() { return this.getLossyScale() }
                get eulerAngles() { return this.getEulerAngles() }
                set eulerAngles(t) { this.setEulerAngles(t) }
                get localEulerAngles() { return this.getLocalEulerAngles() }
                set localEulerAngles(t) { this.setLocalEulerAngles(t) }
                get localPosition() { return this.getLocalPosition() }
                set localPosition(t) { this.setLocalPosition(t) }
                get localRotation() { return this.getLocalRotation() }
                set localRotation(t) { this.setLocalRotation(t) }
                get localScale() { return this.getLocalScale() }
                set localScale(t) { this.setLocalScale(t) }
                get localTransform() { return this.getLocalTransform() }
                set localTransform(t) { this.setLocalTransform(t) }
                get position() { return this.getPosition() }
                set position(t) { this.setPosition(t) }
                get rotation() { return this.getRotation() }
                set rotation(t) { this.setRotation(t) }
                get worldTransform() { return this.getWorldTransform() }
                set worldTransform(t) { this.setWorldTransform(t) }
                get worldTransformInverse() { return this.getWorldTransformInverse() }
            }
            C.Flags = { LocalEulersAnglesDirty: 1, RotationDirty: 2, EulerAnglesDirty: 4, LossyScaleDirty: 8, PositionDirty: 16, LocalTransformDirty: 32, WorldTransformDirty: 64, WorldTransformInverseDirty: 128, TransformModificationCallbackMuted: 256, TransformModificationCallbackRequested: 512, LocalPositionHijacked: 1024, LocalScaleHijacked: 2048, LocalEulerAnglesHijacked: 4096, LocalRotationHijacked: 8192, HijackedByElementComponent: 16384 }
        }, (t, e, i) => {
            "use strict";
            i.d(e, { a: () => s });
            i(5);
            const n = function(t, e) { const i = t.internalExecutionOrder - e.internalExecutionOrder; return 0 !== i ? i : t._scriptsExecutionOrder - e._scriptsExecutionOrder };
            class s {
                constructor() { this._components = [], this._needsSort = !1, this.processing = !1 }
                push(t) { t._scriptsExecutionOrder = 4294967296 * (t.scriptsExecutionOrder + 32768) + (t.sortingOrderInQueue + 2147483648), 0 !== this._components.length && t._scriptsExecutionOrder < this._components[this._components.length - 1]._scriptsExecutionOrder && (this._needsSort = !0), this._components.push(t) }
                getComponents() { return this._needsSort && (this._needsSort = !1, this._components.sort(n)), this._components.slice() }
                delete(t) {
                    for (let e = 0; e < this._components.length; e++)
                        if (t === this._components[e]._id) return void this._components.splice(e, 1)
                }
                clear() { this._components.length = 0 }
                get length() { return this._components.length }
            }
        }, (t, e, i) => {
            "use strict";
            i.d(e, { a: () => r });
            var n = i(0);
            class s {
                constructor() { this.timestamps = { scripts: 0, animations: 0, animators: 0, physics2d: 0, physics: 0, render: 0, frame: 0 }, this.times = { scripts: 0, animations: 0, animators: 0, physics2d: 0, physics: 0, render: 0, frame: 0 }, this.drawCalls = 0, this.frames = 0 }
                reset() { this.times.scripts = 0, this.times.animations = 0, this.times.animators = 0, this.times.physics2d = 0, this.times.physics = 0, this.times.render = 0, this.times.frame = 0, this.drawCalls = 0, this.frames = 0 }
            }
            class r {
                constructor(t) { this.sample = new s, this.current = new s, this.webglVersion = window.WebGL2RenderingContext ? 2 : 1, this.webglExtensions = t.gl.getSupportedExtensions() }
                getSnapshot() {
                    const t = this.sample,
                        e = Math.max(1, t.frames),
                        i = { scriptsTime: t.times.scripts / e, animationsTime: t.times.animations / e, animatorsTime: t.times.animators / e, physics2dTime: t.times.physics2d / e, physicsTime: t.times.physics / e, renderTime: t.times.render / e, frameTime: t.times.frame / e, drawCalls: t.drawCalls / e, webglVersion: this.webglVersion, webglExtensions: this.webglExtensions };
                    return t.reset(), i
                }
                tick() { this.sample.frames++, this.sample.times.scripts += this.current.times.scripts, this.sample.times.animations += this.current.times.animations, this.sample.times.animators += this.current.times.animators, this.sample.times.physics2d += this.current.times.physics2d, this.sample.times.physics += this.current.times.physics, this.sample.times.render += this.current.times.render, this.sample.times.frame += this.current.times.frame, this.sample.drawCalls += this.current.drawCalls, this.current.reset() }
                recordDrawCalls(t) { this.current.drawCalls += t }
                startSection(t) { this.current.timestamps[t] = n.c.now() }
                endSection(t) { this.current.times[t] += n.c.now() - this.current.timestamps[t] }
            }
            r.SCRIPTS = "scripts", r.ANIMATIONS = "animations", r.ANIMATORS = "animators", r.PHYSICS2D = "physics2d", r.PHYSICS = "physics", r.RENDER = "render", r.FRAME = "frame"
        }, (t, e, i) => {
            "use strict";
            var n = i(8),
                s = i(1),
                r = i(3),
                o = i(2),
                a = i(7),
                c = i(5),
                h = i(9),
                l = i(4),
                u = i(10);
            pc.GraphNode = n.a, pc.Entity = s.a, pc.Application = r.a, pc.ComponentSystem = o.a, pc.Component = a.a, pc.UnityComponent = c.a, pc.ComponentQueue = h.a, pc.UnityComponentSystem = l.b, pc.Counters = u.a, pc.FILLMODE_FILL_WINDOW = r.b, pc.FILLMODE_KEEP_ASPECT = r.c, pc.FILLMODE_NONE = r.d, pc.RESOLUTION_AUTO = r.e, pc.RESOLUTION_FIXED = r.f
        }, , (t, e, i) => {
            "use strict";
            i.d(e, { a: () => n });
            i(2), i(4);
            class n {
                constructor() { this.list = [], this.map = {} }
                get animation() { return this.map.animation }
                get animator() { return this.map.animator }
                get audiosourceunity() { return this.map.audiosourceunity }
                get monoBehaviour() { return this.map.monoBehaviour }
                get uiBehaviour() { return this.map.uiBehaviour }
                get camera() { return this.map.camera }
                get element() { return this.map.element }
                get canvasRenderer() { return this.map.canvasRenderer }
                get light() { return this.map.light }
                get meshFilter() { return this.map.meshFilter }
                get particlesystem() { return this.map.particlesystem }
                get particleSystemRenderer() { return this.map.particleSystemRenderer }
                get physics() { return this.map.physics }
                get collider() { return this.map.collider }
                get joint() { return this.map.joint }
                get rigidbody() { return this.map.rigidbody }
                get physics2D() { return this.map.physics2D }
                get collider2D() { return this.map.collider2D }
                get effector2D() { return this.map.effector2D }
                get joint2D() { return this.map.joint2D }
                get rigidbody2D() { return this.map.rigidbody2D }
                get reflectionprobe() { return this.map.reflectionprobe }
                get renderer() { return this.map.renderer }
                get screen() { return this.map.screen }
                get unitymanager() { return this.map.unitymanager }
                get videoPlayer() { return this.map.videoPlayer }
                get unity() { return this.map.unity }
                add(t) {
                    const e = t.id;
                    if (this.map[e]) throw new Error(`ComponentSystem name '${e}' already registered or not allowed`);
                    this.map[e] = t, this.list.push(t)
                }
                remove(t) {
                    const e = t.id;
                    if (!this.map[e]) throw new Error(`No ComponentSystem named '${e}' registered"`);
                    this.map[e] = null;
                    const i = this.list.indexOf(this.map[e]); - 1 !== i && this.list.splice(i, 1)
                }
            }
        }], 0, [
            [11, 0, 3, 5, 4, 2]
        ]
    ]), pc.extend(pc, function() {
        const t = 32,
            e = Math.ceil(10),
            i = {
                namesToIds: {},
                idsToNames: {},
                nextId: 0,
                getIdByName: function(t) {
                    if (void 0 === this.namesToIds[t]) {
                        if (this.nextId >= 320) return console.warn("320 keywords limit exceed. " + t + " was not added!"), null;
                        this.namesToIds[t] = this.nextId, this.idsToNames[this.nextId] = t, this.nextId++
                    }
                    return this.namesToIds[t]
                }
            },
            n = function() { return this.bitfield = new Uint32Array(e), this.cardinality = 0, this };
        return pc.extend(n.prototype, {
            setEnabledKeywords: function(t) { this.clear(); for (let e = 0; e < t.length; e++) this.enableKeyword(t[e]) },
            enableKeyword: function(t) { this.enableKeywordId(pc.KeywordsCollection.getIdByName(t)) },
            disableKeyword: function(t) { void 0 !== pc.KeywordsCollection.namesToIds[t] && this.disableKeywordId(pc.KeywordsCollection.getIdByName(t)) },
            enableKeywordId: function(e) {
                if (e >= pc.KeywordsCollection.nextId || e < 0) return;
                const i = Math.floor(e / t),
                    n = 1 << e % t;
                (this.bitfield[i] & n) === n || (this.cardinality++, this.bitfield[i] |= n)
            },
            disableKeywordId: function(e) {
                if (e >= pc.KeywordsCollection.nextId || e < 0) return;
                const i = Math.floor(e / t),
                    n = 1 << e % t;
                (this.bitfield[i] & n) === n && (this.cardinality--, this.bitfield[i] &= ~n)
            },
            isKeywordEnabled: function(t) { return void 0 !== pc.KeywordsCollection.namesToIds[t] && this.isKeywordIdEnabled(pc.KeywordsCollection.getIdByName(t)) },
            isKeywordIdEnabled: function(e) {
                if (e >= pc.KeywordsCollection.nextId || e < 0) return !1;
                const i = Math.floor(e / t),
                    n = 1 << e % t;
                return (this.bitfield[i] & n) === n
            },
            subset: function(t) { let i, n, s = !0; for (let r = 0; r < e; r++) i = this.bitfield[r], n = t.bitfield[r], s = s && (n & i) === i; return s },
            getEnabledKeywords: function() {
                const t = pc.KeywordsCollection.nextId,
                    e = [];
                for (let i = 0; i < t; i++) {
                    const t = pc.KeywordsCollection.idsToNames[i];
                    this.isKeywordEnabled(t) && e.push(t)
                }
                return e
            },
            getEnabledKeywordsIds: function() {
                const t = pc.KeywordsCollection.nextId,
                    e = [];
                for (let i = 0; i < t; i++) this.isKeywordEnabled(i) && e.push(i);
                return e
            },
            merge: function(t) {
                let i, n;
                for (let s = 0; s < e; s++) i = this.bitfield[s], n = t.bitfield[s], this.bitfield[s] = i | n;
                this.updateCardinality()
            },
            clear: function() {
                for (let t = 0; t < e; t++) this.bitfield[t] = 0;
                this.cardinality = 0
            },
            copy: function(t) {
                for (let i = 0; i < e; i++) this.bitfield[i] = t.bitfield[i];
                this.cardinality = t.cardinality
            },
            updateCardinality: function() {
                this.cardinality = 0;
                for (let t = 0; t < e; t++) {
                    let e = this.bitfield[t];
                    0 !== e && (e -= e >> 1 & 1431655765, e = (858993459 & e) + (e >> 2 & 858993459), this.cardinality += 16843009 * (e + (e >> 4) & 252645135) >> 24)
                }
            }
        }), pc.extend(n, { union: function(t, i, n) { void 0 === n ? n = new pc.KeywordSet : n.clear(); for (let s = 0; s < e; s++) n.bitfield[s] = t.bitfield[s] | i.bitfield[s]; return n.updateCardinality(), n }, intersection: function(t, i, n) { void 0 === n ? n = new pc.KeywordSet : n.clear(); for (let s = 0; s < e; s++) n.bitfield[s] = t.bitfield[s] & i.bitfield[s]; return n.updateCardinality(), n }, differenceLeft: function(t, i, n) { void 0 === n ? n = new pc.KeywordSet : n.clear(); for (let s = 0; s < e; s++) n.bitfield[s] = (t.bitfield[s] ^ i.bitfield[s]) & t.bitfield[s]; return n.updateCardinality(), n }, differenceRight: function(t, e, i) { return pc.KeywordSet.differenceLeft(e, t, i) }, difference: function(t, i, n) { void 0 === n ? n = new pc.KeywordSet : n.clear(); for (let s = 0; s < e; s++) n.bitfield[s] = t.bitfield[s] ^ i.bitfield[s]; return n.updateCardinality(), n } }), { KeywordSet: n, KeywordsCollection: i, Keywords: { LIGHTMAP_ON: i.getIdByName("LIGHTMAP_ON"), DIRLIGHTMAP_COMBINED: i.getIdByName("DIRLIGHTMAP_COMBINED"), POINT_COOKIE: i.getIdByName("POINT_COOKIE"), POINT: i.getIdByName("POINT"), SPOT: i.getIdByName("SPOT"), DIRECTIONAL_COOKIE: i.getIdByName("DIRECTIONAL_COOKIE"), DIRECTIONAL: i.getIdByName("DIRECTIONAL"), VERTEXLIGHT_ON: i.getIdByName("VERTEXLIGHT_ON"), LIGHTPROBE_SH: i.getIdByName("LIGHTPROBE_SH"), FOG_LINEAR: i.getIdByName("FOG_LINEAR"), FOG_EXP: i.getIdByName("FOG_EXP"), FOG_EXP2: i.getIdByName("FOG_EXP2") } }
    }()), pc.extend(pc, function() {
        const t = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            e = 1 / (4 * Math.PI),
            i = 1 / (2 * Math.PI),
            n = 15 / (16 * Math.PI),
            s = 5 / (64 * Math.PI),
            r = 15 / (64 * Math.PI),
            o = new pc.Color,
            a = new pc.Vec3,
            c = new Float64Array(t),
            h = function(e) { return this.data = new Float64Array(e || t), this };
        return h.fromArray = function(t) { const e = Object.create(h.prototype); return e.data = t, e }, pc.extend(h.prototype, {
            get: function(t, e) { return this.data[9 * t + e] },
            set: function(t, e, i) { this.data[9 * t + e] = i },
            copy: function(t) { for (let e = 0; e < this.data.length; e++) this.data[e] = t.data[e] },
            clear: function() { for (let t = 0; t < this.data.length; t++) this.data[t] = 0 },
            setFromInterpolation: function(t, e) { for (let i = 0; i < this.data.length; i++) { this.data[i] = 0; for (let n = 0; n < t.length; n++) this.data[i] += t[n].data[i] * e[n] } },
            addCubemap: function(e, i) {
                const n = e.width;
                let s = 0;
                const r = this.data;
                c.set(t), this.data = c;
                for (let t = 0; t < 6; t++) {
                    const r = e._levels[0][t];
                    for (let e = 0; e < n; e++)
                        for (let c = 0; c < n; c++) {
                            const h = e * n + c,
                                l = c / (n - 1) * 2 - 1,
                                u = e / (n - 1) * 2 - 1,
                                d = 1 + l * l + u * u,
                                p = 4 / (Math.sqrt(d) * d);
                            switch (a.set(l, -u, 1).normalize(), t) {
                                case 0:
                                    a.set(a.z, -a.y, -a.x);
                                    break;
                                case 1:
                                    a.set(-a.z, -a.y, a.x);
                                    break;
                                case 2:
                                    a.set(a.x, a.z, a.y);
                                    break;
                                case 3:
                                    a.set(a.x, -a.z, -a.y);
                                    break;
                                case 4:
                                    a.set(a.x, -a.y, a.z);
                                    break;
                                case 5:
                                    a.set(-a.x, -a.y, -a.z)
                            }
                            o.set(r[4 * h + 0] / 255, r[4 * h + 1] / 255, r[4 * h + 2] / 255, 1), this.addDirectionalLight(a, o, i, p / 2.956), s += p
                        }
                }
                for (let t = 0; t < this.data.length; t++) r[t] += 4 * c[t] * Math.PI / s;
                this.data = r
            },
            addAmbientLight: function(t) { o.copy(t).toLinear(), this.data[0] += o.r, this.data[9] += o.g, this.data[18] += o.b },
            addSkyGradient: function(t, e, i) { this.addAmbientLight(e), this.addDirectionalLight(pc.Vec3.UP, t, 1, 1), this.addDirectionalLight(pc.Vec3.DOWN, i, 1, 1) },
            addPointLight: function(t, e, i, n) {
                const s = t.length() / n;
                a.copy(t).normalize();
                const r = pc.math.clamp(1 / (1 + 25 * s * s) * pc.math.clamp(5 * (1 - s), 0, 1), 0, 1);
                this.addDirectionalLight(a, e, i, r)
            },
            addSpotLight: function(t, e, i, n, s) { this.addPointLight(t, e, i, n) },
            addDirectionalLight: function(t, e, i, n) { o.copy(e).scale(i).toLinear().scale(2.956 * n), this.addLightFromDirection(t, o) },
            addLightFromDirection: function(t, o) {
                const a = e,
                    c = i * t.y,
                    h = i * t.z,
                    l = i * t.x,
                    u = n * (t.x * t.y),
                    d = n * (t.y * t.z),
                    p = s * (3 * t.z * t.z - 1),
                    _ = n * (t.x * t.z),
                    f = r * (t.x * t.x - t.y * t.y);
                this.data[0] += o.r * a, this.data[1] += o.r * c, this.data[2] += o.r * h, this.data[3] += o.r * l, this.data[4] += o.r * u, this.data[5] += o.r * d, this.data[6] += o.r * p, this.data[7] += o.r * _, this.data[8] += o.r * f, this.data[9] += o.g * a, this.data[10] += o.g * c, this.data[11] += o.g * h, this.data[12] += o.g * l, this.data[13] += o.g * u, this.data[14] += o.g * d, this.data[15] += o.g * p, this.data[16] += o.g * _, this.data[17] += o.g * f, this.data[18] += o.b * a, this.data[19] += o.b * c, this.data[20] += o.b * h, this.data[21] += o.b * l, this.data[22] += o.b * u, this.data[23] += o.b * d, this.data[24] += o.b * p, this.data[25] += o.b * _, this.data[26] += o.b * f
            },
            updateUniforms: function() {
                this.uniforms || (this.uniforms = [new pc.Vec4, new pc.Vec4, new pc.Vec4, new pc.Vec4, new pc.Vec4, new pc.Vec4, new pc.Vec4]);
                for (let t = 0; t < 3; t++) this.uniforms[t].x = this.get(t, 3), this.uniforms[t].y = this.get(t, 1), this.uniforms[t].z = this.get(t, 2), this.uniforms[t].w = this.get(t, 0) - this.get(t, 6);
                for (let t = 0; t < 3; t++) this.uniforms[t + 3].x = this.get(t, 4), this.uniforms[t + 3].y = this.get(t, 5), this.uniforms[t + 3].z = 3 * this.get(t, 6), this.uniforms[t + 3].w = this.get(t, 7);
                this.uniforms[6].x = this.get(0, 8), this.uniforms[6].y = this.get(1, 8), this.uniforms[6].z = this.get(2, 8), this.uniforms[6].w = 1;
                for (let t = 0; t < 7; t++) this.uniforms[t].data
            },
            isEmpty: function() {
                for (let t = 0; t < this.data.length; t++)
                    if (Math.abs(this.data[t]) >= 1e-8) return !1;
                return !0
            }
        }), { SphericalHarmonicsL2: h }
    }()), Object.assign(pc, function() {
        const t = new pc.Vec3,
            e = new pc.Vec3,
            i = new pc.Vec3,
            n = new pc.Vec3,
            s = new pc.Vec3,
            r = function(t, e) { this.center = t || new pc.Vec3, this.halfExtents = e || new pc.Vec3, this._min = new pc.Vec3, this._max = new pc.Vec3 };
        return pc.extend(r, { ctor: r, $kind: "struct", equals: function(t, e) { return null === t && null === e || t && e && t.equals(e) } }), Object.assign(r.prototype, {
            add: function(t) {
                const e = this.center,
                    i = e.x,
                    n = e.y,
                    s = e.z,
                    r = this.halfExtents,
                    o = r.x,
                    a = r.y,
                    c = r.z;
                let h = i - o,
                    l = i + o,
                    u = n - a,
                    d = n + a,
                    p = s - c,
                    _ = s + c;
                const f = t.center,
                    m = f.x,
                    y = f.y,
                    g = f.z,
                    E = t.halfExtents,
                    A = E.x,
                    b = E.y,
                    C = E.z,
                    T = m - A,
                    S = m + A,
                    M = y - b,
                    x = y + b,
                    P = g - C,
                    O = g + C;
                T < h && (h = T), S > l && (l = S), M < u && (u = M), x > d && (d = x), P < p && (p = P), O > _ && (_ = O), e.x = .5 * (h + l), e.y = .5 * (u + d), e.z = .5 * (p + _), r.x = .5 * (l - h), r.y = .5 * (d - u), r.z = .5 * (_ - p)
            },
            copy: function(t) { this.center.copy(t.center), this.halfExtents.copy(t.halfExtents), this.type = t.type },
            clone: function() { return new pc.BoundingBox(this.center.clone(), this.halfExtents.clone()) },
            intersects: function(t) {
                const e = this.getMax(),
                    i = this.getMin(),
                    n = t.getMax(),
                    s = t.getMin();
                return i.x <= n.x && e.x >= s.x && i.y <= n.y && e.y >= s.y && i.z <= n.z && e.z >= s.z
            },
            _intersectsRay: function(s, r) {
                const o = t.copy(this.getMin()).sub(s.origin),
                    a = e.copy(this.getMax()).sub(s.origin),
                    c = s.direction;
                0 === c.x ? (o.x = o.x < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE, a.x = a.x < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE) : (o.x /= c.x, a.x /= c.x), 0 === c.y ? (o.y = o.y < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE, a.y = a.y < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE) : (o.y /= c.y, a.y /= c.y), 0 === c.z ? (o.z = o.z < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE, a.z = a.z < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE) : (o.z /= c.z, a.z /= c.z);
                const h = i.set(Math.min(o.x, a.x), Math.min(o.y, a.y), Math.min(o.z, a.z)),
                    l = n.set(Math.max(o.x, a.x), Math.max(o.y, a.y), Math.max(o.z, a.z)),
                    u = Math.min(Math.min(l.x, l.y), l.z),
                    d = Math.max(Math.max(h.x, h.y), h.z),
                    p = u >= d && d >= 0;
                return p && r.copy(s.direction).scale(d).add(s.origin), p
            },
            _fastIntersectsRay: function(r) {
                const o = t,
                    a = e,
                    c = i,
                    h = n,
                    l = s,
                    u = r.direction;
                return o.sub2(r.origin, this.center), h.set(Math.abs(o.x), Math.abs(o.y), Math.abs(o.z)), c.mul2(o, u), !(h.x > this.halfExtents.x && c.x >= 0) && (!(h.y > this.halfExtents.y && c.y >= 0) && (!(h.z > this.halfExtents.z && c.z >= 0) && (l.set(Math.abs(u.x), Math.abs(u.y), Math.abs(u.z)), a.cross(u, o), a.set(Math.abs(a.x), Math.abs(a.y), Math.abs(a.z)), !(a.x > this.halfExtents.y * l.z + this.halfExtents.z * l.y) && (!(a.y > this.halfExtents.x * l.z + this.halfExtents.z * l.x) && !(a.z > this.halfExtents.x * l.y + this.halfExtents.y * l.x)))))
            },
            intersectsRay: function(t, e) { return e ? this._intersectsRay(t, e) : this._fastIntersectsRay(t) },
            setToInfinity: function() { this.center.set(0, 0, 0), this.halfExtents.set(Number.MAX_SAFE_INTEGER / 2, Number.MAX_SAFE_INTEGER / 2, Number.MAX_SAFE_INTEGER / 2) },
            setMinMax: function(t, e) { this.center.add2(e, t).scale(.5), this.halfExtents.sub2(e, t).scale(.5) },
            getMin: function() { return this._min.copy(this.center).sub(this.halfExtents) },
            getMax: function() { return this._max.copy(this.center).add(this.halfExtents) },
            containsPoint: function(t) {
                const e = this.getMin(),
                    i = this.getMax();
                return !(t.x < e.x || t.x > i.x || t.y < e.y || t.y > i.y || t.z < e.z || t.z > i.z)
            },
            setFromTransformedAabb: function(t, e, i) {
                const n = this.center,
                    s = this.halfExtents,
                    r = t.center,
                    o = t.halfExtents,
                    a = (e = e.data)[0],
                    c = e[4],
                    h = e[8],
                    l = e[1],
                    u = e[5],
                    d = e[9],
                    p = e[2],
                    _ = e[6],
                    f = e[10],
                    m = Math.abs(a),
                    y = Math.abs(c),
                    g = Math.abs(h),
                    E = Math.abs(l),
                    A = Math.abs(u),
                    b = Math.abs(d),
                    C = Math.abs(p),
                    T = Math.abs(_),
                    S = Math.abs(f);
                if (n.set(e[12] + a * r.x + c * r.y + h * r.z, e[13] + l * r.x + u * r.y + d * r.z, e[14] + p * r.x + _ * r.y + f * r.z), s.set(m * o.x + y * o.y + g * o.z, E * o.x + A * o.y + b * o.z, C * o.x + T * o.y + S * o.z), i) {
                    const t = e[3],
                        i = e[7],
                        a = e[11],
                        c = e[15],
                        h = Math.abs(t),
                        l = Math.abs(i),
                        u = Math.abs(a),
                        d = Math.abs(c),
                        p = c + t * r.x + i * r.y + a * r.z,
                        _ = d + h * o.x + l * o.y + u * o.z;
                    n.scale(1 / p), s.scale(1 / _)
                }
            },
            compute: function(i, n) {
                if (0 === i.length) return void this.setToInfinity();
                n = n || 3;
                const s = t.set(i[0], i[1], i[2]),
                    r = e.set(i[0], i[1], i[2]),
                    o = i.length / n;
                for (let t = 1; t < o; t++) {
                    const e = i[t * n + 0],
                        o = i[t * n + 1],
                        a = i[t * n + 2];
                    e < s.x && (s.x = e), o < s.y && (s.y = o), a < s.z && (s.z = a), e > r.x && (r.x = e), o > r.y && (r.y = o), a > r.z && (r.z = a)
                }
                this.setMinMax(s, r)
            },
            expandToPoint: function(t) {
                const e = this.getMin(),
                    i = this.getMax();
                e.x = Math.min(e.x, t.x), e.y = Math.min(e.y, t.y), e.z = Math.min(e.z, t.z), i.x = Math.max(i.x, t.x), i.y = Math.max(i.y, t.y), i.z = Math.max(i.z, t.z), this.setMinMax(e, i)
            },
            expand: function(e) { this.halfExtents.add(t.copy(e).scale(.5)) },
            closestPoint: function(t) { const e = t.clone(); return e.sub(this.center), e.x = pc.math.clamp(e.x, -this.halfExtents.x, this.halfExtents.x), e.y = pc.math.clamp(e.y, -this.halfExtents.y, this.halfExtents.y), e.z = pc.math.clamp(e.z, -this.halfExtents.z, this.halfExtents.z), e.add(this.center), e },
            strictEquals: function(t) { return t instanceof pc.BoundingBox && this.equals(t) },
            equals: function(t) { return this.center.equals(t.center) && this.halfExtents.equals(t.halfExtents) },
            intersectRayDistance: function(t, e) { const i = new pc.Vec3; return !!this._intersectsRay(t, i) && (e.v = pc.Vec3.distance(t.origin, i), !0) },
            getHashCode: function() { return this.center.getHashCode() ^ this.halfExtents.getHashCode() << 2 }
        }), Object.defineProperty(r.prototype, "min", { get: function() { return this.getMin() }, set: function(t) { this.setMinMax(t, this.getMax()) } }), Object.defineProperty(r.prototype, "max", { get: function() { return this.getMax() }, set: function(t) { this.setMinMax(this.getMin(), t) } }), { BoundingBox: r }
    }()), Object.assign(pc, function() {
        const t = new pc.Mat4,
            e = function(t, e) {
                t = t || (new pc.Mat4).setPerspective(90, 16 / 9, .1, 1e3), e = e || new pc.Mat4, this.planes = [], this.unityPlanesOrthographic = [], this.unityPlanesPerspective = [];
                for (let t = 0; t < 6; t++) this.planes[t] = [];
                this.unityPlanesOrthographic[0] = this.planes[1], this.unityPlanesOrthographic[1] = this.planes[0], this.unityPlanesOrthographic[2] = this.planes[2], this.unityPlanesOrthographic[3] = this.planes[3], this.unityPlanesOrthographic[4] = this.planes[5], this.unityPlanesOrthographic[5] = this.planes[4], this.unityPlanesPerspective[0] = this.planes[1], this.unityPlanesPerspective[1] = this.planes[0], this.unityPlanesPerspective[2] = this.planes[3], this.unityPlanesPerspective[3] = this.planes[2], this.unityPlanesPerspective[4] = this.planes[5], this.unityPlanesPerspective[5] = this.planes[4], this.update(t, e)
            };
        return Object.assign(e.prototype, {
            update: function(e, i) {
                t.mul2(e, i);
                const n = t.data;
                this.planes[0][0] = n[3] - n[0], this.planes[0][1] = n[7] - n[4], this.planes[0][2] = n[11] - n[8], this.planes[0][3] = n[15] - n[12];
                let s = Math.sqrt(this.planes[0][0] * this.planes[0][0] + this.planes[0][1] * this.planes[0][1] + this.planes[0][2] * this.planes[0][2]);
                this.planes[0][0] /= s, this.planes[0][1] /= s, this.planes[0][2] /= s, this.planes[0][3] /= s, this.planes[1][0] = n[3] + n[0], this.planes[1][1] = n[7] + n[4], this.planes[1][2] = n[11] + n[8], this.planes[1][3] = n[15] + n[12], s = Math.sqrt(this.planes[1][0] * this.planes[1][0] + this.planes[1][1] * this.planes[1][1] + this.planes[1][2] * this.planes[1][2]), this.planes[1][0] /= s, this.planes[1][1] /= s, this.planes[1][2] /= s, this.planes[1][3] /= s, this.planes[2][0] = n[3] + n[1], this.planes[2][1] = n[7] + n[5], this.planes[2][2] = n[11] + n[9], this.planes[2][3] = n[15] + n[13], s = Math.sqrt(this.planes[2][0] * this.planes[2][0] + this.planes[2][1] * this.planes[2][1] + this.planes[2][2] * this.planes[2][2]), this.planes[2][0] /= s, this.planes[2][1] /= s, this.planes[2][2] /= s, this.planes[2][3] /= s, this.planes[3][0] = n[3] - n[1], this.planes[3][1] = n[7] - n[5], this.planes[3][2] = n[11] - n[9], this.planes[3][3] = n[15] - n[13], s = Math.sqrt(this.planes[3][0] * this.planes[3][0] + this.planes[3][1] * this.planes[3][1] + this.planes[3][2] * this.planes[3][2]), this.planes[3][0] /= s, this.planes[3][1] /= s, this.planes[3][2] /= s, this.planes[3][3] /= s, this.planes[4][0] = n[3] - n[2], this.planes[4][1] = n[7] - n[6], this.planes[4][2] = n[11] - n[10], this.planes[4][3] = n[15] - n[14], s = Math.sqrt(this.planes[4][0] * this.planes[4][0] + this.planes[4][1] * this.planes[4][1] + this.planes[4][2] * this.planes[4][2]), this.planes[4][0] /= s, this.planes[4][1] /= s, this.planes[4][2] /= s, this.planes[4][3] /= s, this.planes[5][0] = n[3] + n[2], this.planes[5][1] = n[7] + n[6], this.planes[5][2] = n[11] + n[10], this.planes[5][3] = n[15] + n[14], s = Math.sqrt(this.planes[5][0] * this.planes[5][0] + this.planes[5][1] * this.planes[5][1] + this.planes[5][2] * this.planes[5][2]), this.planes[5][0] /= s, this.planes[5][1] /= s, this.planes[5][2] /= s, this.planes[5][3] /= s
            },
            containsPoint: function(t) {
                for (let e = 0; e < 6; e++)
                    if (this.planes[e][0] * t.x + this.planes[e][1] * t.y + this.planes[e][2] * t.z + this.planes[e][3] <= 0) return !1;
                return !0
            },
            containsSphere: function(t, e) {
                let i, n, s = 0;
                const r = t.radius,
                    o = t.center,
                    a = o.x,
                    c = o.y,
                    h = o.z,
                    l = this.planes;
                let u;
                for (n = 0; n < 6; n++) {
                    if (u = l[n], i = 4 === n && e ? u[0] * a + u[1] * c + u[2] * h + e : u[0] * a + u[1] * c + u[2] * h + u[3], i <= -r) return 0;
                    i > r && s++
                }
                return 6 === s ? 2 : 1
            }
        }), { Frustum: e }
    }()),
    function() {
        const t = { ADDRESS_REPEAT: 0, ADDRESS_CLAMP_TO_EDGE: 1, ADDRESS_MIRRORED_REPEAT: 2, BLENDMODE_ZERO: 0, BLENDMODE_ONE: 1, BLENDMODE_SRC_COLOR: 2, BLENDMODE_ONE_MINUS_SRC_COLOR: 3, BLENDMODE_DST_COLOR: 4, BLENDMODE_ONE_MINUS_DST_COLOR: 5, BLENDMODE_SRC_ALPHA: 6, BLENDMODE_SRC_ALPHA_SATURATE: 7, BLENDMODE_ONE_MINUS_SRC_ALPHA: 8, BLENDMODE_DST_ALPHA: 9, BLENDMODE_ONE_MINUS_DST_ALPHA: 10, BLENDEQUATION_ADD: 0, BLENDEQUATION_SUBTRACT: 1, BLENDEQUATION_REVERSE_SUBTRACT: 2, BLENDEQUATION_MIN: 3, BLENDEQUATION_MAX: 4, BUFFER_STATIC: 0, BUFFER_DYNAMIC: 1, BUFFER_STREAM: 2, BUFFER_GPUDYNAMIC: 3, CLEARFLAG_COLOR: 1, CLEARFLAG_DEPTH: 2, CLEARFLAG_STENCIL: 4, CLEARFLAG_USE_SKYBOX: 8, CUBEFACE_POSX: 0, CUBEFACE_NEGX: 1, CUBEFACE_POSY: 2, CUBEFACE_NEGY: 3, CUBEFACE_POSZ: 4, CUBEFACE_NEGZ: 5, CULLFACE_NONE: 0, CULLFACE_BACK: 1, CULLFACE_FRONT: 2, CULLFACE_FRONTANDBACK: 3, TYPE_INT8: 0, TYPE_UINT8: 1, TYPE_INT16: 2, TYPE_UINT16: 3, TYPE_INT32: 4, TYPE_UINT32: 5, TYPE_FLOAT32: 6, FILTER_NEAREST: 0, FILTER_LINEAR: 1, FILTER_NEAREST_MIPMAP_NEAREST: 2, FILTER_NEAREST_MIPMAP_LINEAR: 3, FILTER_LINEAR_MIPMAP_NEAREST: 4, FILTER_LINEAR_MIPMAP_LINEAR: 5, FUNC_NEVER: 0, FUNC_LESS: 1, FUNC_EQUAL: 2, FUNC_LESSEQUAL: 3, FUNC_GREATER: 4, FUNC_NOTEQUAL: 5, FUNC_GREATEREQUAL: 6, FUNC_ALWAYS: 7, INDEXFORMAT_UINT8: 0, INDEXFORMAT_UINT16: 1, INDEXFORMAT_UINT32: 2, PIXELFORMAT_A8: 0, PIXELFORMAT_L8: 1, PIXELFORMAT_L8_A8: 2, PIXELFORMAT_R5_G6_B5: 3, PIXELFORMAT_R5_G5_B5_A1: 4, PIXELFORMAT_R4_G4_B4_A4: 5, PIXELFORMAT_R8_G8_B8: 6, PIXELFORMAT_R8_G8_B8_A8: 7, PIXELFORMAT_DXT1: 8, PIXELFORMAT_DXT3: 9, PIXELFORMAT_DXT5: 10, PIXELFORMAT_RGB16F: 11, PIXELFORMAT_RGBA16F: 12, PIXELFORMAT_RGB32F: 13, PIXELFORMAT_RGBA32F: 14, PIXELFORMAT_R32F: 15, PIXELFORMAT_DEPTH: 16, PIXELFORMAT_DEPTHSTENCIL: 17, PIXELFORMAT_111110F: 18, PIXELFORMAT_SRGB: 19, PIXELFORMAT_SRGBA: 20, PIXELFORMAT_ETC1: 21, PIXELFORMAT_ETC2_RGB: 22, PIXELFORMAT_ETC2_RGBA: 23, PIXELFORMAT_PVRTC_2BPP_RGB_1: 24, PIXELFORMAT_PVRTC_2BPP_RGBA_1: 25, PIXELFORMAT_PVRTC_4BPP_RGB_1: 26, PIXELFORMAT_PVRTC_4BPP_RGBA_1: 27, PRIMITIVE_POINTS: 0, PRIMITIVE_LINES: 1, PRIMITIVE_LINELOOP: 2, PRIMITIVE_LINESTRIP: 3, PRIMITIVE_TRIANGLES: 4, PRIMITIVE_TRISTRIP: 5, PRIMITIVE_TRIFAN: 6, SEMANTIC_POSITION: "POSITION", SEMANTIC_NORMAL: "NORMAL", SEMANTIC_TANGENT: "TANGENT", SEMANTIC_BLENDWEIGHT: "BLENDWEIGHT", SEMANTIC_BLENDINDICES: "BLENDINDICES", SEMANTIC_COLOR: "COLOR", SEMANTIC_TEXCOORD0: "TEXCOORD0", SEMANTIC_TEXCOORD1: "TEXCOORD1", SEMANTIC_TEXCOORD2: "TEXCOORD2", SEMANTIC_TEXCOORD3: "TEXCOORD3", SEMANTIC_TEXCOORD4: "TEXCOORD4", SEMANTIC_TEXCOORD5: "TEXCOORD5", SEMANTIC_TEXCOORD6: "TEXCOORD6", SEMANTIC_TEXCOORD7: "TEXCOORD7", SEMANTIC_ATTR0: "ATTR0", SEMANTIC_ATTR1: "ATTR1", SEMANTIC_ATTR2: "ATTR2", SEMANTIC_ATTR3: "ATTR3", SEMANTIC_ATTR4: "ATTR4", SEMANTIC_ATTR5: "ATTR5", SEMANTIC_ATTR6: "ATTR6", SEMANTIC_ATTR7: "ATTR7", SEMANTIC_ATTR8: "ATTR8", SEMANTIC_ATTR9: "ATTR9", SEMANTIC_ATTR10: "ATTR10", SEMANTIC_ATTR11: "ATTR11", SEMANTIC_ATTR12: "ATTR12", SEMANTIC_ATTR13: "ATTR13", SEMANTIC_ATTR14: "ATTR14", SEMANTIC_ATTR15: "ATTR15", SHADERTAG_MATERIAL: 1, STENCILOP_KEEP: 0, STENCILOP_ZERO: 1, STENCILOP_REPLACE: 2, STENCILOP_INCREMENT: 3, STENCILOP_INCREMENTWRAP: 4, STENCILOP_DECREMENT: 5, STENCILOP_DECREMENTWRAP: 6, STENCILOP_INVERT: 7, TEXTURELOCK_READ: 1, TEXTURELOCK_WRITE: 2, TEXHINT_NONE: 0, TEXHINT_SHADOWMAP: 1, TEXHINT_ASSET: 2, TEXHINT_LIGHTMAP: 3, UNIFORMTYPE_BOOL: 0, UNIFORMTYPE_INT: 1, UNIFORMTYPE_FLOAT: 2, UNIFORMTYPE_VEC2: 3, UNIFORMTYPE_VEC3: 4, UNIFORMTYPE_VEC4: 5, UNIFORMTYPE_IVEC2: 6, UNIFORMTYPE_IVEC3: 7, UNIFORMTYPE_IVEC4: 8, UNIFORMTYPE_BVEC2: 9, UNIFORMTYPE_BVEC3: 10, UNIFORMTYPE_BVEC4: 11, UNIFORMTYPE_MAT2: 12, UNIFORMTYPE_MAT3: 13, UNIFORMTYPE_MAT4: 14, UNIFORMTYPE_TEXTURE2D: 15, UNIFORMTYPE_TEXTURECUBE: 16, UNIFORMTYPE_FLOATARRAY: 17, UNIFORMTYPE_TEXTURE2D_SHADOW: 18, UNIFORMTYPE_TEXTURECUBE_SHADOW: 19, UNIFORMTYPE_TEXTURE3D: 20 };
        Object.assign(pc, t), pc.gfx = {}, Object.assign(pc.gfx, t);
        const e = { x: 0, y: 0, width: 1, height: 1 },
            i = new pc.KeywordSet,
            n = new pc.Mat4;
        let s = null,
            r = null
    }(), Object.assign(pc, function() {
        const t = function(t) { this.name = t, this.value = null, this.previous_value = null, this.versionObject = new pc.VersionedObject };
        return Object.assign(t.prototype, {
            setValue: function(t) { this.value = t, this.previous_value = null, this.versionObject.increment() },
            pushValue: function(t) {
                if (this.previous_value) throw new Error("pushValue is limited to storing 1 previous value");
                const e = this.value;
                this.setValue(t), this.previous_value = e
            },
            popValue: function() { this.setValue(this.previous_value) },
            getValue: function(t) { return this.value }
        }), { ScopeId: t }
    }()), Object.assign(pc, function() { const t = function(t) { this.name = t, this.variables = {} }; return Object.assign(t.prototype, { resolve: function(t) { return this.variables.hasOwnProperty(t) || (this.variables[t] = new pc.ScopeId(t)), this.variables[t] } }), { ScopeSpace: t } }()), Object.assign(pc, function() { const t = function() { this.globalId = 0, this.revision = 0 }; return Object.assign(t.prototype, { equals: function(t) { return this.globalId === t.globalId && this.revision === t.revision }, notequals: function(t) { return this.globalId !== t.globalId || this.revision !== t.revision }, copy: function(t) { this.globalId = t.globalId, this.revision = t.revision }, reset: function() { this.globalId = 0, this.revision = 0 } }), { Version: t } }()), Object.assign(pc, function() { let t = 0; const e = function() { t++, this.version = new pc.Version, this.version.globalId = t }; return Object.assign(e.prototype, { increment: function() { this.version.revision++ } }), { VersionedObject: e } }()), Object.assign(pc, function() {
        function t(t) { this.array[this.index] = t }

        function e(t, e) { this.array[this.index] = t, this.array[this.index + 1] = e }

        function i(t, e, i) { this.array[this.index] = t, this.array[this.index + 1] = e, this.array[this.index + 2] = i }

        function n(t, e, i, n) { this.array[this.index] = t, this.array[this.index + 1] = e, this.array[this.index + 2] = i, this.array[this.index + 3] = n }

        function s(s, r) {
            switch (this.index = 0, r.dataType) {
                case pc.TYPE_INT8:
                    this.array = new Int8Array(s, r.offset);
                    break;
                case pc.TYPE_UINT8:
                    this.array = new Uint8Array(s, r.offset);
                    break;
                case pc.TYPE_INT16:
                    this.array = new Int16Array(s, r.offset);
                    break;
                case pc.TYPE_UINT16:
                    this.array = new Uint16Array(s, r.offset);
                    break;
                case pc.TYPE_INT32:
                    this.array = new Int32Array(s, r.offset);
                    break;
                case pc.TYPE_UINT32:
                    this.array = new Uint32Array(s, r.offset);
                    break;
                case pc.TYPE_FLOAT32:
                    this.array = new Float32Array(s, r.offset)
            }
            switch (r.numComponents) {
                case 1:
                    this.set = t;
                    break;
                case 2:
                    this.set = e;
                    break;
                case 3:
                    this.set = i;
                    break;
                case 4:
                    this.set = n
            }
        }

        function r(t) {
            this.vertexBuffer = t, this.buffer = this.vertexBuffer.lock(), this.accessors = [], this.element = {};
            const e = this.vertexBuffer.getFormat();
            for (let t = 0; t < e.elements.length; t++) {
                const i = e.elements[t];
                this.accessors[t] = new s(this.buffer, i), this.element[i.name] = this.accessors[t]
            }
        }
        return s.prototype.get = function(t) { return this.array[this.index + t] }, Object.assign(r.prototype, {
            next: function(t) {
                void 0 === t && (t = 1);
                let e = 0;
                const i = this.accessors,
                    n = this.accessors.length,
                    s = this.vertexBuffer.getFormat();
                for (; e < n;) {
                    const n = i[e++];
                    n.index += t * s.size / n.array.constructor.BYTES_PER_ELEMENT
                }
            },
            end: function() { this.vertexBuffer.unlock() },
            setVector4: function(t, e) { this.element[t].set(e[0], e[1], e[2] || 0, e[3] || 1) },
            setVector3: function(t, e) { this.element[t].set(e[0], e[1], e[2]) },
            setVector2: function(t, e) { this.element[t].set(e[0], e[1]) }
        }), { VertexIterator: r }
    }()), Object.assign(pc, function() {
        const t = [];
        t[pc.TYPE_INT8] = 1, t[pc.TYPE_UINT8] = 1, t[pc.TYPE_INT16] = 2, t[pc.TYPE_UINT16] = 2, t[pc.TYPE_INT32] = 4, t[pc.TYPE_UINT32] = 4, t[pc.TYPE_FLOAT32] = 4;
        const e = function(e, i) {
            let n, s, r;
            for (this.elements = [], this.hasUv0 = !1, this.hasUv1 = !1, this.hasColor = !1, this.hasTangents = !1, this.elementMap = {}, this.size = 0, n = 0, s = i.length; n < s; n++) {
                const s = i[n];
                r = { name: s.semantic, offset: 0, stride: 0, stream: -1, scopeId: e.scope.resolve(s.semantic), dataType: s.type, numComponents: s.components, normalize: void 0 !== s.normalize && s.normalize, size: s.components * t[s.type] }, this.elements.push(r), this.size += 4 * Math.ceil(r.size / 4), s.semantic === pc.SEMANTIC_TEXCOORD0 ? this.hasUv0 = !0 : s.semantic === pc.SEMANTIC_TEXCOORD1 ? this.hasUv1 = !0 : s.semantic === pc.SEMANTIC_COLOR ? this.hasColor = !0 : s.semantic === pc.SEMANTIC_TANGENT && (this.hasTangents = !0)
            }
            let o = 0;
            for (n = 0, s = this.elements.length; n < s; n++) r = this.elements[n], r.offset = o, r.stride = this.size, o += r.size, this.elementMap[r.name] = r
        };
        return pc.extend(e.prototype, {
            getStructureFor: function(t, e) {
                let i = -1;
                const n = e ? 4 : 1;
                for (let e = 0; e < this.elements.length; e++)
                    if (this.elements[e].name === t) { i = this.elements[e].offset; break }
                return { offset: i / n, stride: this.size / n }
            }
        }), { VertexFormat: e }
    }()), Object.assign(pc, function() {
        const t = function(t, e, i, n, s) { this.usage = n || pc.BUFFER_STATIC, this.format = e, this.numVertices = i, this.numBytes = e.size * i, t._vram.vb += this.numBytes, this.device = t, s ? this.setData(s) : this.storage = new ArrayBuffer(this.numBytes) };
        return Object.defineProperty(t.prototype, "storage", { set: function(t) { this._storage = t }, get: function() { return this._storage } }), Object.assign(t.prototype, {
            destroy: function() { this.bufferId && (this.device._vram.vb -= this.numBytes), this.invalidateBuffer() },
            getFormat: function() { return this.format },
            getUsage: function() { return this.usage },
            getNumVertices: function() { return this.numVertices },
            lock: function() { return this.storage },
            unlock: function() {
                const t = this.device.gl;
                let e;
                switch (this.bufferId || (this.bufferId = t.createBuffer()), this.usage) {
                    case pc.BUFFER_STATIC:
                        e = t.STATIC_DRAW;
                        break;
                    case pc.BUFFER_DYNAMIC:
                        e = t.DYNAMIC_DRAW;
                        break;
                    case pc.BUFFER_STREAM:
                        e = t.STREAM_DRAW;
                        break;
                    case pc.BUFFER_GPUDYNAMIC:
                        e = this.device.webgl2 ? t.DYNAMIC_COPY : t.STATIC_DRAW
                }
                t.bindBuffer(t.ARRAY_BUFFER, this.bufferId), t.bufferData(t.ARRAY_BUFFER, this.storage, e)
            },
            setData: function(t) { return t.byteLength !== this.numBytes ? (console.error("VertexBuffer: wrong initial data size: expected " + this.numBytes + ", got " + t.byteLength), !1) : (this.storage = t, this.unlock(), !0) },
            resize: function(t) {
                const e = t * this.format.size;
                if (e !== this.numBytes) {
                    this.device._vram.vb += e - this.numBytes, this.numBytes = e, this.numVertices = t;
                    const i = this.storage;
                    this.storage = new ArrayBuffer(this.numBytes), new Uint8Array(this.storage).set(new Uint8Array(i.slice(0, this.numBytes))), this.invalidateBuffer()
                }
            },
            invalidateBuffer: function() {
                const t = this.device;
                if (this.bufferId) {
                    const e = t.gl;
                    e.deleteBuffer(this.bufferId), this.bufferId = null, t.boundBuffer = null, t.vertexBuffers.length = 0, t.vbOffsets.length = 0, t.attributesInvalidated = !0;
                    for (const i in t.enabledAttributes) e.disableVertexAttribArray(i);
                    t.enabledAttributes = {}
                }
            }
        }), { VertexBuffer: t }
    }()), Object.assign(pc, function() {
        const t = function(t, e, i, n, s) {
            this.usage = n || pc.BUFFER_STATIC, this.format = e, this.numIndices = i, this.device = t;
            const r = this.device.gl;
            let o;
            e === pc.INDEXFORMAT_UINT8 ? (o = 1, this.glFormat = r.UNSIGNED_BYTE) : e === pc.INDEXFORMAT_UINT16 ? (o = 2, this.glFormat = r.UNSIGNED_SHORT) : e === pc.INDEXFORMAT_UINT32 && (o = 4, this.glFormat = r.UNSIGNED_INT), this.bytesPerIndex = o, this.numBytes = this.numIndices * o, s ? this.setData(s) : this.storage = new ArrayBuffer(this.numBytes), t._vram.ib += this.numBytes
        };
        return Object.assign(t.prototype, {
            destroy: function() { this.bufferId && (this.device._vram.ib -= this.numBytes), this.invalidateBuffer() },
            getFormat: function() { return this.format },
            getNumIndices: function() { return this.numIndices },
            lock: function() { return this.storage },
            unlock: function() {
                const t = this.device.gl;
                let e;
                switch (this.bufferId || (this.bufferId = t.createBuffer()), this.usage) {
                    case pc.BUFFER_STATIC:
                        e = t.STATIC_DRAW;
                        break;
                    case pc.BUFFER_DYNAMIC:
                        e = t.DYNAMIC_DRAW;
                        break;
                    case pc.BUFFER_STREAM:
                        e = t.STREAM_DRAW;
                        break;
                    case pc.BUFFER_GPUDYNAMIC:
                        e = this.device.webgl2 ? t.DYNAMIC_COPY : t.STATIC_DRAW
                }
                t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.bufferId), t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.storage, e)
            },
            setData: function(t) { return t.byteLength !== this.numBytes ? (console.error("IndexBuffer: wrong initial data size: expected " + this.numBytes + ", got " + t.byteLength), !1) : (this.storage = t, this.unlock(), !0) },
            resize: function(t) {
                const e = t * this.bytesPerIndex;
                if (e !== this.numBytes) {
                    this.numBytes = e, this.numIndices = t;
                    const i = this.storage;
                    this.storage = new ArrayBuffer(this.numBytes), new Uint8Array(this.storage).set(new Uint8Array(i.slice(0, this.numBytes))), this.invalidateBuffer()
                }
            },
            invalidateBuffer: function() { const t = this.device; if (this.bufferId) { t.gl.deleteBuffer(this.bufferId), this.bufferId = null, t.indexBuffer === this && (t.indexBuffer = null) } }
        }), { IndexBuffer: t }
    }()), Object.assign(pc, function() {
        const t = function(t, e) {
            if (this.device = t, this.name = null, this._width = 4, this._height = 4, this._depth = 1, this._pot = !0, this._format = pc.PIXELFORMAT_R8_G8_B8_A8, this.rgbm = !1, this.intensity = 1, this._cubemap = !1, this._volume = !1, this.fixCubemapSeams = !1, this._flipY = !0, this._premultiplyAlpha = !1, this._mipmaps = !0, this._minFilter = pc.FILTER_LINEAR_MIPMAP_LINEAR, this._magFilter = pc.FILTER_LINEAR, this._anisotropy = 1, this._addressU = pc.ADDRESS_CLAMP_TO_EDGE, this._addressV = pc.ADDRESS_CLAMP_TO_EDGE, this._addressW = pc.ADDRESS_CLAMP_TO_EDGE, this._compareOnRead = !1, this._compareFunc = pc.FUNC_LESS, this._atlas = null, this._rects = null, this._buffer = null, void 0 !== e && (this.name = e.name, this._width = void 0 !== e.width ? e.width : this._width, this._height = void 0 !== e.height ? e.height : this._height, this._pot = pc.math.powerOfTwo(this._width) && pc.math.powerOfTwo(this._height), this._format = void 0 !== e.format ? e.format : this._format, this.rgbm = void 0 !== e.rgbm ? e.rgbm : this.rgbm, void 0 !== e.mipmaps ? this._mipmaps = e.mipmaps : this._mipmaps = void 0 !== e.autoMipmap ? e.autoMipmap : this._mipmaps, this._levels = e.levels, this._atlas = e.atlas, this._rects = e.rects, this._cubemap = void 0 !== e.cubemap ? e.cubemap : this._cubemap, this.fixCubemapSeams = void 0 !== e.fixCubemapSeams ? e.fixCubemapSeams : this.fixCubemapSeams, this._minFilter = void 0 !== e.minFilter ? e.minFilter : this._minFilter, this._magFilter = void 0 !== e.magFilter ? e.magFilter : this._magFilter, this._anisotropy = void 0 !== e.anisotropy ? e.anisotropy : this._anisotropy, this._addressU = void 0 !== e.addressU ? e.addressU : this._addressU, this._addressV = void 0 !== e.addressV ? e.addressV : this._addressV, this._compareOnRead = void 0 !== e.compareOnRead ? e.compareOnRead : this._compareOnRead, this._compareFunc = void 0 !== e._compareFunc ? e._compareFunc : this._compareFunc, this._flipY = void 0 !== e.flipY ? e.flipY : this._flipY, this._premultiplyAlpha = void 0 !== e.premultiplyAlpha ? e.premultiplyAlpha : this._premultiplyAlpha, t.webgl2 && (this._depth = void 0 !== e.depth ? e.depth : this._depth, this._volume = void 0 !== e.volume ? e.volume : this._volume, this._addressW = void 0 !== e.addressW ? e.addressW : this._addressW)), this._compressed = this._format === pc.PIXELFORMAT_DXT1 || this._format === pc.PIXELFORMAT_DXT3 || this._format === pc.PIXELFORMAT_DXT5 || this._format >= pc.PIXELFORMAT_ETC1, this._invalid = !1, this._lockedLevel = -1, !this._levels)
                if (this._cubemap) this._levels = [
                    [null, null, null, null, null, null]
                ];
                else {
                    const t = this.createBuffer(this._format, this._width, this._height);
                    this._levels = [t]
                }
            this.dirtyAll(), this._gpuSize = 0
        };
        Object.defineProperty(t.prototype, "minFilter", { get: function() { return this._minFilter }, set: function(t) { this._minFilter !== t && (this._minFilter = t, this._parameterFlags |= 1) } }), Object.defineProperty(t.prototype, "magFilter", { get: function() { return this._magFilter }, set: function(t) { this._magFilter !== t && (this._magFilter = t, this._parameterFlags |= 2) } }), Object.defineProperty(t.prototype, "addressU", { get: function() { return this._addressU }, set: function(t) { this._addressU !== t && (this._addressU = t, this._parameterFlags |= 4) } }), Object.defineProperty(t.prototype, "addressV", { get: function() { return this._addressV }, set: function(t) { this._addressV !== t && (this._addressV = t, this._parameterFlags |= 8) } }), Object.defineProperty(t.prototype, "addressW", { get: function() { return this._addressW }, set: function(t) { this.device.webgl2 && (this._volume ? t !== this._addressW && (this._addressW = t, this._parameterFlags |= 16) : console.warn("pc.Texture#addressW: Can't set W addressing mode for a non-3D texture.")) } }), Object.defineProperty(t.prototype, "compareOnRead", { get: function() { return this._compareOnRead }, set: function(t) { this._compareOnRead !== t && (this._compareOnRead = t, this._parameterFlags |= 32) } }), Object.defineProperty(t.prototype, "compareFunc", { get: function() { return this._compareFunc }, set: function(t) { this._compareFunc !== t && (this._compareFunc = t, this._parameterFlags |= 64) } }), Object.defineProperty(t.prototype, "anisotropy", { get: function() { return this._anisotropy }, set: function(t) { this._anisotropy !== t && (this._anisotropy = t, this._parameterFlags |= 128) } }), Object.defineProperty(t.prototype, "autoMipmap", { get: function() { return this._mipmaps }, set: function(t) { this._mipmaps = t } }), Object.defineProperty(t.prototype, "mipmaps", { get: function() { return this._mipmaps }, set: function(t) { this._mipmaps !== t && (this._mipmaps = t, this._minFilterDirty = !0, t && (this._needsMipmapsUpload = !0)) } }), Object.defineProperty(t.prototype, "width", { get: function() { return this._width } }), Object.defineProperty(t.prototype, "height", { get: function() { return this._height } }), Object.defineProperty(t.prototype, "depth", { get: function() { return this._depth } }), Object.defineProperty(t.prototype, "format", { get: function() { return this._format } }), Object.defineProperty(t.prototype, "cubemap", { get: function() { return this._cubemap } });
        let e = null;
        return Object.defineProperty(t.prototype, "gpuSize", {
            get: function() {
                e || (e = [], e[pc.PIXELFORMAT_A8] = 1, e[pc.PIXELFORMAT_L8] = 1, e[pc.PIXELFORMAT_L8_A8] = 1, e[pc.PIXELFORMAT_R5_G6_B5] = 2, e[pc.PIXELFORMAT_R5_G5_B5_A1] = 2, e[pc.PIXELFORMAT_R4_G4_B4_A4] = 2, e[pc.PIXELFORMAT_R8_G8_B8] = 4, e[pc.PIXELFORMAT_R8_G8_B8_A8] = 4, e[pc.PIXELFORMAT_RGB16F] = 8, e[pc.PIXELFORMAT_RGBA16F] = 8, e[pc.PIXELFORMAT_RGB32F] = 16, e[pc.PIXELFORMAT_RGBA32F] = 16, e[pc.PIXELFORMAT_R32F] = 4, e[pc.PIXELFORMAT_DEPTH] = 4, e[pc.PIXELFORMAT_DEPTHSTENCIL] = 4, e[pc.PIXELFORMAT_111110F] = 4, e[pc.PIXELFORMAT_SRGB] = 4, e[pc.PIXELFORMAT_SRGBA] = 4);
                let t = 1;
                !this._pot || !this._mipmaps && this._minFilter !== pc.FILTER_NEAREST_MIPMAP_NEAREST && this._minFilter !== pc.FILTER_NEAREST_MIPMAP_LINEAR && this._minFilter !== pc.FILTER_LINEAR_MIPMAP_NEAREST && this._minFilter !== pc.FILTER_LINEAR_MIPMAP_LINEAR || this._compressed && 1 === this._levels.length || (t = Math.round(Math.log2(Math.max(this._width, this._height)) + 1));
                let i = this._width,
                    n = this._height,
                    s = this._depth,
                    r = 0;
                for (let o = 0; o < t; o++) {
                    if (this._compressed)
                        if (this._format === pc.PIXELFORMAT_ETC1) r += Math.floor((i + 3) / 4) * Math.floor((n + 3) / 4) * 8 * s;
                        else if (this._format === pc.PIXELFORMAT_PVRTC_2BPP_RGB_1 || this._format === pc.PIXELFORMAT_PVRTC_2BPP_RGBA_1) r += Math.max(i, 16) * Math.max(n, 8) / (4 * s);
                    else if (this._format === pc.PIXELFORMAT_PVRTC_4BPP_RGB_1 || this._format === pc.PIXELFORMAT_PVRTC_4BPP_RGBA_1) r += Math.max(i, 8) * Math.max(n, 8) / (2 * s);
                    else {
                        const t = 4,
                            e = 4,
                            o = this._format === pc.PIXELFORMAT_DXT1 ? 8 : 16;
                        r += Math.floor((i + t - 1) / t) * Math.floor((n + e - 1) / e) * o * s
                    } else r += i * n * s * e[this._format];
                    i = Math.max(.5 * i, 1), n = Math.max(.5 * n, 1), s = Math.max(.5 * s, 1)
                }
                return this._cubemap && (r *= 6), r
            }
        }), Object.defineProperty(t.prototype, "volume", { get: function() { return this._volume } }), Object.defineProperty(t.prototype, "flipY", { get: function() { return this._flipY }, set: function(t) { this._flipY !== t && (this._flipY = t, this._needsUpload = !0) } }), Object.defineProperty(t.prototype, "premultiplyAlpha", { get: function() { return this._premultiplyAlpha }, set: function(t) { this._premultiplyAlpha !== t && (this._premultiplyAlpha = t, this._needsUpload = !0) } }), Object.assign(t.prototype, {
            destroy: function() { this.device && this.device.destroyTexture(this), this.device = null, this._levels = null },
            dirtyAll: function() {
                this._levelsUpdated = this._cubemap ? [
                    [!0, !0, !0, !0, !0, !0]
                ] : [!0], this._needsUpload = !0, this._needsMipmapsUpload = this._mipmaps, this._mipmapsUploaded = !1, this._parameterFlags = 255
            },
            lock: function(t) {
                if (void 0 === (t = t || { level: 0, face: 0, mode: pc.TEXTURELOCK_WRITE }).level && (t.level = 0), void 0 === t.face && (t.face = 0), void 0 === t.mode && (t.mode = pc.TEXTURELOCK_WRITE), this._lockedLevel = t.level, null === this._levels[t.level]) switch (this._format) {
                    case pc.PIXELFORMAT_A8:
                    case pc.PIXELFORMAT_L8:
                        this._levels[t.level] = new Uint8Array(this._width * this._height * this._depth);
                        break;
                    case pc.PIXELFORMAT_L8_A8:
                        this._levels[t.level] = new Uint8Array(this._width * this._height * this._depth * 2);
                        break;
                    case pc.PIXELFORMAT_R5_G6_B5:
                    case pc.PIXELFORMAT_R5_G5_B5_A1:
                    case pc.PIXELFORMAT_R4_G4_B4_A4:
                        this._levels[t.level] = new Uint16Array(this._width * this._height * this._depth);
                        break;
                    case pc.PIXELFORMAT_R8_G8_B8:
                        this._levels[t.level] = new Uint8Array(this._width * this._height * this._depth * 3);
                        break;
                    case pc.PIXELFORMAT_R8_G8_B8_A8:
                        this._levels[t.level] = new Uint8Array(this._width * this._height * this._depth * 4);
                        break;
                    case pc.PIXELFORMAT_DXT1:
                        this._levels[t.level] = new Uint8Array(Math.floor((this._width + 3) / 4) * Math.floor((this._height + 3) / 4) * 8 * this._depth);
                        break;
                    case pc.PIXELFORMAT_DXT3:
                    case pc.PIXELFORMAT_DXT5:
                        this._levels[t.level] = new Uint8Array(Math.floor((this._width + 3) / 4) * Math.floor((this._height + 3) / 4) * 16 * this._depth);
                        break;
                    case pc.PIXELFORMAT_RGB16F:
                        this._levels[t.level] = new Uint16Array(this._width * this._height * this._depth * 3);
                        break;
                    case pc.PIXELFORMAT_RGB32F:
                        this._levels[t.level] = new Float32Array(this._width * this._height * this._depth * 3);
                        break;
                    case pc.PIXELFORMAT_RGBA16F:
                        this._levels[t.level] = new Uint16Array(this._width * this._height * this._depth * 4);
                        break;
                    case pc.PIXELFORMAT_RGBA32F:
                        this._levels[t.level] = new Float32Array(this._width * this._height * this._depth * 4)
                }
                return this._levels[t.level]
            },
            setSource: function(t) {
                let e, i, n, s = !1;
                if (this._cubemap) {
                    if (t[0]) {
                        for (i = t[0].width || 0, n = t[0].height || 0, e = 0; e < 6; e++)
                            if (!(t[e] && t[e].width === i && t[e].height === n && (t[e] instanceof HTMLImageElement || t[e] instanceof HTMLCanvasElement || t[e] instanceof HTMLVideoElement))) { s = !0; break }
                    } else s = !0;
                    if (!s)
                        for (e = 0; e < 6; e++) this._levels[0][e] !== t[e] && (this._levelsUpdated[0][e] = !0)
                } else t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof HTMLVideoElement || (s = !0), s || (t !== this._levels[0] && (this._levelsUpdated[0] = !0), i = t.width, n = t.height);
                if (s)
                    if (this._width = 4, this._height = 4, this._pot = !0, this._cubemap)
                        for (e = 0; e < 6; e++) this._levels[0][e] = null, this._levelsUpdated[0][e] = !0;
                    else this._levels[0] = null, this._levelsUpdated[0] = !0;
                else this._width = i, this._height = n, this._pot = pc.math.powerOfTwo(this._width) && pc.math.powerOfTwo(this._height), this._levels[0] = t;
                this._invalid === s && s || (this._invalid = s, this.upload())
            },
            getSource: function() { return this._levels[0] },
            unlock: function() {-1 === this._lockedLevel && console.log("pc.Texture#unlock: Attempting to unlock a texture that is not locked."), this.upload(), this._lockedLevel = -1 },
            upload: function() { this._needsUpload = !0, this._needsMipmapsUpload = this._mipmaps },
            clone: function() {
                const t = { name: this.name, width: this._width, height: this._height, addressU: this._addressU, addressV: this._addressV, mipmaps: this._mipmaps, minFilter: this._minFilter, magFilter: this._magFilter, autoMipmap: this._mipmaps, rgbm: this.rgbm, anisotropy: this._anisotropy, format: this._format },
                    e = new pc.Texture(this.device, t);
                return e.setSource(this._levels[0]), e
            },
            createBuffer: function(t, e, i) {
                switch (t) {
                    case pc.PIXELFORMAT_R8_G8_B8:
                        return new Uint8Array(3 * e * i);
                    case pc.PIXELFORMAT_R8_G8_B8_A8:
                        return new Uint8Array(4 * e * i)
                }
                return null
            },
            toBuffer: function() {
                const t = this.device.gl;
                this._glTexture || (this.device.setTexture(this, 0), this.device.uploadTexture(this));
                const e = this._glTexture,
                    i = this.width,
                    n = this.height;
                (this._needsUpload || this._needsMipmapsUpload) && this.device.uploadTexture(this);
                const s = t.createFramebuffer();
                t.bindFramebuffer(t.FRAMEBUFFER, s), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, e, 0);
                const r = new Uint8Array(i * n * 4);
                return t.readPixels(0, 0, i, n, t.RGBA, t.UNSIGNED_BYTE, r), t.deleteFramebuffer(s), r
            },
            sync: function(t) {
                const e = this.device.gl,
                    i = this._glTexture,
                    n = this.width / (1 << t),
                    s = this.height / (1 << t),
                    r = this.device.activeFramebuffer,
                    o = e.createFramebuffer();
                if (this.device.setFramebuffer(o), this._cubemap) { this._levels = this._levels || [], this._levels[t] = this._levels[t] || []; for (let r = 0; r < 6; r++) e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_CUBE_MAP_POSITIVE_X + r, i, t), this._levels[t][r] = new Uint8Array(n * s * 4), e.readPixels(0, 0, n, s, e.RGBA, e.UNSIGNED_BYTE, this._levels[t][r]) } else e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, i, t), this._levels = this._levels || [], this._levels[t] = new Uint8Array(n * s * 4), e.readPixels(0, 0, n, s, e.RGBA, e.UNSIGNED_BYTE, this._levels[t]);
                this.device.setFramebuffer(r)
            },
            markUploaded: function() { this._needsUpdate || (this._needsUpload = !1) },
            setPixels: function(t) {
                null === this._buffer && (this._buffer = this.createBuffer(this._format, this._width, this._height));
                for (let e = 0; e < t.length; e++) {
                    const i = 4 * e;
                    this._buffer[i + 0] = 255 * t[e].r, this._buffer[i + 1] = 255 * t[e].g, this._buffer[i + 2] = 255 * t[e].b, this._buffer[i + 3] = 255 * t[e].a
                }
                this._levels[0] = this._buffer, this._needsUpload = !0
            },
            setPixelData: function(t) { this.device.setTexture(this, 0), this._levels = [t], this._needsUpload = !0, this.device.uploadTexture(this) },
            toDataURI: function() {
                const t = this.width,
                    e = this.height,
                    i = this.toBuffer(),
                    n = document.createElement("canvas");
                n.width = t, n.height = e;
                const s = n.getContext("2d", { alpha: !0 }),
                    r = s.createImageData(t, e);
                return r.data.set(i), s.putImageData(r, 0, 0), s.scale(1, -1), s.translate(0, -r.height), s.drawImage(s.canvas, 0, 0), n.toDataURL()
            },
            copyCubemap: function(t) { t._glTexture || this.device.uploadTexture(t), this._glTexture = t._glTexture, this._glTarget = t._glTarget, this._glInternalFormat = t._glInternalFormat, this._glFormat = t._glFormat, this._glPixelType = t._glPixelType, this._parameterFlags = t._parameterFlags, this.rgbm = t.rgbm, this._width = t._width, this._height = t._height, this._needsUpload = !1, this._needsMipmapsUpload = !1 }
        }), { Texture: t }
    }()), Object.assign(pc, function() {
        const t = { depth: !0, face: 0 },
            e = function(e, i, n) {
                if (e instanceof pc.GraphicsDevice ? (this._colorBuffer = i, e = n) : this._colorBuffer = e.colorBuffer, this._glFrameBuffer = null, this._glDepthBuffer = null, e = void 0 !== e ? e : t, this._depthBuffer = e.depthBuffer, this._face = void 0 !== e.face ? e.face : 0, this._depthBuffer) {
                    const t = this._depthBuffer._format;
                    t === pc.PIXELFORMAT_DEPTH ? (this._depth = !0, this._stencil = !1) : t === pc.PIXELFORMAT_DEPTHSTENCIL ? (this._depth = !0, this._stencil = !0) : (console.warn("Incorrect depthBuffer format. Must be pc.PIXELFORMAT_DEPTH or pc.PIXELFORMAT_DEPTHSTENCIL"), this._depth = !1, this._stencil = !1)
                } else this._depth = void 0 === e.depth || e.depth, this._stencil = void 0 !== e.stencil && e.stencil;
                this._samples = void 0 !== e.samples ? e.samples : 1, this.autoResolve = void 0 === e.autoResolve || e.autoResolve, this._glResolveFrameBuffer = null, this._glMsaaColorBuffer = null, this._glMsaaDepthBuffer = null
            };
        return Object.assign(e.prototype, {
            destroy: function() {
                if (!this._device) return;
                const t = this._device,
                    e = t.targets.indexOf(this); - 1 !== e && t.targets.splice(e, 1);
                const i = t.gl;
                this._glFrameBuffer && (i.deleteFramebuffer(this._glFrameBuffer), this._glFrameBuffer = null), this._glDepthBuffer && (i.deleteRenderbuffer(this._glDepthBuffer), this._glDepthBuffer = null), this._glResolveFrameBuffer && (i.deleteFramebuffer(this._glResolveFrameBuffer), this._glResolveFrameBuffer = null), this._glMsaaColorBuffer && (i.deleteRenderbuffer(this._glMsaaColorBuffer), this._glMsaaColorBuffer = null), this._glMsaaDepthBuffer && (i.deleteRenderbuffer(this._glMsaaDepthBuffer), this._glMsaaDepthBuffer = null)
            },
            resolve: function(t, e) {
                if (!this._device) return;
                if (!this._device.webgl2) return;
                const i = this._device.gl;
                void 0 === t && (t = !0), void 0 === e && this._depthBuffer && (e = !0), i.bindFramebuffer(i.READ_FRAMEBUFFER, this._glFrameBuffer), i.bindFramebuffer(i.DRAW_FRAMEBUFFER, this._glResolveFrameBuffer), i.blitFramebuffer(0, 0, this.width, this.height, 0, 0, this.width, this.height, (t ? i.COLOR_BUFFER_BIT : 0) | (e ? i.DEPTH_BUFFER_BIT : 0), i.NEAREST), i.bindFramebuffer(i.FRAMEBUFFER, this._glFrameBuffer)
            }
        }), Object.defineProperty(e.prototype, "colorBuffer", { get: function() { return this._colorBuffer } }), Object.defineProperty(e.prototype, "depthBuffer", { get: function() { return this._depthBuffer } }), Object.defineProperty(e.prototype, "face", { get: function() { return this._face } }), Object.defineProperty(e.prototype, "width", { get: function() { return this._colorBuffer ? this._colorBuffer.width : this._depthBuffer.width } }), Object.defineProperty(e.prototype, "height", { get: function() { return this._colorBuffer ? this._colorBuffer.height : this._depthBuffer.height } }), { RenderTarget: e }
    }()), Object.assign(pc, { ShaderInput: function(t, e, i, n) { this.locationId = n, this.scopeId = t.scope.resolve(e), this.version = new pc.Version, i === pc.UNIFORMTYPE_FLOAT && "[0]" === e.substr(e.length - 3) && (i = pc.UNIFORMTYPE_FLOATARRAY), this.dataType = i, this.dataType === pc.UNIFORMTYPE_VEC2 ? this.value = [null, null] : this.dataType === pc.UNIFORMTYPE_VEC3 ? this.value = [null, null, null] : this.value = [null, null, null, null], this.array = [] } }), Object.assign(pc, function() {
        const t = "FORWARDBASE",
            e = "FORWARDADD",
            i = "SHADOWCASTER",
            n = "Vertex",
            s = "VertexLM",
            r = "Background",
            o = "GRABPASS",
            a = ["ALWAYS", t, e, i, o, n, s],
            c = [r, "Opaque", "Transparent"],
            h = ["zTest", "zWrite", "culling", "blending", "alphaBlending", "colorWriteMask", "offsetUnits", "offsetFactor", "stencilRef", "stencilReadMask", "stencilWriteMask", "stencilOp", "stencilOpFront", "stencilOpBack"],
            l = { vertex_position: pc.SEMANTIC_POSITION, vertex_normal: pc.SEMANTIC_NORMAL, vertex_tangent: pc.SEMANTIC_TANGENT, vertex_texCoord0: pc.SEMANTIC_TEXCOORD0, vertex_texCoord1: pc.SEMANTIC_TEXCOORD1, vertex_color: pc.SEMANTIC_COLOR, vertex_boneWeights: pc.SEMANTIC_BLENDWEIGHT, vertex_boneIndices: pc.SEMANTIC_BLENDINDICES, instancing_translation: pc.SEMANTIC_TEXCOORD5, instancing_rotation: pc.SEMANTIC_TEXCOORD6, instancing_scale: pc.SEMANTIC_TEXCOORD7, instancing_color: pc.SEMANTIC_ATTR0, instancing_st: pc.SEMANTIC_ATTR1, _glesVertex: pc.SEMANTIC_POSITION, _glesNormal: pc.SEMANTIC_NORMAL, _glesTangent: pc.SEMANTIC_TANGENT, _glesMultiTexCoord0: pc.SEMANTIC_TEXCOORD0, _glesMultiTexCoord1: pc.SEMANTIC_TEXCOORD1, _glesMultiTexCoord2: pc.SEMANTIC_TEXCOORD2, _glesMultiTexCoord3: pc.SEMANTIC_TEXCOORD3, _glesColor: pc.SEMANTIC_COLOR, _glesTANGENT: pc.SEMANTIC_TANGENT, in_POSITION0: pc.SEMANTIC_POSITION, in_NORMAL0: pc.SEMANTIC_NORMAL, in_TANGENT0: pc.SEMANTIC_TANGENT, in_TEXCOORD0: pc.SEMANTIC_TEXCOORD0, in_TEXCOORD1: pc.SEMANTIC_TEXCOORD1, in_TEXCOORD2: pc.SEMANTIC_TEXCOORD2, in_TEXCOORD3: pc.SEMANTIC_TEXCOORD3, in_COLOR0: pc.SEMANTIC_COLOR, _patched_POSITION: pc.SEMANTIC_POSITION, _patched_COLOR: pc.SEMANTIC_COLOR, _patched_NORMAL: pc.SEMANTIC_NORMAL, _patched_TANGENT: pc.SEMANTIC_TANGENT, _patched_TEXCOORD0: pc.SEMANTIC_TEXCOORD0 },
            u = new pc.KeywordSet,
            d = function(t, e) { this.device = t, this.definition = e, this.attributes = [], this.uniforms = [], this.samplers = [], this._keywords = [], this._supportsKeywords = !1, this._globalKeywordsVersion = 0, this.ready = !1, this._refCount = 0, this.device.createShader(this) };
        Object.assign(d.prototype, { destroy: function() { this.device.destroyShader(this) } });
        const p = function(t, e, i, n, s) { this.graphicsDevice = t, this.keywords = new pc.KeywordSet, this.shader = null, this._particlesShader = null, this._skinnedShader = null, this._sourceShader = s, this.setupKeywords(e), this.setupShader(i, n) };
        pc.extend(p.prototype, {
            getShader: function(t) { let e; return e = t & pc.SHADERDEF_PARTICLES_INSTANCING ? this.getParticlesShader() : t & pc.SHADERDEF_SKIN ? this.getSkinnedShader() : this.shader, e },
            applyMissingShader: function(t) {
                let e;
                e = t & pc.SHADERDEF_PARTICLES_INSTANCING ? "_particlesShader" : t & pc.SHADERDEF_SKIN ? "_skinnedShader" : "shader";
                const i = pc._createMissingShader(this._sourceShader.name, this._sourceShader.$id);
                return this[e] = i, i
            },
            getParticlesShader: function() { return null === this._particlesShader && (this._particlesShader = new pc.Shader(this.graphicsDevice, { attributes: l, vshader: pc.ShaderPatches.patchParticlesVertexShader(this.shader.definition.vshader, l), fshader: this.shader.definition.fshader })), this._particlesShader },
            getSkinnedShader: function() { return null === this._skinnedShader && (this._skinnedShader = new pc.Shader(this.graphicsDevice, { attributes: l, vshader: pc.ShaderPatches.patchSkinningVertexShader(this.shader.definition.vshader, l), fshader: this.shader.definition.fshader })), this._skinnedShader },
            setupKeywords: function(t) { this.keywords.setEnabledKeywords(t) },
            setupShader: function(t, e) { 2 === UnityEngine.LightmapSettings.lightmapEncodingQuality && (e = pc.ShaderPatches.patchTexture2DLightmap(e)), this.shader = new pc.Shader(this.graphicsDevice, { attributes: l, vshader: t, fshader: e }) }
        });
        const _ = function() { this.lightMode = 0, this.renderType = 1, this.grabPassTextureName = null, this.graphicsDevice = null, this.shaders = [], this.boundParameters = [], this.sourceShader = null, this.passType = null, this.zTest = null, this.zWrite = null, this.culling = null, this.blending = null, this.alphaBlending = null, this.colorWriteMask = null, this.offsetUnits = null, this.offsetFactor = null, this.stencilRef = null, this.stencilReadMask = null, this.stencilWriteMask = null, this.stencilOp = null, this.stencilOpFrontstencilOpBack = null, this.tags = null, this.variants = null };
        pc.extend(_.prototype, {
            setupTags: function() { for (let a = 0; a < this.tags.length; a++) { const c = this.tags[a]; "LIGHTMODE" === c.name && (c.value === t && (this.lightMode = 1), c.value === e && (this.lightMode = 2), c.value === i && (this.lightMode = 3), c.value === n && (this.lightMode = 5), c.value === s && (this.lightMode = 6)), c.name === o && (this.lightMode = 4), "GRABPASS_TEXTURE_NAME" === c.name && (this.grabPassTextureName = c.value), "RENDERTYPE" === c.name && c.value === r && (this.renderType = 0) } },
            getVariant: function(t) {
                let e = null;
                for (let i = 0; i < this.variants.length; i++) {
                    const n = this.variants[i];
                    pc.KeywordSet.intersection(t, n.keywords, u), u.cardinality === n.keywords.cardinality && (null === e || e.keywords.cardinality < u.cardinality) && (e = n)
                }
                return e
            },
            setupVariants: function() {
                const t = new Array(this.variants.length);
                for (let e = 0; e < this.variants.length; e++) {
                    const i = this.variants[e],
                        n = ShaderProgramsLibrary[i.vertexProgram],
                        s = ShaderProgramsLibrary[i.fragmentProgram];
                    t[e] = new p(this.graphicsDevice, i.keywords, n, s, this.sourceShader)
                }
                this.variants = t
            },
            updateRenderState: function(t) {
                for (let e = 0; e < this.boundParameters.length; e++) {
                    const i = t.parameters[this.boundParameters[e].name];
                    i && i.data ? this.boundParameters[e].val = i.data : this.boundParameters[e].val = 0
                }
            },
            setupRenderSettings: function() { for (let t = 0; t < h.length; t++) this._collectBoundParameters(this[h[t]], this.boundParameters) },
            _collectBoundParameters: function(t, e) {
                if (t)
                    if ("Luna.Unity.DTO.UnityEngine.Assets.Shader.Pass+Value" === t.$$fullname && t.name) e.push(t);
                    else
                        for (const i in t) {
                            if (!t.hasOwnProperty(i)) continue;
                            const n = t[i];
                            n && n.$$fullname && this._collectBoundParameters(n, e)
                        }
            },
            applyMissingVariant: function(t) {
                const e = pc.Application.getApplication().graphicsDevice,
                    i = pc._createMissingShader(this.sourceShader.name, this.sourceShader.$id),
                    n = new p(e, t, i.definition.vshader, i.definition.fshader, this.sourceShader);
                return n.shader = i, this.variants.push(n), n
            }
        });
        const f = function(t) {
            this.graphicsDevice = t, this.name = null, this.passes = [], this.defaultParameterValues = [], this.defaultParameters = {}, this.lightModes = [
                [],
                [],
                [],
                [],
                [],
                [],
                []
            ], this.supportedKeywords = new pc.KeywordSet
        };
        f.globalKeywords = new pc.KeywordSet, f.globalUniforms = {};
        const m = function() { this.value = null, this.scopeId = null };
        return f.setGlobalUniform = function(t, e) { this.globalUniforms[t] = this.globalUniforms[t] || new m, this.globalUniforms[t].value = e }, f.enableKeyword = function(t) { this.globalKeywords.enableKeyword(t) }, f.disableKeyword = function(t) { this.globalKeywords.disableKeyword(t) }, f.getEnabledKeywords = function() { return this.globalKeywords.getEnabledKeywords() }, pc.extend(f.prototype, {
            setup: function() { this.setupPasses(), this.setupDefaultParameters() },
            setupPasses: function() {
                for (let t = 0; t < this.passes.length; t++) {
                    const e = this.passes[t];
                    e.graphicsDevice = this.graphicsDevice, e.sourceShader = this, e.setupTags(), e.setupVariants(), e.setupRenderSettings(), this.lightModes[e.lightMode].push(e);
                    for (let t = 0; t < e.variants.length; t++) {
                        const i = e.variants[t];
                        this.supportedKeywords.merge(i.keywords)
                    }
                }
            },
            setupDefaultParameters: function() {
                this.defaultParameterNames = {};
                for (let t = 0; t < this.defaultParameterValues.length; t++) {
                    const e = this.defaultParameterValues[t];
                    switch (this.defaultParameterNames[e.name] = !0, e.type) {
                        case Luna.Unity.DTO.UnityEngine.Assets.Shader.ShaderParameterType.Vector:
                        case Luna.Unity.DTO.UnityEngine.Assets.Shader.ShaderParameterType.Color:
                            this.defaultParameters[e.name] = e.value.data;
                            break;
                        case Luna.Unity.DTO.UnityEngine.Assets.Shader.ShaderParameterType.Scalar:
                            this.defaultParameters[e.name] = e.value.x;
                            break;
                        case Luna.Unity.DTO.UnityEngine.Assets.Shader.ShaderParameterType.Texture:
                            { const t = UnityEngine.Texture2D[e.textureValue + "Texture"];this.defaultParameters[e.name] = t ? t.handle : null; break }
                    }
                }
            },
            supportsKeyword: function(t) { return this.supportedKeywords.isKeywordEnabled(t) }
        }), { Shader: d, UnityShader: f, UnityShaderPass: _, LIGHT_MODE_NAMES: a, SHADER_PASS_ALWAYS: 0, SHADER_PASS_FORWARD_BASE: 1, SHADER_PASS_FORWARD_ADD: 2, SHADER_PASS_SHADOW_CASTER: 3, SHADER_PASS_GRAB_PASS: 4, SHADER_PASS_VERTEX: 5, SHADER_PASS_VERTEX_LM: 6, RENDER_TYPE_BACKGROUND: 0, RENDER_TYPE_OPAQUE: 1, RENDER_TYPE_TRANSPARENT: 2, RENDER_TYPE_NAMES: c }
    }()), Object.assign(pc, function() {
        const t = function(t) { this._device = t, this._cache = {}, this._generators = {}, this._isClearingCache = !1 };
        return t.prototype.register = function(t, e) { this._generators[t] = e }, t.prototype.clearCache = function() {
            const t = this._cache;
            this._isClearingCache = !0;
            for (const e in t) t.hasOwnProperty(e) && t[e].destroy();
            this._cache = {}, this._isClearingCache = !1
        }, t.prototype.removeFromCache = function(t) {
            if (this._isClearingCache) return;
            const e = this._cache;
            for (const i in e)
                if (e.hasOwnProperty(i) && e[i] === t) { delete e[i]; break }
        }, { ProgramLibrary: t }
    }()), Object.assign(pc, function() {
        const t = "resizecanvas",
            e = new Float32Array([1, 1, 1, 1]),
            i = new Float32Array([0, 0, 0, 0]),
            n = new Float32Array([0, 0, 0, 1]),
            s = new Float32Array([1, 0, 0, 1]),
            r = new Float32Array([0, 0, 1, 1]),
            o = {};
        o[pc.SEMANTIC_POSITION] = 0, o[pc.SEMANTIC_NORMAL] = 1, o[pc.SEMANTIC_TANGENT] = 2, o[pc.SEMANTIC_BLENDWEIGHT] = 3, o[pc.SEMANTIC_BLENDINDICES] = 4, o[pc.SEMANTIC_COLOR] = 5, o[pc.SEMANTIC_TEXCOORD0] = 6, o[pc.SEMANTIC_TEXCOORD1] = 7, o[pc.SEMANTIC_TEXCOORD2] = 8, o[pc.SEMANTIC_TEXCOORD3] = 9, o[pc.SEMANTIC_TEXCOORD4] = 10, o[pc.SEMANTIC_TEXCOORD5] = 11, o[pc.SEMANTIC_TEXCOORD6] = 12, o[pc.SEMANTIC_TEXCOORD7] = 13, o[pc.SEMANTIC_ATTR0] = 14, o[pc.SEMANTIC_ATTR1] = 15, o[pc.SEMANTIC_ATTR2] = 16, o[pc.SEMANTIC_ATTR3] = 17, o[pc.SEMANTIC_ATTR4] = 18, o[pc.SEMANTIC_ATTR5] = 19, o[pc.SEMANTIC_ATTR6] = 20, o[pc.SEMANTIC_ATTR7] = 21, o[pc.SEMANTIC_ATTR8] = 22, o[pc.SEMANTIC_ATTR9] = 23, o[pc.SEMANTIC_ATTR10] = 24, o[pc.SEMANTIC_ATTR11] = 25, o[pc.SEMANTIC_ATTR12] = 26, o[pc.SEMANTIC_ATTR13] = 27, o[pc.SEMANTIC_ATTR14] = 28, o[pc.SEMANTIC_ATTR15] = 29, pc.UNIFORMS_USAGE_MAP = {}, pc.UNIFORMS_USAGE_MAP["unity_CameraWorldClipPlanes[0]"] = 1, pc.UNIFORMS_USAGE_MAP.unity_MatrixMVP = 2, pc.UNIFORMS_USAGE_MAP.unity_MatrixMV = 4, pc.UNIFORMS_USAGE_MAP.unity_MatrixVP = 8, pc.UNIFORMS_USAGE_MAP.unity_MatrixV = 16, pc.UNIFORMS_USAGE_MAP.unity_MatrixInvV = 32, pc.UNIFORMS_USAGE_MAP.glstate_matrix_projection = 64, pc.UNIFORMS_USAGE_MAP.unity_MatrixTMV = 128, pc.UNIFORMS_USAGE_MAP.unity_MatrixITMV = 256, pc.UNIFORMS_USAGE_MAP.unity_ObjectToWorld = 512, pc.UNIFORMS_USAGE_MAP.unity_WorldToObject = 1024, pc.UNIFORMS_USAGE_MAP.unity_CameraProjection = 2048, pc.UNIFORMS_USAGE_MAP.unity_CameraInvProjection = 4096, pc.UNIFORMS_USAGE_MAP["hlslcc_mtx4x4unity_MatrixMVP[0]"] = 2, pc.UNIFORMS_USAGE_MAP["hlslcc_mtx4x4unity_MatrixMV[0]"] = 4, pc.UNIFORMS_USAGE_MAP["hlslcc_mtx4x4unity_MatrixVP[0]"] = 8, pc.UNIFORMS_USAGE_MAP["hlslcc_mtx4x4unity_MatrixV[0]"] = 16, pc.UNIFORMS_USAGE_MAP["hlslcc_mtx4x4unity_MatrixInvV[0]"] = 32, pc.UNIFORMS_USAGE_MAP["hlslcc_mtx4x4glstate_matrix_projection[0]"] = 64, pc.UNIFORMS_USAGE_MAP["hlslcc_mtx4x4unity_MatrixTMV[0]"] = 128, pc.UNIFORMS_USAGE_MAP["hlslcc_mtx4x4unity_MatrixITMV[0]"] = 256, pc.UNIFORMS_USAGE_MAP["hlslcc_mtx4x4unity_ObjectToWorld[0]"] = 512, pc.UNIFORMS_USAGE_MAP["hlslcc_mtx4x4unity_WorldToObject[0]"] = 1024, pc.UNIFORMS_USAGE_MAP["hlslcc_mtx4x4unity_CameraProjection[0]"] = 2048, pc.UNIFORMS_USAGE_MAP["hlslcc_mtx4x4unity_CameraInvProjection[0]"] = 4096;
        const a = {};
        a[pc.UNIFORMTYPE_BOOL] = 0, a[pc.UNIFORMTYPE_INT] = 0, a[pc.UNIFORMTYPE_FLOAT] = 0, a[pc.UNIFORMTYPE_VEC2] = new Float32Array([0, 0]), a[pc.UNIFORMTYPE_VEC3] = new Float32Array([0, 0, 0]), a[pc.UNIFORMTYPE_VEC4] = new Float32Array([0, 0, 0, 0]), a[pc.UNIFORMTYPE_IVEC2] = new Int32Array([0, 0]), a[pc.UNIFORMTYPE_IVEC3] = new Int32Array([0, 0, 0]), a[pc.UNIFORMTYPE_IVEC4] = new Int32Array([0, 0, 0, 0]), a[pc.UNIFORMTYPE_BVEC2] = 0, a[pc.UNIFORMTYPE_BVEC3] = 0, a[pc.UNIFORMTYPE_BVEC4] = 0, a[pc.UNIFORMTYPE_MAT2] = new Float32Array([0, 0, 0, 0]), a[pc.UNIFORMTYPE_MAT3] = new Float32Array([0, 0, 0, 0, 0, 0, 0, 0, 0]), a[pc.UNIFORMTYPE_MAT4] = new Float32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), a[pc.UNIFORMTYPE_TEXTURE2D] = null, a[pc.UNIFORMTYPE_TEXTURECUBE] = null, a[pc.UNIFORMTYPE_FLOATARRAY] = new Float32Array([0, 0, 0, 0]), a[pc.UNIFORMTYPE_TEXTURE2D_SHADOW] = null, a[pc.UNIFORMTYPE_TEXTURECUBE_SHADOW] = null;
        const c = function(t, e) {
            const i = t.width,
                n = t.height;
            if (i > e || n > e) {
                const s = e / Math.max(i, n),
                    r = Math.floor(i * s),
                    o = Math.floor(n * s);
                console.warn("Image dimensions larger than max supported texture size of " + e + ". Resizing from " + i + ", " + n + " to " + r + ", " + o + ".");
                const a = document.createElement("canvas");
                a.width = r, a.height = o;
                return a.getContext("2d").drawImage(t, 0, 0, i, n, 0, 0, r, o), a
            }
            return t
        };

        function h(t, e) {
            let i = !0;
            const n = t.createTexture();
            t.bindTexture(t.TEXTURE_2D, n), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, 2, 2, 0, t.RGBA, e, null);
            const s = t.createFramebuffer();
            return t.bindFramebuffer(t.FRAMEBUFFER, s), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, n, 0), t.checkFramebufferStatus(t.FRAMEBUFFER) !== t.FRAMEBUFFER_COMPLETE && (i = !1), t.bindTexture(t.TEXTURE_2D, null), t.deleteTexture(n), t.bindFramebuffer(t.FRAMEBUFFER, null), t.deleteFramebuffer(s), i
        }
        const l = function(t, e) {
            this.canvas = t, this.shader = null, this.indexBuffer = null, this.vertexBuffers = [], this.vbOffsets = [], this._enableAutoInstancing = !1, this.autoInstancingMaxObjects = 16384, this.attributesInvalidated = !0, this.boundBuffer = null, this.boundElementBuffer = null, this.instancedAttribs = {}, this.enabledAttributes = {}, this.attributePointers = {}, this.transformFeedbackBuffer = null, this.activeFramebuffer = null, this.textureUnit = 0, this.textureUnits = [], this._maxPixelRatio = 2, this.renderTarget = null, this.feedback = null, this._width = 0, this._height = 0, this.updateClientRect(), this.vertexShaderCache = {}, this.fragmentShaderCache = {}, this.shaders = [], this.buffers = [], this.textures = [], this.targets = [], this.contextLost = !1, this._contextLostHandler = function(t) { t.preventDefault(), this.contextLost = !0, DEBUG && console.log("pc.GraphicsDevice: WebGL context lost.") }.bind(this), this._contextRestoredHandler = function() { DEBUG && console.log("pc.GraphicsDevice: WebGL context restored."), this.initializeContext(), this.contextLost = !1 }.bind(this), t.addEventListener("webglcontextlost", this._contextLostHandler, !1), t.addEventListener("webglcontextrestored", this._contextRestoredHandler, !1);
            const i = !(!e || void 0 === e.preferWebGl2) && e.preferWebGl2,
                n = i ? ["webgl2", "experimental-webgl2", "webgl", "experimental-webgl"] : ["webgl", "experimental-webgl"];
            let s, r, o, a, c, l = null;
            (e = e || {}).stencil = !0, e.antialias = !e.disableAntiAliasing && window.devicePixelRatio < 2, e.alpha = !1;
            for (let s = 0; s < n.length; s++) { try { l = t.getContext(n[s], e) } catch (t) {} if (l) { this.webgl2 = i && s < 2; break } }
            if (!l) throw new Error("WebGL not supported");
            l.blendColor(0, 0, 0, 0), this.gl = l, this.initializeExtensions(), this.initializeCapabilities(), this.initializeRenderState();
            for (let t = 0; t < this.maxCombinedTextures; t++) this.textureUnits.push([null, null, null]);
            this.defaultClearOptions = { color: [0, 0, 0, 1], depth: 1, stencil: 0, flags: pc.CLEARFLAG_COLOR | pc.CLEARFLAG_DEPTH }, this.glAddress = [l.REPEAT, l.CLAMP_TO_EDGE, l.MIRRORED_REPEAT], this.glBlendEquation = [l.FUNC_ADD, l.FUNC_SUBTRACT, l.FUNC_REVERSE_SUBTRACT, this.webgl2 ? l.MIN : this.extBlendMinmax ? this.extBlendMinmax.MIN_EXT : l.FUNC_ADD, this.webgl2 ? l.MAX : this.extBlendMinmax ? this.extBlendMinmax.MAX_EXT : l.FUNC_ADD], this.glBlendFunction = [l.ZERO, l.ONE, l.SRC_COLOR, l.ONE_MINUS_SRC_COLOR, l.DST_COLOR, l.ONE_MINUS_DST_COLOR, l.SRC_ALPHA, l.SRC_ALPHA_SATURATE, l.ONE_MINUS_SRC_ALPHA, l.DST_ALPHA, l.ONE_MINUS_DST_ALPHA], this.glComparison = [l.NEVER, l.LESS, l.EQUAL, l.LEQUAL, l.GREATER, l.NOTEQUAL, l.GEQUAL, l.ALWAYS], this.glStencilOp = [l.KEEP, l.ZERO, l.REPLACE, l.INCR, l.INCR_WRAP, l.DECR, l.DECR_WRAP, l.INVERT], this.glClearFlag = [0, l.COLOR_BUFFER_BIT, l.DEPTH_BUFFER_BIT, l.COLOR_BUFFER_BIT | l.DEPTH_BUFFER_BIT, l.STENCIL_BUFFER_BIT, l.STENCIL_BUFFER_BIT | l.COLOR_BUFFER_BIT, l.STENCIL_BUFFER_BIT | l.DEPTH_BUFFER_BIT, l.STENCIL_BUFFER_BIT | l.COLOR_BUFFER_BIT | l.DEPTH_BUFFER_BIT], this.glCull = [0, l.BACK, l.FRONT, l.FRONT_AND_BACK], this.glFilter = [l.NEAREST, l.LINEAR, l.NEAREST_MIPMAP_NEAREST, l.NEAREST_MIPMAP_LINEAR, l.LINEAR_MIPMAP_NEAREST, l.LINEAR_MIPMAP_LINEAR], this.glPrimitive = [l.POINTS, l.LINES, l.LINE_LOOP, l.LINE_STRIP, l.TRIANGLES, l.TRIANGLE_STRIP, l.TRIANGLE_FAN], this.glType = [l.BYTE, l.UNSIGNED_BYTE, l.SHORT, l.UNSIGNED_SHORT, l.INT, l.UNSIGNED_INT, l.FLOAT], this.pcUniformType = {}, this.pcUniformType[l.BOOL] = pc.UNIFORMTYPE_BOOL, this.pcUniformType[l.INT] = pc.UNIFORMTYPE_INT, this.pcUniformType[l.FLOAT] = pc.UNIFORMTYPE_FLOAT, this.pcUniformType[l.FLOAT_VEC2] = pc.UNIFORMTYPE_VEC2, this.pcUniformType[l.FLOAT_VEC3] = pc.UNIFORMTYPE_VEC3, this.pcUniformType[l.FLOAT_VEC4] = pc.UNIFORMTYPE_VEC4, this.pcUniformType[l.INT_VEC2] = pc.UNIFORMTYPE_IVEC2, this.pcUniformType[l.INT_VEC3] = pc.UNIFORMTYPE_IVEC3, this.pcUniformType[l.INT_VEC4] = pc.UNIFORMTYPE_IVEC4, this.pcUniformType[l.BOOL_VEC2] = pc.UNIFORMTYPE_BVEC2, this.pcUniformType[l.BOOL_VEC3] = pc.UNIFORMTYPE_BVEC3, this.pcUniformType[l.BOOL_VEC4] = pc.UNIFORMTYPE_BVEC4, this.pcUniformType[l.FLOAT_MAT2] = pc.UNIFORMTYPE_MAT2, this.pcUniformType[l.FLOAT_MAT3] = pc.UNIFORMTYPE_MAT3, this.pcUniformType[l.FLOAT_MAT4] = pc.UNIFORMTYPE_MAT4, this.pcUniformType[l.SAMPLER_2D] = pc.UNIFORMTYPE_TEXTURE2D, this.pcUniformType[l.SAMPLER_CUBE] = pc.UNIFORMTYPE_TEXTURECUBE, this.webgl2 && (this.pcUniformType[l.SAMPLER_2D_SHADOW] = pc.UNIFORMTYPE_TEXTURE2D_SHADOW, this.pcUniformType[l.SAMPLER_CUBE_SHADOW] = pc.UNIFORMTYPE_TEXTURECUBE_SHADOW, this.pcUniformType[l.SAMPLER_3D] = pc.UNIFORMTYPE_TEXTURE3D), this.targetToSlot = {}, this.targetToSlot[l.TEXTURE_2D] = 0, this.targetToSlot[l.TEXTURE_CUBE_MAP] = 1, this.targetToSlot[l.TEXTURE_3D] = 2, this.commitFunction = [], this.commitFunction[pc.UNIFORMTYPE_BOOL] = function(t, e) { t.value !== e && (l.uniform1i(t.locationId, e), t.value = e) }, this.commitFunction[pc.UNIFORMTYPE_INT] = this.commitFunction[pc.UNIFORMTYPE_BOOL], this.commitFunction[pc.UNIFORMTYPE_FLOAT] = function(t, e) { t.value !== e && (l.uniform1f(t.locationId, e), t.value = e) }, this.commitFunction[pc.UNIFORMTYPE_VEC2] = function(t, e) { c = t.value, s = e[0], r = e[1], c[0] === s && c[1] === r || (c[0] = s, c[1] = r, l.uniform2fv(t.locationId, c)) }, this.commitFunction[pc.UNIFORMTYPE_VEC3] = function(t, e) { c = t.value, s = e[0], r = e[1], o = e[2], c[0] === s && c[1] === r && c[2] === o || (c[0] = s, c[1] = r, c[2] = o, l.uniform3fv(t.locationId, c)) }, this.commitFunction[pc.UNIFORMTYPE_VEC4] = function(t, e) { c = t.value, s = e[0], r = e[1], o = e[2], a = e[3], (e.length > 4 || c[0] !== s || c[1] !== r || c[2] !== o || c[3] !== a) && (l.uniform4fv(t.locationId, e), c[0] = s, c[1] = r, c[2] = o, c[3] = a) }, this.commitFunction[pc.UNIFORMTYPE_IVEC2] = function(t, e) { c = t.value, s = e[0], r = e[1], c[0] === s && c[1] === r || (l.uniform2iv(t.locationId, e), c[0] = s, c[1] = r) }, this.commitFunction[pc.UNIFORMTYPE_BVEC2] = this.commitFunction[pc.UNIFORMTYPE_IVEC2], this.commitFunction[pc.UNIFORMTYPE_IVEC3] = function(t, e) { c = t.value, s = e[0], r = e[1], o = e[2], c[0] === s && c[1] === r && c[2] === o || (l.uniform3iv(t.locationId, e), c[0] = s, c[1] = r, c[2] = o) }, this.commitFunction[pc.UNIFORMTYPE_BVEC3] = this.commitFunction[pc.UNIFORMTYPE_IVEC3], this.commitFunction[pc.UNIFORMTYPE_IVEC4] = function(t, e) { c = t.value, s = e[0], r = e[1], o = e[2], a = e[3], c[0] === s && c[1] === r && c[2] === o && c[3] === a || (l.uniform4iv(t.locationId, e), c[0] = s, c[1] = r, c[2] = o, c[3] = a) }, this.commitFunction[pc.UNIFORMTYPE_BVEC4] = this.commitFunction[pc.UNIFORMTYPE_IVEC4], this.commitFunction[pc.UNIFORMTYPE_MAT2] = function(t, e) { l.uniformMatrix2fv(t.locationId, !1, e) }, this.commitFunction[pc.UNIFORMTYPE_MAT3] = function(t, e) { l.uniformMatrix3fv(t.locationId, !1, e) }, this.commitFunction[pc.UNIFORMTYPE_MAT4] = function(t, e) { l.uniformMatrix4fv(t.locationId, !1, e) }, this.commitFunction[pc.UNIFORMTYPE_FLOATARRAY] = function(t, e) { l.uniform1fv(t.locationId, e) }, this.scope = new pc.ScopeSpace("Device"), this.programLib = new pc.ProgramLibrary(this);
            for (const t in pc.programlib) pc.programlib.hasOwnProperty(t) && this.programLib.register(t, pc.programlib[t]);
            this.events = new pc.Events(this), this.supportsBoneTextures = this.extTextureFloat && this.maxVertexTextures > 0, this.useTexCubeLod = this.extTextureLod && this.maxTextures < 16;
            let u = this.vertexUniformsCount;
            u -= 16, u -= 8, u -= 1, u -= 16, this.boneLimit = Math.floor(u / 4), this.boneLimit = Math.min(this.boneLimit, 128), "Mali-450 MP" === this.unmaskedRenderer && (this.boneLimit = 34), "Apple A8 GPU" === this.unmaskedRenderer && (this.forceCpuParticles = !0), this._drawCallsPerFrame = 0, this._vram = { tex: 0, vb: 0, ib: 0 }, this._shaderStats = { vsCompiled: 0, fsCompiled: 0, linked: 0, materialShaders: 0, compileTime: 0 }, this.constantTexSource = this.scope.resolve("source"), this.extTextureFloat ? this.webgl2 ? this.textureFloatRenderable = !!this.extColorBufferFloat : this.textureFloatRenderable = h(l, l.FLOAT) : this.textureFloatRenderable = !1, this.extTextureHalfFloat ? this.webgl2 ? this.textureHalfFloatRenderable = !!this.extColorBufferFloat : this.textureHalfFloatRenderable = h(l, this.extTextureHalfFloat.HALF_FLOAT_OES) : this.textureHalfFloatRenderable = !1, this.initializeGrabPassTexture(), this.activeDrawCall = null
        };
        return Object.assign(l.prototype, {
            getPrecision: function() {
                const t = this.gl;
                let e = "highp";
                if (t.getShaderPrecisionFormat) {
                    const i = t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT),
                        n = t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT),
                        s = t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT),
                        r = t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT),
                        o = i.precision > 0 && s.precision > 0,
                        a = n.precision > 0 && r.precision > 0;
                    o || (a ? (e = "mediump", DEBUG && console.warn("WARNING: highp not supported, using mediump")) : (e = "lowp", DEBUG && console.warn("WARNING: highp and mediump not supported, using lowp")))
                }
                return e
            },
            initializeExtensions: function() {
                const t = this.gl;
                let e;
                const i = t.getSupportedExtensions(),
                    n = function(...e) { let n = null; for (let s = 0; s < e.length; s++) - 1 !== i.indexOf(e[s]) && (n = t.getExtension(e[s])); return n };
                this.webgl2 ? (this.extBlendMinmax = !0, this.extDrawBuffers = !0, this.extInstancing = !0, this.extStandardDerivatives = !0, this.extTextureFloat = !0, this.extTextureHalfFloat = !0, this.extTextureHalfFloatLinear = !0, this.extTextureLod = !0, this.extUintElement = !0, this.extVertexArrayObject = !0, this.extColorBufferFloat = n("EXT_color_buffer_float")) : (this.extBlendMinmax = n("EXT_blend_minmax"), this.extDrawBuffers = n("EXT_draw_buffers"), this.extInstancing = n("ANGLE_instanced_arrays"), this.extInstancing && (e = this.extInstancing, t.drawArraysInstanced = e.drawArraysInstancedANGLE.bind(e), t.drawElementsInstanced = e.drawElementsInstancedANGLE.bind(e), t.vertexAttribDivisor = e.vertexAttribDivisorANGLE.bind(e)), this.extStandardDerivatives = n("OES_standard_derivatives"), this.extTextureFloat = n("OES_texture_float"), this.extTextureHalfFloat = n("OES_texture_half_float"), this.extTextureHalfFloatLinear = n("OES_texture_half_float_linear"), this.extTextureLod = n("EXT_shader_texture_lod"), this.extUintElement = n("OES_element_index_uint"), this.extVertexArrayObject = n("OES_vertex_array_object"), this.extVertexArrayObject && (e = this.extVertexArrayObject, t.createVertexArray = e.createVertexArrayOES.bind(e), t.deleteVertexArray = e.deleteVertexArrayOES.bind(e), t.isVertexArray = e.isVertexArrayOES.bind(e), t.bindVertexArray = e.bindVertexArrayOES.bind(e)), this.extColorBufferFloat = null), this.extDebugRendererInfo = n("WEBGL_debug_renderer_info"), this.extTextureFloatLinear = n("OES_texture_float_linear"), this.extTextureFilterAnisotropic = n("EXT_texture_filter_anisotropic", "WEBKIT_EXT_texture_filter_anisotropic"), this.extCompressedTextureETC1 = n("WEBGL_compressed_texture_etc1"), this.extCompressedTextureETC = n("WEBGL_compressed_texture_etc"), this.extCompressedTexturePVRTC = n("WEBGL_compressed_texture_pvrtc", "WEBKIT_WEBGL_compressed_texture_pvrtc"), this.extCompressedTextureS3TC = n("WEBGL_compressed_texture_s3tc", "WEBKIT_WEBGL_compressed_texture_s3tc"), this.extParallelShaderCompile = n("KHR_parallel_shader_compile")
            },
            initializeCapabilities: function() {
                const t = this.gl;
                let e;
                this.maxPrecision = this.precision = this.getPrecision();
                const i = t.getContextAttributes();
                this.supportsMsaa = i.antialias, this.supportsStencil = i.stencil, this.maxTextureSize = t.getParameter(t.MAX_TEXTURE_SIZE), this.maxCubeMapSize = t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE), this.maxRenderBufferSize = t.getParameter(t.MAX_RENDERBUFFER_SIZE), this.maxTextures = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS), this.maxCombinedTextures = t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS), this.maxVertexTextures = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS), this.vertexUniformsCount = t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS), this.fragmentUniformsCount = t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS), this.webgl2 ? (this.maxDrawBuffers = t.getParameter(t.MAX_DRAW_BUFFERS), this.maxColorAttachments = t.getParameter(t.MAX_COLOR_ATTACHMENTS), this.maxVolumeSize = t.getParameter(t.MAX_3D_TEXTURE_SIZE)) : (e = this.extDrawBuffers, this.maxDrawBuffers = e ? t.getParameter(e.MAX_DRAW_BUFFERS_EXT) : 1, this.maxColorAttachments = e ? t.getParameter(e.MAX_COLOR_ATTACHMENTS_EXT) : 1, this.maxVolumeSize = 1), e = this.extDebugRendererInfo, this.unmaskedRenderer = e ? t.getParameter(e.UNMASKED_RENDERER_WEBGL) : "", this.unmaskedVendor = e ? t.getParameter(e.UNMASKED_VENDOR_WEBGL) : "", e = this.extTextureFilterAnisotropic, this.maxAnisotropy = e ? t.getParameter(e.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1
            },
            initializeRenderState: function() {
                const t = this.gl;
                this.blending = !1, t.disable(t.BLEND), this.blendSrc = pc.BLENDMODE_ONE, this.blendDst = pc.BLENDMODE_ZERO, this.blendSrcAlpha = pc.BLENDMODE_ONE, this.blendDstAlpha = pc.BLENDMODE_ZERO, this.separateAlphaBlend = !1, this.blendEquation = pc.BLENDEQUATION_ADD, this.blendAlphaEquation = pc.BLENDEQUATION_ADD, this.separateAlphaEquation = !1, t.blendFunc(t.ONE, t.ZERO), t.blendEquation(t.FUNC_ADD), this.writeRed = !0, this.writeGreen = !0, this.writeBlue = !0, this.writeAlpha = !0, t.colorMask(!0, !0, !0, !0), this.cullMode = pc.CULLFACE_BACK, t.enable(t.CULL_FACE), t.cullFace(t.BACK), this.depthTest = !0, t.enable(t.DEPTH_TEST), this.depthFunc = pc.FUNC_LESSEQUAL, t.depthFunc(t.LEQUAL), this.depthWrite = !0, t.depthMask(!0), this.stencil = !1, t.disable(t.STENCIL_TEST), this.stencilFuncFront = this.stencilFuncBack = pc.FUNC_ALWAYS, this.stencilRefFront = this.stencilRefBack = 0, this.stencilMaskFront = this.stencilMaskBack = 255, t.stencilFunc(t.ALWAYS, 0, 255), this.stencilFailFront = this.stencilFailBack = pc.STENCILOP_KEEP, this.stencilZfailFront = this.stencilZfailBack = pc.STENCILOP_KEEP, this.stencilZpassFront = this.stencilZpassBack = pc.STENCILOP_KEEP, this.stencilWriteMaskFront = 255, this.stencilWriteMaskBack = 255, t.stencilOp(t.KEEP, t.KEEP, t.KEEP), t.stencilMask(255), this.alphaToCoverage = !1, this.raster = !0, this.webgl2 && (t.disable(t.SAMPLE_ALPHA_TO_COVERAGE), t.disable(t.RASTERIZER_DISCARD)), this.depthBiasEnabled = !1, t.disable(t.POLYGON_OFFSET_FILL), this.clearDepth = 1, t.clearDepth(1), this.clearRed = 0, this.clearBlue = 0, this.clearGreen = 0, this.clearAlpha = 0, t.clearColor(0, 0, 0, 0), this.clearStencil = 0, t.clearStencil(0), this.vx = this.vy = this.vw = this.vh = 0, this.sx = this.sy = this.sw = this.sh = 0, this.webgl2 ? t.hint(t.FRAGMENT_SHADER_DERIVATIVE_HINT, t.NICEST) : this.extStandardDerivatives && t.hint(this.extStandardDerivatives.FRAGMENT_SHADER_DERIVATIVE_HINT_OES, t.NICEST), t.enable(t.SCISSOR_TEST), t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, t.NONE), this.unpackFlipY = !1, t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, !1), this.unpackPremultiplyAlpha = !1, t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1), this.depthRange = new pc.Vec2(0, 1), t.depthRange(this.depthRange.x, this.depthRange.y)
            },
            initializeContext: function() {
                let t, e;
                for (this.initializeExtensions(), this.initializeCapabilities(), this.initializeRenderState(), t = 0, e = this.shaders.length; t < e; t++) this.compileAndLinkShader(this.shaders[t]);
                for (this.shader = null, t = 0, e = this.buffers.length; t < e; t++) this.buffers[t].bufferId = void 0, this.buffers[t].unlock();
                for (this.boundBuffer = null, this.boundElementBuffer = null, this.indexBuffer = null, this.attributesInvalidated = !0, this.enabledAttributes = {}, this.vertexBuffers = [], t = 0, e = this.textures.length; t < e; t++) {
                    const e = this.textures[t];
                    this.destroyTexture(e), e.dirtyAll()
                }
                for (this.textureUnit = 0, this.textureUnits.length = 0, t = 0; t < this.maxCombinedTextures; t++) this.textureUnits.push([null, null, null]);
                for (t = 0, e = this.targets.length; t < e; t++) this.targets[t]._glFrameBuffer = void 0, this.targets[t]._glDepthBuffer = void 0, this.targets[t]._glResolveFrameBuffer = void 0, this.targets[t]._glMsaaColorBuffer = void 0, this.targets[t]._glMsaaDepthBuffer = void 0;
                this.renderTarget = null, this.activeFramebuffer = null, this.feedback = null, this.transformFeedbackBuffer = null
            },
            initializeGrabPassTexture: function() {
                if (this.grabPassTexture) return;
                const t = new pc.Texture(this, { format: pc.PIXELFORMAT_R8_G8_B8_A8, autoMipmap: !1 });
                t.minFilter = pc.FILTER_LINEAR, t.magFilter = pc.FILTER_LINEAR, t.addressU = pc.ADDRESS_CLAMP_TO_EDGE, t.addressV = pc.ADDRESS_CLAMP_TO_EDGE, t.name = "texture_grabPass", t.setSource(this.canvas);
                const e = this.scope.resolve(t.name);
                e.setValue(t), this.grabPassTextureId = e, this.grabPassTexture = t
            },
            updateClientRect: function() { this.clientRect = this.canvas.getBoundingClientRect() },
            setViewport: function(t, e, i, n) { this.vx === t && this.vy === e && this.vw === i && this.vh === n || (this.gl.viewport(t, e, i, n), this.vx = t, this.vy = e, this.vw = i, this.vh = n) },
            setDepthRange: function(t, e) { this.depthRange.x === t && this.depthRange.y === e || (this.depthRange.set(t, e), this.gl.depthRange(t, e)) },
            setScissor: function(t, e, i, n) { this.sx === t && this.sy === e && this.sw === i && this.sh === n || (this.gl.scissor(t, e, i, n), this.sx = t, this.sy = e, this.sw = i, this.sh = n) },
            getProgramLibrary: function() { return this.programLib },
            setProgramLibrary: function(t) { this.programLib = t },
            setFramebuffer: function(t) { this.activeFramebuffer !== t && (this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, t), this.activeFramebuffer = t) },
            _checkFbo: function() {
                const t = this.gl;
                switch (t.checkFramebufferStatus(t.FRAMEBUFFER)) {
                    case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                        console.error("ERROR: FRAMEBUFFER_INCOMPLETE_ATTACHMENT");
                        break;
                    case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                        console.error("ERROR: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
                        break;
                    case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                        console.error("ERROR: FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
                        break;
                    case t.FRAMEBUFFER_UNSUPPORTED:
                        console.error("ERROR: FRAMEBUFFER_UNSUPPORTED");
                        break;
                    case t.FRAMEBUFFER_COMPLETE:
                }
            },
            updateBegin: function() {
                const t = this.gl;
                this.boundBuffer = null, this.boundElementBuffer = null;
                const e = this.renderTarget;
                if (e)
                    if (e._glFrameBuffer) {
                        this.setFramebuffer(e._glFrameBuffer);
                        const t = e._colorBuffer;
                        t && (this.setViewport(0, 0, t._width, t._height), this.setScissor(0, 0, t._width, t._height))
                    } else {
                        e._device = this, e._glFrameBuffer = t.createFramebuffer(), this.setFramebuffer(e._glFrameBuffer);
                        const i = e._colorBuffer;
                        i && (i._glTexture || (i._width = Math.min(i.width, this.maxRenderBufferSize), i._height = Math.min(i.height, this.maxRenderBufferSize), this.setTexture(i, 0)), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, i._cubemap ? t.TEXTURE_CUBE_MAP_POSITIVE_X + e._face : t.TEXTURE_2D, i._glTexture, 0));
                        const n = e._depthBuffer;
                        if (n && this.webgl2) n._glTexture || (n._width = Math.min(n.width, this.maxRenderBufferSize), n._height = Math.min(n.height, this.maxRenderBufferSize), this.setTexture(n, 0)), e._stencil ? t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, n._cubemap ? t.TEXTURE_CUBE_MAP_POSITIVE_X + e._face : t.TEXTURE_2D, e._depthBuffer._glTexture, 0) : t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, n._cubemap ? t.TEXTURE_CUBE_MAP_POSITIVE_X + e._face : t.TEXTURE_2D, e._depthBuffer._glTexture, 0);
                        else if (e._depth) { e._samples > 1 && this.webgl2 || (e._glDepthBuffer || (e._glDepthBuffer = t.createRenderbuffer()), t.bindRenderbuffer(t.RENDERBUFFER, e._glDepthBuffer), e._stencil ? (t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_STENCIL, e.width, e.height), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, e._glDepthBuffer)) : (t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_COMPONENT16, e.width, e.height), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.RENDERBUFFER, e._glDepthBuffer)), t.bindRenderbuffer(t.RENDERBUFFER, null)) }
                        DEBUG && this._checkFbo(), this.webgl2 && e._samples > 1 && (e._glResolveFrameBuffer = e._glFrameBuffer, e._glFrameBuffer = t.createFramebuffer(), this.setFramebuffer(e._glFrameBuffer), i && (e._glMsaaColorBuffer || (e._glMsaaColorBuffer = t.createRenderbuffer()), t.bindRenderbuffer(t.RENDERBUFFER, e._glMsaaColorBuffer), t.renderbufferStorageMultisample(t.RENDERBUFFER, e._samples, i._glInternalFormat, e.width, e.height), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.RENDERBUFFER, e._glMsaaColorBuffer)), e._depth && (e._glMsaaDepthBuffer || (e._glMsaaDepthBuffer = t.createRenderbuffer()), t.bindRenderbuffer(t.RENDERBUFFER, e._glMsaaDepthBuffer), e._stencil ? (t.renderbufferStorageMultisample(t.RENDERBUFFER, e._samples, t.DEPTH24_STENCIL8, e.width, e.height), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, e._glMsaaDepthBuffer)) : (t.renderbufferStorageMultisample(t.RENDERBUFFER, e._samples, t.DEPTH_COMPONENT32F, e.width, e.height), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.RENDERBUFFER, e._glMsaaDepthBuffer))), DEBUG && this._checkFbo()), this.targets.push(e)
                    }
                else this.setFramebuffer(null)
            },
            updateEnd: function() {
                const t = this.gl,
                    e = this.renderTarget;
                if (e) {
                    const i = e._colorBuffer;
                    i && i._glTexture && i.mipmaps && i._pot && (this.activeTexture(this.maxCombinedTextures - 1), this.bindTexture(i), t.generateMipmap(i._glTarget)), this.webgl2 && e._samples > 1 && e.autoResolve && e.resolve()
                }
            },
            initializeTexture: function(t) {
                const e = this.gl;
                let i;
                switch (t._glTexture = e.createTexture(), t._levels && t._levels[0] && "VIDEO" === t._levels[0].tagName && (t._needsUpdate = !0), t._glTarget = t._cubemap ? e.TEXTURE_CUBE_MAP : t._volume ? e.TEXTURE_3D : e.TEXTURE_2D, t._format) {
                    case pc.PIXELFORMAT_A8:
                        t._glFormat = e.ALPHA, t._glInternalFormat = e.ALPHA, t._glPixelType = e.UNSIGNED_BYTE;
                        break;
                    case pc.PIXELFORMAT_L8:
                        t._glFormat = e.LUMINANCE, t._glInternalFormat = e.LUMINANCE, t._glPixelType = e.UNSIGNED_BYTE;
                        break;
                    case pc.PIXELFORMAT_L8_A8:
                        t._glFormat = e.LUMINANCE_ALPHA, t._glInternalFormat = e.LUMINANCE_ALPHA, t._glPixelType = e.UNSIGNED_BYTE;
                        break;
                    case pc.PIXELFORMAT_R5_G6_B5:
                        t._glFormat = e.RGB, t._glInternalFormat = e.RGB, t._glPixelType = e.UNSIGNED_SHORT_5_6_5;
                        break;
                    case pc.PIXELFORMAT_R5_G5_B5_A1:
                        t._glFormat = e.RGBA, t._glInternalFormat = e.RGBA, t._glPixelType = e.UNSIGNED_SHORT_5_5_5_1;
                        break;
                    case pc.PIXELFORMAT_R4_G4_B4_A4:
                        t._glFormat = e.RGBA, t._glInternalFormat = e.RGBA, t._glPixelType = e.UNSIGNED_SHORT_4_4_4_4;
                        break;
                    case pc.PIXELFORMAT_R8_G8_B8:
                        t._glFormat = e.RGB, t._glInternalFormat = this.webgl2 ? e.RGB8 : e.RGB, t._glPixelType = e.UNSIGNED_BYTE;
                        break;
                    case pc.PIXELFORMAT_R8_G8_B8_A8:
                        t._glFormat = e.RGBA, t._glInternalFormat = this.webgl2 ? e.RGBA8 : e.RGBA, t._glPixelType = e.UNSIGNED_BYTE;
                        break;
                    case pc.PIXELFORMAT_DXT1:
                        i = this.extCompressedTextureS3TC, t._glFormat = e.RGB, t._glInternalFormat = i.COMPRESSED_RGB_S3TC_DXT1_EXT;
                        break;
                    case pc.PIXELFORMAT_DXT3:
                        i = this.extCompressedTextureS3TC, t._glFormat = e.RGBA, t._glInternalFormat = i.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                        break;
                    case pc.PIXELFORMAT_DXT5:
                        i = this.extCompressedTextureS3TC, t._glFormat = e.RGBA, t._glInternalFormat = i.COMPRESSED_RGBA_S3TC_DXT5_EXT;
                        break;
                    case pc.PIXELFORMAT_ETC1:
                        i = this.extCompressedTextureETC1, t._glFormat = e.RGB, t._glInternalFormat = i.COMPRESSED_RGB_ETC1_WEBGL;
                        break;
                    case pc.PIXELFORMAT_PVRTC_2BPP_RGB_1:
                        i = this.extCompressedTexturePVRTC, t._glFormat = e.RGB, t._glInternalFormat = i.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                        break;
                    case pc.PIXELFORMAT_PVRTC_2BPP_RGBA_1:
                        i = this.extCompressedTexturePVRTC, t._glFormat = e.RGBA, t._glInternalFormat = i.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
                        break;
                    case pc.PIXELFORMAT_PVRTC_4BPP_RGB_1:
                        i = this.extCompressedTexturePVRTC, t._glFormat = e.RGB, t._glInternalFormat = i.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                        break;
                    case pc.PIXELFORMAT_PVRTC_4BPP_RGBA_1:
                        i = this.extCompressedTexturePVRTC, t._glFormat = e.RGBA, t._glInternalFormat = i.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                        break;
                    case pc.PIXELFORMAT_ETC2_RGB:
                        i = this.extCompressedTextureETC, t._glFormat = e.RGB, t._glInternalFormat = i.COMPRESSED_RGB8_ETC2;
                        break;
                    case pc.PIXELFORMAT_ETC2_RGBA:
                        i = this.extCompressedTextureETC, t._glFormat = e.RGBA, t._glInternalFormat = i.COMPRESSED_RGBA8_ETC2_EAC;
                        break;
                    case pc.PIXELFORMAT_RGB16F:
                        i = this.extTextureHalfFloat, t._glFormat = e.RGB, this.webgl2 ? (t._glInternalFormat = e.RGB16F, t._glPixelType = e.HALF_FLOAT) : (t._glInternalFormat = e.RGB, t._glPixelType = i.HALF_FLOAT_OES);
                        break;
                    case pc.PIXELFORMAT_RGBA16F:
                        i = this.extTextureHalfFloat, t._glFormat = e.RGBA, this.webgl2 ? (t._glInternalFormat = e.RGBA16F, t._glPixelType = e.HALF_FLOAT) : (t._glInternalFormat = e.RGBA, t._glPixelType = i.HALF_FLOAT_OES);
                        break;
                    case pc.PIXELFORMAT_RGB32F:
                        t._glFormat = e.RGB, this.webgl2 ? t._glInternalFormat = e.RGB32F : t._glInternalFormat = e.RGB, t._glPixelType = e.FLOAT;
                        break;
                    case pc.PIXELFORMAT_RGBA32F:
                        t._glFormat = e.RGBA, this.webgl2 ? t._glInternalFormat = e.RGBA32F : t._glInternalFormat = e.RGBA, t._glPixelType = e.FLOAT;
                        break;
                    case pc.PIXELFORMAT_R32F:
                        t._glFormat = e.RED, t._glInternalFormat = e.R32F, t._glPixelType = e.FLOAT;
                        break;
                    case pc.PIXELFORMAT_DEPTH:
                        this.webgl2 ? (t._glFormat = e.DEPTH_COMPONENT, t._glInternalFormat = e.DEPTH_COMPONENT32F, t._glPixelType = e.FLOAT) : (t._glFormat = e.DEPTH_COMPONENT, t._glInternalFormat = e.DEPTH_COMPONENT, t._glPixelType = e.UNSIGNED_SHORT);
                        break;
                    case pc.PIXELFORMAT_DEPTHSTENCIL:
                        t._glFormat = e.DEPTH_STENCIL, t._glInternalFormat = e.DEPTH24_STENCIL8, t._glPixelType = e.UNSIGNED_INT_24_8;
                        break;
                    case pc.PIXELFORMAT_111110F:
                        t._glFormat = e.RGB, t._glInternalFormat = e.R11F_G11F_B10F, t._glPixelType = e.FLOAT;
                        break;
                    case pc.PIXELFORMAT_SRGB:
                        t._glFormat = e.RGB, t._glInternalFormat = e.SRGB8, t._glPixelType = e.UNSIGNED_BYTE;
                        break;
                    case pc.PIXELFORMAT_SRGBA:
                        t._glFormat = e.RGBA, t._glInternalFormat = e.SRGB8_ALPHA8, t._glPixelType = e.UNSIGNED_BYTE
                }
                this.textures.push(t)
            },
            destroyTexture: function(t) {
                if (t._glTexture) {
                    const e = this.textures.indexOf(t); - 1 !== e && this.textures.splice(e, 1);
                    for (const e in this.scope.variables)
                        if (this.scope.variables.hasOwnProperty(e)) {
                            const i = this.scope.variables[e];
                            i.value === t && (i.value = null)
                        }
                    for (let e = 0; e < this.textureUnits.length; e++) { const i = this.textureUnits[e]; for (let e = 0; e < i.length; e++) i[e] === t._glTexture && (i[e] = null) }
                    this.gl.deleteTexture(t._glTexture), delete t._glTexture, delete t._glTarget, delete t._glFormat, delete t._glInternalFormat, delete t._glPixelType, this._vram.tex -= t._gpuSize
                }
            },
            setUnpackFlipY: function(t) {
                if (this.unpackFlipY !== t) {
                    this.unpackFlipY = t;
                    const e = this.gl;
                    e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, t)
                }
            },
            setUnpackPremultiplyAlpha: function(t) {
                if (this.unpackPremultiplyAlpha !== t) {
                    this.unpackPremultiplyAlpha = t;
                    const e = this.gl;
                    e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t)
                }
            },
            uploadCubemapFromAtlas: function(t) {
                const e = t._atlas,
                    i = this.gl,
                    n = this.textureUnits[0],
                    s = n ? n[0] : null;
                e._glTexture || (this.setTexture(e, 0), this.uploadTexture(e));
                const r = this.activeFramebuffer,
                    o = i.createFramebuffer();
                this.setFramebuffer(o), i.framebufferTexture2D(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, e._glTexture, 0), t._needsUpload = !1, t._needsMipmapsUpload = !1, this.setTexture(t, 0);
                for (let n = 0; n < t._rects.length; n += 4) {
                    const s = t._rects[n + 0] * e._width,
                        r = t._rects[n + 1] * e._height,
                        o = t._rects[n + 2] * e._width - s,
                        a = t._rects[n + 3] * e._height - r,
                        c = n / 4 | 0,
                        h = c / 6 | 0,
                        l = c % 6 | 0;
                    i.copyTexImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + l, h, t._glInternalFormat, s, r, o, a, 0)
                }
                t._mipmaps && 24 === t._rects.length && i.generateMipmap(t._glTarget), this.setFramebuffer(r), s && (i.bindTexture(i.TEXTURE_2D, s), this.textureUnits[0][0] = s)
            },
            uploadTexture: function(t) {
                const e = this.gl;
                if (!t._needsUpload && (t._needsMipmapsUpload && t._mipmapsUploaded || !t._pot)) return;
                let i, n, s = 0;
                for (t._cubemap && t._atlas && t._rects && this.uploadCubemapFromAtlas(t); t._levels[s] || 0 === s;)
                    if (t._needsUpload || 0 !== s) {
                        if (s && (!t._needsMipmapsUpload || !t._mipmaps)) break;
                        if (i = t._levels[s], 1 !== s || t._compressed || (e.generateMipmap(t._glTarget), t._mipmapsUploaded = !0), t._cubemap) {
                            let r;
                            if (i[0] instanceof HTMLCanvasElement || i[0] instanceof HTMLImageElement || i[0] instanceof HTMLVideoElement)
                                for (r = 0; r < 6; r++) {
                                    if (!t._levelsUpdated[0][r]) continue;
                                    let n = i[r];
                                    n instanceof HTMLImageElement && (n.width > this.maxCubeMapSize || n.height > this.maxCubeMapSize) && (n = c(n, this.maxCubeMapSize), 0 === s && (t.width = n.width, t.height = n.height)), this.setUnpackFlipY(t._flipY), this.setUnpackPremultiplyAlpha(t._premultiplyAlpha), e.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + r, s, t._glInternalFormat, t._glFormat, t._glPixelType, n)
                                } else
                                    for (this.setUnpackPremultiplyAlpha(t._premultiplyAlpha), n = 1 / Math.pow(2, s), r = 0; r < 6; r++) {
                                        if (!t._levelsUpdated[0][r]) continue;
                                        const o = i[r];
                                        t._compressed ? e.compressedTexImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + r, s, t._glInternalFormat, Math.max(t._width * n, 1), Math.max(t._height * n, 1), 0, o) : (this.setUnpackFlipY(t._flipY), this.setUnpackPremultiplyAlpha(t._premultiplyAlpha), e.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + r, s, t._glInternalFormat, Math.max(t._width * n, 1), Math.max(t._height * n, 1), 0, t._glFormat, t._glPixelType, o))
                                    }
                        } else t._volume ? (n = 1 / Math.pow(2, s), t._compressed ? e.compressedTexImage3D(e.TEXTURE_3D, s, t._glInternalFormat, Math.max(t._width * n, 1), Math.max(t._height * n, 1), Math.max(t._depth * n, 1), 0, i) : (this.setUnpackFlipY(!1), this.setUnpackPremultiplyAlpha(t._premultiplyAlpha), e.texImage3D(e.TEXTURE_3D, s, t._glInternalFormat, Math.max(t._width * n, 1), Math.max(t._height * n, 1), Math.max(t._depth * n, 1), 0, t._glFormat, t._glPixelType, i))) : (i instanceof HTMLCanvasElement || i instanceof HTMLImageElement || i instanceof HTMLVideoElement ? (i instanceof HTMLImageElement && (i.width > this.maxTextureSize || i.height > this.maxTextureSize) && (i = c(i, this.maxTextureSize), 0 === s && (t.width = i.width, t.height = i.height)), this.setUnpackFlipY(t._flipY), this.setUnpackPremultiplyAlpha(t._premultiplyAlpha), e.texImage2D(e.TEXTURE_2D, s, t._glInternalFormat, t._glFormat, t._glPixelType, i)) : (n = 1 / Math.pow(2, s), t._compressed ? e.compressedTexImage2D(e.TEXTURE_2D, s, t._glInternalFormat, Math.max(t._width * n, 1), Math.max(t._height * n, 1), 0, i) : (this.setUnpackFlipY(!1), this.setUnpackPremultiplyAlpha(t._premultiplyAlpha), e.texImage2D(e.TEXTURE_2D, s, t._glInternalFormat, Math.max(t._width * n, 1), Math.max(t._height * n, 1), 0, t._glFormat, t._glPixelType, i))), t._mipmapsUploaded = 0 !== s);
                        s++
                    } else s++;
                if (t._needsUpload)
                    if (t._cubemap)
                        for (let e = 0; e < 6; e++) t._levelsUpdated[0][e] = !1;
                    else t._levelsUpdated[0] = !1;
                    !t._compressed && t._mipmaps && t._needsMipmapsUpload && t._pot && 1 === t._levels.length && (e.generateMipmap(t._glTarget), t._mipmapsUploaded = !0), t._gpuSize && (this._vram.tex -= t._gpuSize), t._gpuSize = t.gpuSize, this._vram.tex += t._gpuSize
            },
            activeTexture: function(t) { this.textureUnit !== t && (this.gl.activeTexture(this.gl.TEXTURE0 + t), this.textureUnit = t) },
            bindTexture: function(t) {
                const e = t._glTarget,
                    i = t._glTexture,
                    n = this.textureUnit,
                    s = this.targetToSlot[e];
                this.textureUnits[n][s] !== i && (this.gl.bindTexture(e, i), this.textureUnits[n][s] = i)
            },
            bindTextureOnUnit: function(t, e) {
                const i = t._glTarget,
                    n = t._glTexture,
                    s = this.targetToSlot[i];
                this.textureUnits[e][s] !== n && (this.activeTexture(e), this.gl.bindTexture(i, n), this.textureUnits[e][s] = n)
            },
            setTextureParameters: function(t) {
                const e = this.gl,
                    i = t._parameterFlags,
                    n = t._glTarget;
                if (1 & i) {
                    let i = t._minFilter;
                    (!t._pot || !t._mipmaps || t._compressed && 1 === t._levels.length) && (i === pc.FILTER_NEAREST_MIPMAP_NEAREST || i === pc.FILTER_NEAREST_MIPMAP_LINEAR ? i = pc.FILTER_NEAREST : i !== pc.FILTER_LINEAR_MIPMAP_NEAREST && i !== pc.FILTER_LINEAR_MIPMAP_LINEAR || (i = pc.FILTER_LINEAR)), e.texParameteri(n, e.TEXTURE_MIN_FILTER, this.glFilter[i])
                }
                if (2 & i && e.texParameteri(n, e.TEXTURE_MAG_FILTER, this.glFilter[t._magFilter]), 4 & i && (this.webgl2 ? e.texParameteri(n, e.TEXTURE_WRAP_S, this.glAddress[t._addressU]) : e.texParameteri(n, e.TEXTURE_WRAP_S, this.glAddress[t._pot ? t._addressU : pc.ADDRESS_CLAMP_TO_EDGE])), 8 & i && (this.webgl2 ? e.texParameteri(n, e.TEXTURE_WRAP_T, this.glAddress[t._addressV]) : e.texParameteri(n, e.TEXTURE_WRAP_T, this.glAddress[t._pot ? t._addressV : pc.ADDRESS_CLAMP_TO_EDGE])), 16 & i && this.webgl2 && e.texParameteri(n, e.TEXTURE_WRAP_R, this.glAddress[t._addressW]), 32 & i && this.webgl2 && e.texParameteri(n, e.TEXTURE_COMPARE_MODE, t._compareOnRead ? e.COMPARE_REF_TO_TEXTURE : e.NONE), 64 & i && this.webgl2 && e.texParameteri(n, e.TEXTURE_COMPARE_FUNC, this.glComparison[t._compareFunc]), 128 & i) {
                    const i = this.extTextureFilterAnisotropic;
                    i && e.texParameterf(n, i.TEXTURE_MAX_ANISOTROPY_EXT, Math.max(1, Math.min(Math.round(t._anisotropy), this.maxAnisotropy)))
                }
            },
            setTexture: function(t, e) { t._glTexture || this.initializeTexture(t), t._parameterFlags > 0 || t._needsUpload || t._needsMipmapsUpload ? (this.activeTexture(e), this.bindTexture(t), t._parameterFlags && (this.setTextureParameters(t), t._parameterFlags = 0), (t._needsUpload || t._needsMipmapsUpload) && (this.uploadTexture(t), t !== this.grabPassTexture && (t.markUploaded(), t._needsMipmapsUpload = !1))) : this.bindTextureOnUnit(t, e) },
            setBuffers: function(t, o, a) {
                o = o || [];
                const c = this.gl;
                let h, l, u, d, p, _;
                const f = this.shader.attributes;
                if (this.attributesInvalidated) {
                    for (let o = 0, a = f.length; o < a; o++) {
                        h = f[o], _ = h.locationId, l = h.scopeId.value;
                        const a = "TEXCOORD1" === h.scopeId.name && this.activeDrawCall && (this.activeDrawCall._shaderDefs & pc.SHADERDEF_LMUV0) > 0;
                        if (null === l || l.const || (u = this.vertexBuffers[l.stream], d = this.vbOffsets[l.stream] || 0, !u || u.format.elementMap[l.name] || a || (c.disableVertexAttribArray(h.locationId), this.enabledAttributes[h.locationId] = !1, l = null)), null == l) c.disableVertexAttribArray(_), this.enabledAttributes[_] = !1, "POSITION" === h.scopeId.name ? c.vertexAttrib4fv(_, n) : "COLOR" === h.scopeId.name ? c.vertexAttrib4fv(_, e) : "TANGENT" === h.scopeId.name ? c.vertexAttrib4fv(_, s) : "NORMAL" === h.scopeId.name ? c.vertexAttrib4fv(_, r) : c.vertexAttrib4fv(_, i);
                        else {
                            if (void 0 === u) continue;
                            let e;
                            if (p = u.bufferId, this.boundBuffer !== p && (c.bindBuffer(c.ARRAY_BUFFER, p), this.attributePointers = {}, this.boundBuffer = p), this.enabledAttributes[_] || (c.enableVertexAttribArray(_), this.enabledAttributes[_] = !0), a)
                                for (let t = 0; t < f.length; t++) { const i = f[t].scopeId; if ("TEXCOORD0" === i.name) { e = i.value; break } } else e = l;
                            const i = (e.numComponents << 24) + (e.dataType << 21) + (e.normalize ? 1 << 20 : 0) + (e.stride << 10) + (e.offset + d << 0);
                            this.attributePointers[_] !== i && (c.vertexAttribPointer(_, e.numComponents, this.glType[e.dataType], e.normalize, e.stride, e.offset + d), this.attributePointers[_] = i), 1 === l.stream && t > 0 ? this.instancedAttribs[_] || (c.vertexAttribDivisor(_, 1), this.instancedAttribs[_] = !0) : this.instancedAttribs[_] && (c.vertexAttribDivisor(_, 0), this.instancedAttribs[_] = !1)
                        }
                    }
                    this.attributesInvalidated = !1
                }
                for (let t = 0, e = f.length; t < e; t++) {
                    h = f[t];
                    const e = o[h.scopeId.name];
                    e && (_ = h.locationId, this.enabledAttributes[h.locationId] = !1, c.disableVertexAttribArray(h.locationId), c.vertexAttrib4fv(h.locationId, e))
                }
                p = this.indexBuffer ? this.indexBuffer.bufferId : null, this.boundElementBuffer !== p && (c.bindBuffer(c.ELEMENT_ARRAY_BUFFER, p), this.boundElementBuffer = p)
            },
            draw: function(t, e, i, n, s) {
                const r = this.gl;
                let o, c, h, l, u, d, p, _, f, m, y, g;
                const E = this.shader,
                    A = E.samplers,
                    b = E.uniforms;
                if (0 === e) return;
                this.activeDrawCall = s, e > 0 && (this.boundBuffer = null, this.attributesInvalidated = !0), this.setBuffers(e, n);
                let C = 0;
                for (o = 0, h = A.length; o < h; o++)
                    if (u = A[o], d = u.scopeId.value, l = u.scopeId.name, null == d && (d = i[u.scopeId.name] || a[u.dataType]), u.meta || (u.meta = { hdr: this.scope.resolve(l + "_HDR"), texels: this.scope.resolve(l + "_TexelSize") }), d instanceof pc.Texture) p = d, this.setTexture(p, C), p.rgbm ? u.meta.hdr.setValue([5 * p.intensity, 1, 0, 1]) : u.meta.hdr.setValue([1 * p.intensity, 1, 0, 0]), u.meta.texels.setValue([1 / p.width, 1 / p.height, p.width, p.height]), DEBUG && this.renderTarget && this.renderTarget._samples < 2 && (this.renderTarget.colorBuffer && this.renderTarget.colorBuffer === p ? console.error("Trying to bind current color buffer as a texture") : this.renderTarget.depthBuffer && this.renderTarget.depthBuffer === p && console.error("Trying to bind current depth buffer as a texture")), u.slot !== C && (r.uniform1i(u.locationId, C), u.slot = C), C++;
                    else {
                        for (u.array.length = 0, _ = d.length, c = 0; c < _; c++) p = d[c], this.setTexture(p, C), u.array[c] = C, C++;
                        r.uniform1iv(u.locationId, u.array)
                    }
                for (o = 0, h = b.length; o < h; o++) f = b[o], m = f.scopeId, y = f.version, g = m.versionObject.version, y.globalId === g.globalId && y.revision === g.revision || (y.globalId = g.globalId, y.revision = g.revision, null == m.value ? this.commitFunction[f.dataType](f, i[m.name] || a[f.dataType]) : this.commitFunction[f.dataType](f, m.value));
                this.webgl2 && this.transformFeedbackBuffer && (r.bindBufferBase(r.TRANSFORM_FEEDBACK_BUFFER, 0, this.transformFeedbackBuffer.bufferId), r.beginTransformFeedback(r.POINTS));
                const T = this.glPrimitive[t.type],
                    S = t.count;
                if (t.indexed) {
                    const i = this.indexBuffer,
                        n = i.glFormat,
                        s = t.base * i.bytesPerIndex;
                    e > 0 ? r.drawElementsInstanced(T, S, n, s, e) : r.drawElements(T, S, n, s)
                } else {
                    const i = t.base;
                    e > 0 ? r.drawArraysInstanced(T, i, S, e) : r.drawArrays(T, i, S)
                }
                this.webgl2 && this.transformFeedbackBuffer && (r.endTransformFeedback(), r.bindBufferBase(r.TRANSFORM_FEEDBACK_BUFFER, 0, null)), this._drawCallsPerFrame++, this.activeDrawCall = null
            },
            clear: function(t) {
                const e = this.defaultClearOptions,
                    i = pc.CLEARFLAG_COLOR | pc.CLEARFLAG_STENCIL | pc.CLEARFLAG_DEPTH,
                    n = void 0 === (t = t || e).flags || null === t.flags ? e.flags : t.flags;
                if (0 !== n) {
                    const s = this.gl;
                    if (n & pc.CLEARFLAG_COLOR) {
                        const i = t.color ? t.color : e.color;
                        this.setClearColor(i[0], i[1], i[2], i[3])
                    }
                    if (n & pc.CLEARFLAG_DEPTH) {
                        const i = void 0 === t.depth || null === t.depth ? e.depth : t.depth;
                        this.setClearDepth(i), this.depthWrite || s.depthMask(!0)
                    }
                    if (n & pc.CLEARFLAG_STENCIL) {
                        const i = void 0 === t.stencil || null === t.stencil ? e.stencil : t.stencil;
                        this.setClearStencil(i)
                    }
                    s.clear(this.glClearFlag[n & i]), n & pc.CLEARFLAG_DEPTH && (this.depthWrite || s.depthMask(!1))
                }
            },
            readPixels: function(t, e, i, n, s) {
                const r = this.gl;
                r.readPixels(t, e, i, n, r.RGBA, r.UNSIGNED_BYTE, s)
            },
            setClearDepth: function(t) { t !== this.clearDepth && (this.gl.clearDepth(t), this.clearDepth = t) },
            setClearColor: function(t, e, i, n) { t === this.clearRed && e === this.clearGreen && i === this.clearBlue && n === this.clearAlpha || (this.gl.clearColor(t, e, i, n), this.clearRed = t, this.clearGreen = e, this.clearBlue = i, this.clearAlpha = n) },
            setClearStencil: function(t) { t !== this.clearStencil && (this.gl.clearStencil(t), this.clearStencil = t) },
            setRenderTarget: function(t) { this.renderTarget = t },
            getRenderTarget: function() { return this.renderTarget },
            getDepthTest: function() { return this.depthTest },
            setDepthTest: function(t) {
                if (this.depthTest !== t) {
                    const e = this.gl;
                    t ? e.enable(e.DEPTH_TEST) : e.disable(e.DEPTH_TEST), this.depthTest = t
                }
            },
            setDepthFunc: function(t) { this.depthFunc !== t && (this.gl.depthFunc(this.glComparison[t]), this.depthFunc = t) },
            getDepthWrite: function() { return this.depthWrite },
            setDepthWrite: function(t) { this.depthWrite !== t && (this.gl.depthMask(t), this.depthWrite = t) },
            setColorWrite: function(t, e, i, n) { this.writeRed === t && this.writeGreen === e && this.writeBlue === i && this.writeAlpha === n || (this.gl.colorMask(t, e, i, n), this.writeRed = t, this.writeGreen = e, this.writeBlue = i, this.writeAlpha = n) },
            setAlphaToCoverage: function(t) { this.webgl2 && this.alphaToCoverage !== t && (this.alphaToCoverage = t, t ? this.gl.enable(this.gl.SAMPLE_ALPHA_TO_COVERAGE) : this.gl.disable(this.gl.SAMPLE_ALPHA_TO_COVERAGE)) },
            setTransformFeedbackBuffer: function(t) {
                if (this.transformFeedbackBuffer !== t && (this.transformFeedbackBuffer = t, this.webgl2)) {
                    const e = this.gl;
                    t ? (this.feedback || (this.feedback = e.createTransformFeedback()), e.bindTransformFeedback(e.TRANSFORM_FEEDBACK, this.feedback)) : e.bindTransformFeedback(e.TRANSFORM_FEEDBACK, null)
                }
            },
            setRaster: function(t) { this.raster !== t && (this.raster = t, this.webgl2 && (t ? this.gl.disable(this.gl.RASTERIZER_DISCARD) : this.gl.enable(this.gl.RASTERIZER_DISCARD))) },
            setDepthBias: function(t) { this.depthBiasEnabled !== t && (this.depthBiasEnabled = t, t ? this.gl.enable(this.gl.POLYGON_OFFSET_FILL) : this.gl.disable(this.gl.POLYGON_OFFSET_FILL)) },
            setDepthBiasValues: function(t, e) { this.gl.polygonOffset(e, t) },
            getBlending: function() { return this.blending },
            setBlending: function(t) {
                if (this.blending !== t) {
                    const e = this.gl;
                    t ? e.enable(e.BLEND) : e.disable(e.BLEND), this.blending = t
                }
            },
            setStencilTest: function(t) {
                if (this.stencil !== t) {
                    const e = this.gl;
                    t ? e.enable(e.STENCIL_TEST) : e.disable(e.STENCIL_TEST), this.stencil = t
                }
            },
            setStencilFunc: function(t, e, i) { if (this.stencilFuncFront !== t || this.stencilRefFront !== e || this.stencilMaskFront !== i || this.stencilFuncBack !== t || this.stencilRefBack !== e || this.stencilMaskBack !== i) { this.gl.stencilFunc(this.glComparison[t], e, i), this.stencilFuncFront = this.stencilFuncBack = t, this.stencilRefFront = this.stencilRefBack = e, this.stencilMaskFront = this.stencilMaskBack = i } },
            setStencilFuncFront: function(t, e, i) {
                if (this.stencilFuncFront !== t || this.stencilRefFront !== e || this.stencilMaskFront !== i) {
                    const n = this.gl;
                    n.stencilFuncSeparate(n.FRONT, this.glComparison[t], e, i), this.stencilFuncFront = t, this.stencilRefFront = e, this.stencilMaskFront = i
                }
            },
            setStencilFuncBack: function(t, e, i) {
                if (this.stencilFuncBack !== t || this.stencilRefBack !== e || this.stencilMaskBack !== i) {
                    const n = this.gl;
                    n.stencilFuncSeparate(n.BACK, this.glComparison[t], e, i), this.stencilFuncBack = t, this.stencilRefBack = e, this.stencilMaskBack = i
                }
            },
            setStencilOperation: function(t, e, i, n) { this.stencilFailFront === t && this.stencilZfailFront === e && this.stencilZpassFront === i && this.stencilFailBack === t && this.stencilZfailBack === e && this.stencilZpassBack === i || (this.gl.stencilOp(this.glStencilOp[t], this.glStencilOp[e], this.glStencilOp[i]), this.stencilFailFront = this.stencilFailBack = t, this.stencilZfailFront = this.stencilZfailBack = e, this.stencilZpassFront = this.stencilZpassBack = i), this.stencilWriteMaskFront === n && this.stencilWriteMaskBack === n || (this.gl.stencilMask(n), this.stencilWriteMaskFront = n, this.stencilWriteMaskBack = n) },
            setStencilOperationFront: function(t, e, i, n) { this.stencilFailFront === t && this.stencilZfailFront === e && this.stencilZpassFront === i || (this.gl.stencilOpSeparate(this.gl.FRONT, this.glStencilOp[t], this.glStencilOp[e], this.glStencilOp[i]), this.stencilFailFront = t, this.stencilZfailFront = e, this.stencilZpassFront = i), this.stencilWriteMaskFront !== n && (this.gl.stencilMaskSeparate(this.gl.FRONT, n), this.stencilWriteMaskFront = n) },
            setStencilOperationBack: function(t, e, i, n) { this.stencilFailBack === t && this.stencilZfailBack === e && this.stencilZpassBack === i || (this.gl.stencilOpSeparate(this.gl.BACK, this.glStencilOp[t], this.glStencilOp[e], this.glStencilOp[i]), this.stencilFailBack = t, this.stencilZfailBack = e, this.stencilZpassBack = i), this.stencilWriteMaskBack !== n && (this.gl.stencilMaskSeparate(this.gl.BACK, n), this.stencilWriteMaskBack = n) },
            setBlendFunction: function(t, e) {
                (this.blendSrc !== t || this.blendDst !== e || this.separateAlphaBlend) && (this.gl.blendFunc(this.glBlendFunction[t], this.glBlendFunction[e]), this.blendSrc = t, this.blendDst = e, this.separateAlphaBlend = !1)
            },
            setBlendFunctionSeparate: function(t, e, i, n) { this.blendSrc === t && this.blendDst === e && this.blendSrcAlpha === i && this.blendDstAlpha === n && this.separateAlphaBlend || (this.gl.blendFuncSeparate(this.glBlendFunction[t], this.glBlendFunction[e], this.glBlendFunction[i], this.glBlendFunction[n]), this.blendSrc = t, this.blendDst = e, this.blendSrcAlpha = i, this.blendDstAlpha = n, this.separateAlphaBlend = !0) },
            setBlendEquation: function(t) {
                (this.blendEquation !== t || this.separateAlphaEquation) && (this.gl.blendEquation(this.glBlendEquation[t]), this.blendEquation = t, this.separateAlphaEquation = !1)
            },
            setBlendEquationSeparate: function(t, e) { this.blendEquation === t && this.blendAlphaEquation === e && this.separateAlphaEquation || (this.gl.blendEquationSeparate(this.glBlendEquation[t], this.glBlendEquation[e]), this.blendEquation = t, this.blendAlphaEquation = e, this.separateAlphaEquation = !0) },
            setCullMode: function(t) {
                if (this.cullMode !== t) {
                    if (t === pc.CULLFACE_NONE) this.gl.disable(this.gl.CULL_FACE);
                    else {
                        this.cullMode === pc.CULLFACE_NONE && this.gl.enable(this.gl.CULL_FACE);
                        const e = this.glCull[t];
                        this.cullFace !== e && (this.gl.cullFace(e), this.cullFace = e)
                    }
                    this.cullMode = t
                }
            },
            getCullMode: function() { return this.cullMode },
            setIndexBuffer: function(t) { this.indexBuffer = t },
            setVertexBuffer: function(t, e, i) {
                if (null != t && (this.vertexBuffers[e] !== t || this.vbOffsets[e] !== i)) {
                    this.vertexBuffers[e] = t, this.vbOffsets[e] = i;
                    let n = 0;
                    const s = t.getFormat().elements,
                        r = s.length;
                    for (; n < r;) {
                        const t = s[n++];
                        t.stream = e, t.scopeId.setValue(t)
                    }
                    this.attributesInvalidated = !0
                }
            },
            compileShaderSource: function(t, e) { const i = this.gl; let n = e ? this.vertexShaderCache[t] : this.fragmentShaderCache[t]; return n || (n = i.createShader(e ? i.VERTEX_SHADER : i.FRAGMENT_SHADER), i.shaderSource(n, t), i.compileShader(n), e ? this.vertexShaderCache[t] = n : this.fragmentShaderCache[t] = n), n },
            compileAndLinkShader: function(t) {
                const e = this.gl,
                    i = t.definition,
                    n = this.compileShaderSource(i.vshader, !0),
                    s = this.compileShaderSource(i.fshader, !1),
                    r = e.createProgram();
                if (e.attachShader(r, n), e.attachShader(r, s), this.webgl2 && i.useTransformFeedback) {
                    const t = i.attributes,
                        n = [];
                    for (const e in t) t.hasOwnProperty(e) && n.push("out_" + e);
                    e.transformFeedbackVaryings(r, n, e.INTERLEAVED_ATTRIBS)
                }
                for (const t in i.attributes)
                    if (i.attributes.hasOwnProperty(t)) {
                        const n = i.attributes[t],
                            s = o[n];
                        e.bindAttribLocation(r, s, t)
                    }
                e.linkProgram(r), t._glVertexShader = n, t._glFragmentShader = s, t._glProgram = r, t._globalKeywordsVersion = pc.Shader._globalKeywordsVersion, t.ready = !1
            },
            createShader: function(t) { this.compileAndLinkShader(t), this.shaders.push(t) },
            destroyShader: function(t) { const e = this.shaders.indexOf(t); - 1 !== e && this.shaders.splice(e, 1), t._glProgram && (this.gl.deleteProgram(t._glProgram), t._glProgram = null, this.removeShaderFromCache(t)) },
            _addLineNumbers: function(t) { const e = t.split("\n"); for (let t = 0, i = e.length; t < i; t++) e[t] = t + 1 + ":\t" + e[t]; return e.join("\n") },
            postLink: function(t) {
                const e = this.gl,
                    i = t._glVertexShader,
                    n = t._glFragmentShader,
                    s = t._glProgram,
                    r = t.definition;
                if (!e.getShaderParameter(i, e.COMPILE_STATUS)) return console.error("Failed to compile vertex shader:\n\n" + this._addLineNumbers(r.vshader) + "\n\n" + e.getShaderInfoLog(i)), !1;
                if (!e.getShaderParameter(n, e.COMPILE_STATUS)) return console.error("Failed to compile fragment shader:\n\n" + this._addLineNumbers(r.fshader) + "\n\n" + e.getShaderInfoLog(n)), !1;
                if (!e.getProgramParameter(s, e.LINK_STATUS)) return console.error("Failed to link shader program. Error: " + e.getProgramInfoLog(s)), !1;
                let o, a, c, h;
                o = 0;
                const l = e.getProgramParameter(s, e.ACTIVE_ATTRIBUTES);
                for (; o < l;) a = e.getActiveAttrib(s, o++), c = e.getAttribLocation(s, a.name), void 0 === r.attributes[a.name] && console.error('Vertex shader attribute "' + a.name + '" is not mapped to a semantic in shader definition.'), h = new pc.ShaderInput(this, r.attributes[a.name], this.pcUniformType[a.type], c), t.attributes.push(h);
                t.samplers = [], t.uniforms = [], o = 0;
                const u = e.getProgramParameter(s, e.ACTIVE_UNIFORMS);
                for (; o < u;) a = e.getActiveUniform(s, o++), c = e.getUniformLocation(s, a.name), h = new pc.ShaderInput(this, a.name, this.pcUniformType[a.type], c), a.type === e.SAMPLER_2D || a.type === e.SAMPLER_CUBE || this.webgl2 && (a.type === e.SAMPLER_2D_SHADOW || a.type === e.SAMPLER_CUBE_SHADOW || a.type === e.SAMPLER_3D) ? t.samplers.push(h) : t.uniforms.push(h);
                return t.ready = !0, !0
            },
            setShader: function(t) {
                if (t !== this.shader) {
                    if (t.needsCompilation && this.compileAndLinkShader(t), !t.ready) {
                        if (!this.postLink(t)) return !1;
                        t.uniformsUsage = this.getUniformsInUse(t.uniforms)
                    }
                    this.shader = t, this.gl.useProgram(t._glProgram), this.attributesInvalidated = !0
                }
                return !0
            },
            getHdrFormat: function() { return this.textureHalfFloatRenderable ? pc.PIXELFORMAT_RGB16F : this.textureFloatRenderable ? pc.PIXELFORMAT_RGB32F : pc.PIXELFORMAT_R8_G8_B8_A8 },
            getBoneLimit: function() { return this.boneLimit },
            setBoneLimit: function(t) { this.boneLimit = t },
            resizeCanvas: function(e, i) {
                this._width = e, this._height = i;
                const n = Math.min(this._maxPixelRatio, window.devicePixelRatio);
                e *= n, i *= n, this.canvas.width = e, this.canvas.height = i, this.events.fire(t, e, i, this._width, this._height)
            },
            setResolution: function(e, i) { this._width = e, this._height = i, this.canvas.width = e, this.canvas.height = i, this.events.fire(t, e, i, this._width, this._height) },
            getUniformsInUse(t) {
                let e = 0;
                for (let i = 0; i < t.length; i++) {
                    const n = t[i],
                        s = pc.UNIFORMS_USAGE_MAP[n.scopeId.name];
                    void 0 !== s && (e |= s)
                }
                return e
            },
            applyStencilState(t, e, i) { t || e || !i ? (t || e) && (this.setStencilTest(!0), t === e ? (this.setStencilFunc(t.func, t.ref, t.readMask), this.setStencilOperation(t.fail, t.zfail, t.zpass, t.writeMask)) : (t ? (this.setStencilFuncFront(t.func, t.ref, t.readMask), this.setStencilOperationFront(t.fail, t.zfail, t.zpass, t.writeMask)) : (this.setStencilFuncFront(pc.FUNC_ALWAYS, 0, 255), this.setStencilOperationFront(pc.STENCILOP_KEEP, pc.STENCILOP_KEEP, pc.STENCILOP_KEEP, 255)), e ? (this.setStencilFuncBack(e.func, e.ref, e.readMask), this.setStencilOperationBack(e.fail, e.zfail, e.zpass, e.writeMask)) : (this.setStencilFuncBack(pc.FUNC_ALWAYS, 0, 255), this.setStencilOperationBack(pc.STENCILOP_KEEP, pc.STENCILOP_KEEP, pc.STENCILOP_KEEP, 255)))) : this.setStencilTest(!1) },
            clearShaderCache: function() {
                const t = this.gl;
                let e;
                for (e in this.fragmentShaderCache) this.fragmentShaderCache.hasOwnProperty(e) && (t.deleteShader(this.fragmentShaderCache[e]), delete this.fragmentShaderCache[e]);
                for (e in this.vertexShaderCache) this.vertexShaderCache.hasOwnProperty(e) && (t.deleteShader(this.vertexShaderCache[e]), delete this.vertexShaderCache[e]);
                this.programLib.clearCache()
            },
            removeShaderFromCache: function(t) { this.programLib.removeFromCache(t) },
            destroy: function() {
                const t = this.gl;
                this.grabPassTexture.destroy(), this.webgl2 && this.feedback && t.deleteTransformFeedback(this.feedback), this.clearShaderCache(), this.canvas.removeEventListener("webglcontextlost", this._contextLostHandler, !1), this.canvas.removeEventListener("webglcontextrestored", this._contextRestoredHandler, !1), this._contextLostHandler = null, this._contextRestoredHandler = null, this.canvas = null, this.gl = null
            }
        }), Object.defineProperty(l.prototype, "width", { get: function() { return this.gl.drawingBufferWidth || this.canvas.width } }), Object.defineProperty(l.prototype, "height", { get: function() { return this.gl.drawingBufferHeight || this.canvas.height } }), Object.defineProperty(l.prototype, "enableAutoInstancing", { get: function() { return this._enableAutoInstancing }, set: function(t) { this._enableAutoInstancing = t && this.extInstancing } }), Object.defineProperty(l.prototype, "maxPixelRatio", { get: function() { return this._maxPixelRatio }, set: function(t) { this._maxPixelRatio = t, this.resizeCanvas(this._width, this._height) } }), { GraphicsDevice: l, ShaderAttributeSlots: o, UniformDefaultValues: a }
    }()), Object.assign(pc, function() {
        const t = {},
            e = { vertex_position: pc.SEMANTIC_POSITION, vertex_normal: pc.SEMANTIC_NORMAL, vertex_tangent: pc.SEMANTIC_TANGENT, vertex_texCoord0: pc.SEMANTIC_TEXCOORD0, vertex_texCoord1: pc.SEMANTIC_TEXCOORD1, vertex_texCoord2: pc.SEMANTIC_TEXCOORD2, vertex_texCoord3: pc.SEMANTIC_TEXCOORD3, vertex_texCoord4: pc.SEMANTIC_TEXCOORD4, vertex_texCoord5: pc.SEMANTIC_TEXCOORD5, vertex_texCoord6: pc.SEMANTIC_TEXCOORD6, vertex_texCoord7: pc.SEMANTIC_TEXCOORD7, vertex_color: pc.SEMANTIC_COLOR, vertex_boneIndices: pc.SEMANTIC_BLENDINDICES, vertex_boneWeights: pc.SEMANTIC_BLENDWEIGHT };
        return t.collectAttribs = function(t) {
            const i = {};
            let n = 0,
                s = t.indexOf("attribute");
            for (; s >= 0 && !(s > 0 && "/" === t[s - 1]);) {
                const r = t.indexOf(";", s),
                    o = t.lastIndexOf(" ", r),
                    a = t.substr(o + 1, r - (o + 1)),
                    c = e[a];
                void 0 !== c ? i[a] = c : (i[a] = "ATTR" + n, n++), s = t.indexOf("attribute", s + 1)
            }
            return i
        }, t.createShader = function(e, i, n, s) {
            let r = t[i],
                o = pc.programlib.precisionCode(e) + "\n" + t[n];
            o = pc.ensureExtensionsInTheBeginning(o);
            const a = this.collectAttribs(r);
            return e.webgl2 && (r = pc.programlib.versionCode(e) + this.gles3VS + r, o = pc.programlib.versionCode(e) + this.gles3PS + o), new pc.Shader(e, { attributes: a, vshader: r, fshader: o, useTransformFeedback: s })
        }, t.createShaderFromCode = function(t, e, i, n, s) {
            const r = t.programLib._cache,
                o = r[n];
            if (void 0 !== o) return o;
            i = pc.programlib.precisionCode(t) + "\n" + (i || pc.programlib.dummyFragmentCode()), i = pc.ensureExtensionsInTheBeginning(i);
            const a = this.collectAttribs(e);
            return t.webgl2 && (e = pc.programlib.versionCode(t) + this.gles3VS + e, i = pc.programlib.versionCode(t) + this.gles3PS + i), r[n] = new pc.Shader(t, { attributes: a, vshader: e, fshader: i, useTransformFeedback: s }), r[n]
        }, { shaderChunks: t }
    }()), Object.assign(pc, function() {
        let t = null;
        const e = { type: pc.PRIMITIVE_TRISTRIP, base: 0, count: 4, indexed: !1 };
        return {
            drawQuadWithShader: function(i, n, s, r, o, a) {
                if (null === t) {
                    const e = new pc.VertexFormat(i, [{ semantic: pc.SEMANTIC_POSITION, components: 2, type: pc.TYPE_FLOAT32 }]);
                    t = new pc.VertexBuffer(i, e, 4);
                    const n = new pc.VertexIterator(t);
                    n.element[pc.SEMANTIC_POSITION].set(-1, -1), n.next(), n.element[pc.SEMANTIC_POSITION].set(1, -1), n.next(), n.element[pc.SEMANTIC_POSITION].set(-1, 1), n.next(), n.element[pc.SEMANTIC_POSITION].set(1, 1), n.end()
                }
                const c = i.renderTarget;
                let h, l, u, d, p, _, f, m;
                i.setRenderTarget(n), i.updateBegin(), r ? (h = r.x, l = r.y, u = r.z, d = r.w) : (u = n ? n.width : i.width, d = n ? n.height : i.height, h = 0, l = 0), o ? (p = o.x, _ = o.y, f = o.z, m = o.w) : (p = h, _ = l, f = u, m = d), i.setViewport(h, l, u, d), i.setScissor(p, _, f, m);
                const y = i.getDepthTest(),
                    g = i.getDepthWrite(),
                    E = i.getCullMode();
                i.setDepthTest(!1), i.setDepthWrite(!1), i.setCullMode(pc.CULLFACE_NONE), a || i.setBlending(!1), i.setVertexBuffer(t, 0), i.setShader(s), i.draw(e, 1, {}), i.setDepthTest(y), i.setDepthWrite(g), i.setCullMode(E), i.updateEnd(), i.setRenderTarget(c), i.updateBegin()
            }
        }
    }()), pc.shaderChunks.convolveLastMipOfCubemapPS = "#extension GL_EXT_shader_texture_lod : enable\nhighp vec4 sampleCubeLod(highp samplerCube sampler, highp vec3 coord, mediump float lod) {\n#if defined(GL_EXT_shader_texture_lod)\n    return textureCubeLodEXT( sampler, coord, lod );\n#else\n    return textureCube( sampler, coord, lod );\n#endif\n}\nuniform highp samplerCube _Cubemap_; \nuniform highp float _Level_; \nvoid main() { \n    // just sample all directions (+X, -X etc) and average the result\n    gl_FragColor = vec4(( \n        sampleCubeLod( _Cubemap_, vec3( 1.0, 0.0, 0.0 ),  _Level_ ) + \n        sampleCubeLod( _Cubemap_, vec3( -1.0, 0.0, 0.0 ), _Level_ ) + \n        sampleCubeLod( _Cubemap_, vec3( 0.0, 1.0, 0.0 ),  _Level_ ) + \n        sampleCubeLod( _Cubemap_, vec3( 0.0, -1.0, 0.0 ), _Level_ ) + \n        sampleCubeLod( _Cubemap_, vec3( 0.0, 0.0, 1.0 ),  _Level_ ) +\n        sampleCubeLod( _Cubemap_, vec3( 0.0, 0.0, -1.0 ), _Level_ ) \n    ) * 0.1666666667); \n}", pc.shaderChunks.convolveLastMipOfCubemapVS = "attribute vec2 vertex_position; \nvoid main() { \n    gl_Position = vec4( vertex_position, 0.5, 1.0 ); \n}", pc.shaderChunks.fullscreenQuadVS = "attribute vec2 vertex_position;\nvarying vec2 vUv0;\nvoid main(void)\n{\n    gl_Position = vec4(vertex_position, 0.5, 1.0);\n    vUv0 = vertex_position.xy*0.5+0.5;\n}\n", pc.shaderChunks.gles3PS = "#define varying in\nout highp vec4 pc_fragColor;\n#define gl_FragColor pc_fragColor\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad\n#define GL2\n", pc.shaderChunks.gles3VS = "#define attribute in\n#define varying out\n#define texture2D texture\n#define GL2\n#define VERTEXSHADER\n", pc.programlib = { precisionCode: function(t) { let e = "precision " + t.precision + " float;\n"; return t.webgl2 && (e += "#ifdef GL2\nprecision " + t.precision + " sampler2DShadow;\n#endif\n"), e }, versionCode: function(t) { return t.webgl2 ? "#version 300 es\n" : "" }, dummyFragmentCode: function() { return "void main(void) {gl_FragColor = vec4(0.0);}" }, begin: function() { return "void main(void)\n{\n" }, end: function() { return "}\n" } }, Object.assign(pc, { FOG_NONE: "none", FOG_LINEAR: "linear", FOG_EXP: "exp", FOG_EXP2: "exp2", LIGHTTYPE_DIRECTIONAL: 0, LIGHTTYPE_POINT: 1, LIGHTTYPE_SPOT: 2, SHADOW_PCF3: 0, SHADOW_DEPTH: 0, SHADOW_VSM8: 1, SHADOW_VSM16: 2, SHADOW_VSM32: 3, SHADOW_PCF5: 4, PROJECTION_PERSPECTIVE: 0, PROJECTION_ORTHOGRAPHIC: 1, SHADERDEF_NOSHADOW: 1, SHADERDEF_SKIN: 2, SHADERDEF_UV0: 4, SHADERDEF_UV1: 8, SHADERDEF_VCOLOR: 16, SHADERDEF_INSTANCING: 32, SHADERDEF_LM: 64, SHADERDEF_DIRLM: 128, SHADERDEF_SCREENSPACE: 256, SHADERDEF_TANGENTS: 512, SHADERDEF_LMUV0: 1024, SHADERDEF_LM_DLDR: 2048, SHADERDEF_LM_BAKED_AMBIENT: 4096, SHADERDEF_LIGHTPROBES: 8192, SHADERDEF_BLEND_REFLECTION_PROBES: 16384, SHADERDEF_RENDERTYPE_BACKGROUND: 32768, SHADERDEF_PARTICLES_INSTANCING: 65536, SHADERDEF_UI_MASK: 1 << 17, SHADERDEF_REVERT_STENCIL: 1 << 18, SHADERDEF_STENCIL_OVERRIDE: 1 << 19, MASK_DYNAMIC: 1, MASK_BAKED: 2, MASK_LIGHTMAP: 4, SORTKEY_FORWARD: 0, SORTKEY_DEPTH: 1, VIEW_CENTER: 0, VIEW_LEFT: 1, VIEW_RIGHT: 2, ASPECT_AUTO: 0, ASPECT_MANUAL: 1 }), Object.assign(pc, function() {
        const t = function() { this.root = null, this.meshInstancesCount = 0, this._meshInstances = new Array(1e3), this._renderers = new Set, this._cameras = [], this._lights = [], this._overlayScreensDirty = !1, this._overlayScreens = [], this._worldScreens = [], this.activeUiMasks = {}, this.dirtyEntities = new Set, this.events = new pc.Events(this) };
        return t.prototype.addDirty = function(t) { this.dirtyEntities.add(t) }, t.prototype.syncHierarchy = function(t) {
            const e = [...this.dirtyEntities];
            for (const t of e) t.syncHierarchy();
            this.dirtyEntities.clear()
        }, t.prototype.addRenderer = function(t) { this._renderers.add(t) }, t.prototype.removeRenderer = function(t) { this._renderers.delete(t) }, t.prototype.getMeshInstances = function() {
            for (let t = 0; t < this.meshInstancesCount; t++) this._meshInstances[t] = null;
            this.meshInstancesCount = 0;
            for (const t of this._renderers) {
                const e = t.getMeshInstancesForRender();
                for (let t = 0; t < e.length; t++) {
                    const i = e[t];
                    i.isIndexBufferEmpty && !i.isCanvas || (this._meshInstances.length === this.meshInstancesCount ? this._meshInstances.push(i) : this._meshInstances[this.meshInstancesCount] = i, this.meshInstancesCount++)
                }
            }
            return this._meshInstances
        }, t.prototype.getMeshInstancesCached = function() { return this._meshInstances }, t.prototype.addCamera = function(t) { this._cameras.includes(t) || this._cameras.push(t) }, t.prototype.removeCamera = function(t) { this._cameras.splice(this._cameras.indexOf(t), 1) }, t.prototype.addLight = function(t) { this._lights.includes(t) || this._lights.push(t) }, t.prototype.removeLight = function(t) { this._lights.splice(this._lights.indexOf(t), 1) }, t.prototype.addScreen = function(t) {
            const e = t.screenType === pc.SCREEN_TYPE_SCREEN ? this._overlayScreens : this._worldScreens;
            e.includes(t) || (e.push(t), e === this._overlayScreens && (this._overlayScreensDirty = !0))
        }, t.prototype.removeScreen = function(t) {
            const e = t.screenType === pc.SCREEN_TYPE_SCREEN ? this._overlayScreens : this._worldScreens;
            e.includes(t) && e.splice(e.indexOf(t), 1)
        }, Object.defineProperty(t.prototype, "overlayScreens", { get: function() { return this._overlayScreensDirty && (this._overlayScreensDirty = !1, this._overlayScreens.sort(pc.SortUtils.sortOverlayCanvases)), this._overlayScreens } }), Object.defineProperty(t.prototype, "worldScreens", { get: function() { return this._worldScreens } }), { Scene: t }
    }()), pc.extend(pc, function() {
        const t = /void\s+main\s*\(\s*(void)?\s*\)\s*{/,
            e = "attribute\\s+(highp\\s*|lowp\\s*|mediump\\s*)?vec[2|3|4]\\s+",
            i = /\s*vec(2|3|4)\s*/,
            n = "\\s*;",
            s = /uniform mat4 matrix_viewProjection;/,
            r = /texture2D\s*\(\s*unity_Lightmap\s*,/,
            o = "  ",
            a = "attribute vec4 vertex_boneWeights;\nattribute vec4 vertex_boneIndices;\nmat4 skinnedMatrix;\n\nmat4 getSkinnedModelMatrix() {\n    return (\n    getBoneMatrix( vertex_boneIndices.x ) * vertex_boneWeights.x +\n    getBoneMatrix( vertex_boneIndices.y ) * vertex_boneWeights.y +\n    getBoneMatrix( vertex_boneIndices.z ) * vertex_boneWeights.z +\n    getBoneMatrix( vertex_boneIndices.w ) * vertex_boneWeights.w );\n}\n\nvec4 get_POSITION( vec4 pos )\n{\n    return skinnedMatrix * pos;\n}\n\nvec4 get_NORMAL( vec4 normal )\n{\n    return skinnedMatrix * normal;\n}\n\nvec4 get_TANGENT( vec4 tangent )\n{\n    return skinnedMatrix * tangent;\n}\n",
            c = function(t, e, i, n) { return t.substring(0, e) + n + t.substring(e + i) },
            h = function(t, e, i, n) {
                let s = t,
                    r = e[0].search(i);
                return r += e.index, s = c(s, r, i.length, n), s
            },
            l = function(t, e) { let i = t; return i = c(i, e.index, e[0].length, ""), i },
            u = function(t, s, r, a, c) {
                let l = t;
                const u = new RegExp(e + r + n),
                    d = l.match(u);
                if (null != d) {
                    const t = d[0].match(i)[0].trim();
                    l = h(l, d, "attribute", "");
                    const e = "_patched_" + s;
                    if (c.defines += "attribute " + t + " " + e + ";\n", "vec4" === t) c.main += o + r + " = get_" + s + "( " + e + " );\n";
                    else {
                        let i = "",
                            n = "";
                        "vec2" === t ? (i = ".xy", n = ", 0, 0") : "vec3" === t && (i = ".xyz", n = ", 0"), c.main += o + r + " = get_" + s + "( vec4( " + e + n + ") )" + i + ";\n"
                    }
                }
                return l
            },
            d = function(t, i, s) { let r = null; for (const o in i) { if (i[o] !== s) continue; const a = new RegExp(e + o + n); if (null != t.match(a)) { r = o; break } } return r },
            p = function(t, e, i, n) {
                let s = t;
                for (let t = 0; t < e.length; t++) {
                    const r = e[t],
                        o = d(s, i, r);
                    if (null !== o) { s = u(s, r, o, 0, n) }
                }
                return s
            },
            _ = function(t, e) {
                const i = t.match("\\s*#version [0-9]+\\s*");
                if (null == i) return t;
                const n = i[0].trim(),
                    s = l(t, i);
                return e.defines = n + "\n\n" + e.defines, s
            };

        function f(t, e) { this.baseShader = t, this.patchShader = e, this.defines = "", this.main = "", this.getMain = function() { return "void main() {\n" + this.main + "  _main(); // Initial main function call\n}\n" }, this.combine = function() { return "\n// Patched defines\n" + this.defines + "\n// Patch shader\n" + this.patchShader + "\n\n// Base shader\n" + this.baseShader + "\n\n// Partched main\n" + this.getMain() } }
        const m = /^#extension.*$/gm;
        return {
            ShaderPatches: {
                patchParticlesVertexShader: function(e, i) {
                    const n = new f(e, "// Instancing attributes\nattribute vec3 instancing_translation;\nattribute vec4 instancing_rotation;\nattribute vec3 instancing_scale;\nattribute vec4 instancing_color;\nattribute vec4 instancing_st;\n\n// Uniforms\nuniform highp mat4 matrix_viewInverse;\nuniform highp mat4 matrix_viewProjection;\nuniform highp mat4 matrix_modelRotation;\nuniform highp mat4 matrix_modelTranslation;\nuniform highp mat4 matrix_modelRotationInverse;\nuniform highp vec3 system_scale;\nuniform int renderer_alignment;\nuniform float worldSimulationSpace;\n\n// Quaternion multiplication\n// http://mathworld.wolfram.com/Quaternion.html\nvec4 quaternion_multiply( vec4 lhs, vec4 rhs ) {\n    return vec4(\n    rhs.xyz * lhs.w + lhs.xyz * rhs.w + cross( lhs.xyz, rhs.xyz ),\n    lhs.w * rhs.w - dot( lhs.xyz, rhs.xyz )\n    );\n}\n\n// Vector rotation with a quaternion\n// http://mathworld.wolfram.com/Quaternion.html\nvec3 quaternion_rotate_vector( vec3 vector, vec4 quaternion ) {\n    vec4 quaternion_conjugate = quaternion * vec4( -1, -1, -1, 1 );\n    return quaternion_multiply( quaternion, quaternion_multiply( vec4( vector, 0 ), quaternion_conjugate ) ).xyz;\n}\n\nmat4 transpose( mat4 m ) {\n    return mat4(\n    m[ 0 ][ 0 ], m[ 1 ][ 0 ], m[ 2 ][ 0 ], m[ 3 ][ 0 ],\n    m[ 0 ][ 1 ], m[ 1 ][ 1 ], m[ 2 ][ 1 ], m[ 3 ][ 1 ],\n    m[ 0 ][ 2 ], m[ 1 ][ 2 ], m[ 2 ][ 2 ], m[ 3 ][ 2 ],\n    m[ 0 ][ 3 ], m[ 1 ][ 3 ], m[ 2 ][ 3 ], m[ 3 ][ 3 ]);\n}\n\nmat4 getFacingAlignmentRotation( vec4 particlePosition ) {\n    vec3 eye = matrix_viewInverse[ 3 ].xyz;\n    vec3 pivot = particlePosition.xyz;\n\n    // Find desired rotation between two vectors\n    vec4 cameraZ = vec4( normalize( pivot - eye ), 0 );\n    vec4 cameraY = matrix_viewInverse * vec4( 0, 1, 0, 0 );\n    vec4 cameraX = vec4( cross(cameraY.xyz, cameraZ.xyz), 0 );\n    cameraY = vec4( cross(cameraZ.xyz, cameraX.xyz), 0 );\n\n    mat4 extraRotation = mat4( 0.0 );\n    extraRotation[ 0 ] = cameraX;\n    extraRotation[ 1 ] = cameraY;\n    extraRotation[ 2 ] = cameraZ;\n    extraRotation[ 3 ][ 3 ] = 1.0;\n\n    return extraRotation;\n}\n\n// Applies rotation, then scale, then translate to the\n// vertex coordinates.\n\n#define VIEW_ALIGNMENT      0\n#define WORLD_ALIGNMENT     1\n#define LOCAL_ALIGNMENT     2\n#define FACING_ALIGNMENT    3\n\nmat4 alignment_rotation;\nmat4 simulationSpace_rotation;\nmat4 simulationSpace_translation;\n\nvec4 transform_vertex( vec4 vertex, mat4 matrix_scale ) {\n    vec4 v = matrix_scale * vertex;\n    v = vec4( quaternion_rotate_vector( v.xyz, instancing_rotation ), 1.0 );\n    v = alignment_rotation * v;\n\n    v += vec4( instancing_translation, 0 );\n\n    v = simulationSpace_rotation * v;\n    v = simulationSpace_translation * v;\n\n    return v;\n}\n\n\nvec4 get_POSITION( vec4 position ) {\n    if ( worldSimulationSpace > 0.0 ) {\n        simulationSpace_rotation = mat4( 1.0 );\n        simulationSpace_translation = mat4( 1.0 );\n    } else {\n        simulationSpace_rotation = matrix_modelRotation;\n        simulationSpace_translation = mat4( 1.0 );\n        simulationSpace_translation[ 3 ] = matrix_modelTranslation[ 3 ];\n    }\n\n    if ( LOCAL_ALIGNMENT == renderer_alignment ) {\n        // local alignment means rotation starts with hierarchy rotation\n        alignment_rotation = matrix_modelRotation;\n    } else if ( WORLD_ALIGNMENT ==  renderer_alignment ) {\n        // world alignment means rotation starts with E\n        alignment_rotation = mat4( 1.0 );\n    } else if ( ( VIEW_ALIGNMENT == renderer_alignment ) || ( FACING_ALIGNMENT == renderer_alignment ) ) {\n        // view alignment means rotation starts with camera rotation\n        // Assume scales are 0\n        alignment_rotation = matrix_viewInverse;\n        alignment_rotation[ 3 ] = vec4( 0, 0, 0, 1 );\n    }\n\n    alignment_rotation = transpose( simulationSpace_rotation ) * alignment_rotation;\n\n    mat4 scale;\n    scale[ 0 ] = vec4( system_scale.x * instancing_scale.x, 0, 0, 0 );\n    scale[ 1 ] = vec4( 0, system_scale.y * instancing_scale.y, 0, 0 );\n    scale[ 2 ] = vec4( 0, 0, system_scale.z * instancing_scale.z, 0 );\n    scale[ 3 ] = vec4( 0, 0, 0, 1 );\n\n    vec4 vertex = vec4( position.xyz, 1 );\n    vec4 vertexPosition = transform_vertex( vertex, scale );\n\n    if ( FACING_ALIGNMENT == renderer_alignment ) {\n        vec4 pivot_vertex = vec4( 0, 0, 0, 1 );\n        vec4 pivot = transform_vertex( pivot_vertex, scale );\n\n        alignment_rotation = transpose( simulationSpace_rotation ) * getFacingAlignmentRotation( pivot );\n        vertexPosition = transform_vertex( vertex, scale );\n    }\n\n    return vertexPosition;\n}\n\nvec4 get_COLOR( vec4 color ) {\n    return color * instancing_color;\n}\n\nvec4 get_TEXCOORD0( vec4 texcoord ) {\n    return vec4( ( texcoord.xy + instancing_st.zw ) * instancing_st.xy, texcoord.zw );\n}\n\nvec4 get_NORMAL( vec4 normal ) {\n    normal = vec4( quaternion_rotate_vector( normal.xyz, instancing_rotation ), 0 );\n    normal = alignment_rotation * normal;\n    normal = simulationSpace_rotation * normal;\n    return normal;\n}\n\nvec4 get_TANGENT( vec4 tangent ) {\n    tangent = vec4( quaternion_rotate_vector( tangent.xyz, instancing_rotation ), 0 );\n    tangent = alignment_rotation * tangent;\n    tangent = simulationSpace_rotation * tangent;\n    return tangent;\n}");
                    n.baseShader = function(t) {
                        const e = new RegExp(s),
                            i = t.match(e);
                        return null === i ? t : l(t, i)
                    }(n.baseShader);
                    const r = [pc.SEMANTIC_POSITION, pc.SEMANTIC_COLOR, pc.SEMANTIC_TEXCOORD0, pc.SEMANTIC_NORMAL, pc.SEMANTIC_TANGENT];
                    n.baseShader = _(n.baseShader, n), n.baseShader = p(n.baseShader, r, i, n);
                    const o = new RegExp(t),
                        a = n.baseShader.match(o);
                    if (null === a) return console.error("Shader patching error. Main function not found\n" + e), null;
                    n.baseShader = h(n.baseShader, a, "main", "_main");
                    return n.combine()
                },
                patchSkinningVertexShader: function(e, i) {
                    const n = pc.Application.getApplication().graphicsDevice;
                    let s;
                    n.supportsBoneTextures ? s = new f(e, "uniform sampler2D texture_poseMap;\nuniform vec2 texture_poseMapSize;\nmat4 getBoneMatrix(const in float i)\n{\n    float j = i * 4.0;\n    float x = mod(j, float(texture_poseMapSize.x));\n    float y = floor(j / float(texture_poseMapSize.x));\n    float dx = 1.0 / float(texture_poseMapSize.x);\n    float dy = 1.0 / float(texture_poseMapSize.y);\n    y = dy * (y + 0.5);\n    vec4 v1 = texture2D(texture_poseMap, vec2(dx * (x + 0.5), y));\n    vec4 v2 = texture2D(texture_poseMap, vec2(dx * (x + 1.5), y));\n    vec4 v3 = texture2D(texture_poseMap, vec2(dx * (x + 2.5), y));\n    vec4 v4 = texture2D(texture_poseMap, vec2(dx * (x + 3.5), y));\n    mat4 bone = mat4(v1, v2, v3, v4);\n    return bone;\n}\n\n" + a) : (s = new f(e, "// #define BONE_LIMIT 128 // will be added in code\nuniform mat4 matrix_pose[BONE_LIMIT];\nmat4 getBoneMatrix(const in float i) {\n    mat4 bone = matrix_pose[int(i)];\n    return bone;\n}\n\n" + a), s.defines += "#define BONE_LIMIT " + n.getBoneLimit() + "\n"), s.main += "  skinnedMatrix = getSkinnedModelMatrix();\n";
                    const r = [pc.SEMANTIC_POSITION, pc.SEMANTIC_NORMAL, pc.SEMANTIC_TANGENT];
                    s.baseShader = _(s.baseShader, s), s.baseShader = p(s.baseShader, r, i, s);
                    const o = new RegExp(t),
                        c = s.baseShader.match(o);
                    if (null === c) return console.error("Shader patching error. Main function not found\n" + e), null;
                    s.baseShader = h(s.baseShader, c, "main", "_main");
                    let l = s.combine();
                    const u = "vec3 _patched_POSITION;",
                        d = new RegExp(u);
                    return s.defines.match(d) && (l = l.replace(u, "vec4 _patched_POSITION;"), l = l.replace("vec4( _patched_POSITION, 0)", "_patched_POSITION")), l
                },
                patchTexture2DLightmap: function(e) {
                    const i = new RegExp(r),
                        n = e.match(i);
                    if (!n) return e;
                    return e = function(e, i) { const n = e.match(t); return null == n ? e : (s = e, r = n.index, o = i, s.substring(0, r) + o + s.substring(r)); var s, r, o }(e = h(e, n, "texture2D", "texture2D_LM"), "// Patched method to support RGBm decoding\nuniform mediump vec4 unity_Lightmap_HDR;\nmediump vec4 texture2D_LM( sampler2D texture, mediump vec2 uv ) {\n    mediump vec4 rgbmColor = texture2D( texture, uv );    mediump vec4 color = vec4( rgbmColor.rgb * ( rgbmColor.w * unity_Lightmap_HDR.x ), rgbmColor.w );    return color;\n}\n\n")
                }
            },
            ensureExtensionsInTheBeginning: function(t) {
                const e = new RegExp(m),
                    i = t.match(e);
                return i ? (t = t.replace(e, ""), t = i[0] + "\n" + t) : t
            },
            _createMissingShader: function(t, e) { console.error('Shader "' + t + '" with id #' + e + " is replaced as missing shader."); return new pc.Shader(pc.Application.getApplication().graphicsDevice, { attributes: { _glesVertex: pc.SEMANTIC_POSITION, _glesNormal: pc.SEMANTIC_NORMAL, _glesTangent: pc.SEMANTIC_TANGENT, _glesMultiTexCoord0: pc.SEMANTIC_TEXCOORD0, _glesMultiTexCoord1: pc.SEMANTIC_TEXCOORD1, _glesMultiTexCoord2: pc.SEMANTIC_TEXCOORD2, _glesMultiTexCoord3: pc.SEMANTIC_TEXCOORD3, _glesColor: pc.SEMANTIC_COLOR }, vshader: "// This is a VP stub for shader #" + e + " \n attribute vec3 _glesVertex; varying highp vec2 xlv_TEXCOORD0; uniform mat4 matrix_model;\nuniform mat4 matrix_viewProjection;\nvoid main() { gl_Position = matrix_viewProjection * matrix_model * vec4(_glesVertex, 1.0); }", fshader: "// This is a FP stub for shader #" + e + " \n uniform sampler2D _MainTex; void main(void) { gl_FragColor = vec4(1, 0, 0.5, 1); }" }) }
        }
    }()), pc.extend(pc, {
        SortUtils: {
            genericSort: function(t, e, i) {
                const n = t._material,
                    s = e._material;
                if (!n || !s) return 0;
                if (n.renderQueue !== s.renderQueue) return n.renderQueue - s.renderQueue;
                if (t.sortingLayerIndex !== e.sortingLayerIndex) return t.sortingLayerIndex - e.sortingLayerIndex;
                if (t.sortingOrder !== e.sortingOrder) return t.sortingOrder - e.sortingOrder;
                if (t.drawOrder !== e.drawOrder) return t.drawOrder - e.drawOrder;
                const r = n.renderQueue > 2500 ? -1 : 1;
                return t.zdist && e.zdist && t.zdist !== e.zdist ? (t.zdist - e.zdist) * r : n.id !== s.id ? n.id - s.id : t.mesh.id - e.mesh.id
            },
            uiElementsSort: function(t, e, i) { return t.drawOrder - e.drawOrder },
            calculateSortDistances: function(t, e, i) {
                for (let n = 0; n < t.length; n++) {
                    const s = t[n];
                    if (s.command) continue;
                    const r = s.aabb.center;
                    s.zdist = (r.x - e.x) * i.x + (r.y - e.y) * i.y + (r.z - e.z) * i.z
                }
            },
            cameraCompare: function(t, e) { return t.priority - e.priority },
            sortOverlayCanvases: function(t, e) { return t.sortingOrder !== e.sortingOrder ? t.sortingOrder - e.sortingOrder : t.$id - e.$id }
        }
    }), pc.extend(pc, function() {
        let t = 3;
        const e = [pc.STENCILOP_KEEP, pc.STENCILOP_ZERO, pc.STENCILOP_REPLACE, pc.STENCILOP_INCREMENT, pc.STENCILOP_INCREMENT, pc.STENCILOP_DECREMENT, pc.STENCILOP_INVERT, pc.STENCILOP_INCREMENTWRAP, pc.STENCILOP_DECREMENTWRAP],
            i = [pc.CULLFACE_NONE, pc.CULLFACE_FRONT, pc.CULLFACE_BACK],
            n = [pc.BLENDMODE_ZERO, pc.BLENDMODE_ONE, pc.BLENDMODE_DST_COLOR, pc.BLENDMODE_SRC_COLOR, pc.BLENDMODE_ONE_MINUS_DST_COLOR, pc.BLENDMODE_SRC_ALPHA, pc.BLENDMODE_ONE_MINUS_SRC_COLOR, pc.BLENDMODE_DST_ALPHA, pc.BLENDMODE_ONE_MINUS_DST_ALPHA, pc.BLENDMODE_SRC_ALPHA_SATURATE, pc.BLENDMODE_ONE_MINUS_SRC_ALPHA],
            s = function(t, e) { return e._priority - t._priority },
            r = new pc.Vec3,
            o = [];
        return {
            RenderingUtils: {
                opacityMapChannelIDs: { r: 1, g: 2, b: 3, a: 4 },
                getLightsData: function(e, i, n) {
                    if (n.reset(), o.length = 0, 0 === i.length) return;
                    let a = -1;
                    const c = e.node,
                        h = 1 << c.cullingLayer,
                        l = c.getPosition(),
                        u = e.aabb,
                        d = u.getMax(),
                        p = u.getMin(),
                        _ = (d.x - p.x) * (d.y - p.y) * (d.z - p.z);
                    t = UnityEngine.RenderSettings._pixelLightCount;
                    for (let t = 0; t < i.length; t++) {
                        const e = i[t];
                        if (0 == (e._cullingMask & h)) continue;
                        if (0 == (e._mask & pc.MASK_DYNAMIC)) continue;
                        const s = e._aabb.getMax(),
                            c = e._aabb.getMin();
                        let f = Math.max(0, Math.min(d.x, s.x) - Math.max(p.x, c.x)) * Math.max(0, Math.min(d.y, s.y) - Math.max(p.y, c.y)) * Math.max(0, Math.min(d.z, s.z) - Math.max(p.z, c.z));
                        if (0 === _) f = e._aabb.intersects(u) ? 1 : 0;
                        else if (f <= 0) continue;
                        if (e._type === pc.LIGHTTYPE_DIRECTIONAL && !e._cookie && e._renderMode !== UnityEngine.LightRenderMode.ForceVertex) {
                            const t = n.mainLight;
                            (null === t || t._luminance < e._luminance || t._luminance === e._luminance && e._renderMode === UnityEngine.LightRenderMode.ForcePixel && t._renderMode !== UnityEngine.LightRenderMode.ForcePixel) && (n.mainLight = e)
                        }
                        if (e._effectiveLuminance = e._luminance, e._type !== pc.LIGHTTYPE_DIRECTIONAL) {
                            r.sub2(e._position, l), e._directionToLight.copy(r);
                            const t = r.length() / e.attenuationEnd;
                            e._effectiveLuminance *= pc.math.clamp(1 / (1 + 25 * t * t) * pc.math.clamp(5 * (1 - t), 0, 1), 0, 1), e._range = t
                        }
                        o.push(e), e === n.mainLight && (a = o.length - 1), e._priority = f / (0 === _ ? 1 : _), e._renderMode === UnityEngine.LightRenderMode.ForcePixel && (e._priority += 1e4), e._renderMode === UnityEngine.LightRenderMode.Auto && (e._priority += 100)
                    }
                    a >= 0 && (o[a] = o[o.length - 1], o.length -= 1), o.sort(s);
                    let f = 0;
                    for (f = 0; f < o.length; f++) {
                        const e = o[f];
                        if (n.pixelLights.length >= t) break;
                        if (e._renderMode === UnityEngine.LightRenderMode.ForceVertex) break;
                        n.pixelLights.push(e)
                    }
                    for (; f < o.length; f++) {
                        const t = o[f];
                        if (!(t._effectiveLuminance < 1e-4)) {
                            if (n.vertexLights.length >= 4) break;
                            t._type === pc.LIGHTTYPE_DIRECTIONAL ? n.otherLights.push(t) : n.vertexLights.push(t)
                        }
                    }
                    for (; f < o.length; f++) n.otherLights.push(o[f]);
                    n.combineAllLights()
                },
                unityCompareFunctionToPlaycanvas: function(t) { return t - 1 },
                unityStencilOpToPlaycanvas: function(t) { return e[t] },
                unityBlendModeToPlaycanvas: function(t) { return n[t] },
                unityCullModeToPlaycanvas: function(t) { return i[t] },
                unityBlendOpToPlaycanvas: function(t) { return t <= UnityEngine.Rendering.BlendOp.Max ? t : null }
            }
        }
    }()), pc.extend(pc, function() {
        const t = { radius: null, center: null },
            e = function(e, i, n) { return t.center = i.center, t.radius = i.halfExtents.length(), e.containsSphere(t, n) };
        return {
            Culling: {
                cull: function(t, i, n, s) {
                    let r = 0,
                        o = 0;
                    const a = void 0 === t.cullingMask ? 4294967295 : t.cullingMask,
                        c = [],
                        h = t.frustum;
                    for (let t = 0; t < n; t++) {
                        const e = i[t],
                            n = !0;
                        if (e.material && (e._mesh._refCount !== -1 / 0 && e.visible))
                            if (!e.command && e.cull) {
                                if (n) {
                                    const t = e.node.cullingLayer || 0,
                                        i = 1 << t;
                                    if (t < 0) continue;
                                    if (0 == (i & a)) continue
                                }
                                c[o++] = e, e.visibleThisFrame = !0
                            } else c[o++] = e, e.visibleThisFrame = !0
                    }
                    for (let i = 0; i < c.length; i++) {
                        const n = c[i];
                        let o = !0;
                        n.cull && (o = t._component.layerCullDistancesActivated ? e(h, n.aabb, t._component.layerCullDistances[n.node.cullingLayer]) : e(h, n.aabb)), o ? (s[r++] = n, n.visibleThisFrame = !0) : n.visibleThisFrame = !1
                    }
                    return r
                },
                cullUi: function(t, i, n) {
                    let s = 0,
                        r = 0;
                    const o = i.length,
                        a = [],
                        c = t.frustum;
                    for (let t = 0; t < o; t++) {
                        const e = i[t];
                        e && (e.material && (e._mesh && e._mesh._refCount === -1 / 0 || e.visible && (!e.command && e.cull, a[r++] = e, e.visibleThisFrame = !0)))
                    }
                    for (let t = 0; t < a.length; t++) {
                        const i = a[t];
                        let r = !0;
                        const o = !i._nearestScreen;
                        i.cull && o && (r = e(c, i.aabb)), r ? (n[s++] = i, i.visibleThisFrame = !0) : i.visibleThisFrame = !1
                    }
                    return s
                },
                reset: function(t, e) { for (let i = 0; i < e; i++) t[i].visibleThisFrame = !1 },
                isAABBVisibleInFrustum: e
            }
        }
    }()), pc.extend(pc, function() {
        const t = new pc.Vec3,
            e = function() { this.mainLight = null, this.pixelLights = [], this.vertexLights = [], this.otherLights = [], this.allLights = [] };
        return Object.assign(e.prototype, {
            reset: function() { this.mainLight = null, this.pixelLights.length = 0, this.vertexLights.length = 0, this.otherLights.length = 0, this.allLights.length = 0 },
            addOtherLights: function(e) {
                for (let i = 0; i < this.otherLights.length; i++) {
                    const n = this.otherLights[i];
                    t.copy(n._directionToLight), n._type === pc.LIGHTTYPE_DIRECTIONAL ? e.addDirectionalLight(t, n._color, n._intensity, 1) : n._type === pc.LIGHTTYPE_POINT && e.addPointLight(t, n._color, n._intensity, n.attenuationEnd), n._type === pc.LIGHTTYPE_SPOT && e.addSpotLight(t, n._color, n._intensity, n.attenuationEnd, n._outerConeAngle)
                }
            },
            combineAllLights: function() { this.allLights.length = 0, this.mainLight && this.allLights.push(this.mainLight); for (let t = 0; t < this.pixelLights.length; t++) this.allLights.push(this.pixelLights[t]); for (let t = 0; t < this.vertexLights.length; t++) this.allLights.push(this.vertexLights[t]); for (let t = 0; t < this.otherLights.length; t++) this.allLights.push(this.otherLights[t]) },
            toString: function() { return "{ " + (this.mainLight ? this.mainLight._node.name : "<NONE>") + ", Pixel = [" + this.pixelLights.map((t => t._node.name)).join(", ") + "], Vertex = [" + this.vertexLights.map((t => t._node.name)).join(", ") + "], SH = [" + this.otherLights.map((t => t._node.name)).join(", ") + "] }" }
        }), { LightData: e }
    }()), pc.extend(pc, function() {
        const t = new pc.LightData,
            e = new pc.KeywordSet,
            i = new pc.SphericalHarmonicsL2,
            n = new Float32Array([0, 0, 0, 0]),
            s = new Float32Array(4),
            r = new Float32Array(4),
            o = new Float32Array(4),
            a = new Float32Array(4),
            c = new Float32Array(4),
            h = new Float32Array(16),
            l = new Float32Array(16),
            u = new Float32Array(4),
            d = new Float32Array(4),
            p = new pc.KeywordSet,
            _ = [],
            f = [],
            m = [],
            y = [],
            g = [],
            E = [],
            A = {};
        let b = {},
            C = {},
            T = null,
            S = !1;
        return {
            BuiltInForwardRenderer: {
                renderMeshInstance: function(t, e, i, n, s) {
                    const r = this.device,
                        o = n.material,
                        a = n.mesh,
                        c = (n._shaderDefs & pc.SHADERDEF_LM) > 0;
                    if (T = i, !o || 0 === n.mesh.primitive.count) return;
                    o.getPass(pc.SHADER_PASS_ALWAYS, _), o.getPass(pc.SHADER_PASS_FORWARD_BASE, f), o.getPass(pc.SHADER_PASS_FORWARD_ADD, m), o.getPass(pc.SHADER_PASS_VERTEX, y), o.getPass(pc.SHADER_PASS_VERTEX_LM, g), o.getPass(pc.SHADER_PASS_GRAB_PASS, E);
                    const h = f.length > 0 || m.length,
                        l = y.length > 0;
                    if (0 !== _.length || !h || !l) {
                        for (let t = 0; t < E.length; t++) {
                            const e = E[t];
                            C[e.grabPassTextureName] = e, S = !0
                        }
                        c && n.configureLightmap(), d[0] = this.device.sx, d[1] = this.device.sy, d[2] = this.device.sw, d[3] = this.device.sh, r.setVertexBuffer(n.morphInstance && n.morphInstance._vertexBuffer ? n.morphInstance._vertexBuffer : a.vertexBuffer, 0), r.setIndexBuffer(a.indexBuffer[0]), this.setSkinning(r, n, o), this.setMaterial(r, o), this.pushUniforms(r, n.parameters), this.setDrawCall(r, n), r.setDepthRange((n._shaderDefs & pc.SHADERDEF_RENDERTYPE_BACKGROUND) > 0 ? 1 : 0, 1), t.merge(o.keywords), c && t.enableKeywordId(pc.Keywords.LIGHTMAP_ON), (n._shaderDefs & pc.SHADERDEF_DIRLM) > 0 && t.enableKeywordId(pc.Keywords.DIRLIGHTMAP_COMBINED);
                        for (let e = 0; e < _.length; e++) {
                            const i = _[e];
                            this.renderMeshInstancePass(i, t, n)
                        }
                        if (!h && !l) return this.popUniforms(r, n.parameters), void this.setDrawCall(r, null);
                        h ? this.drawForwardPasses(f, m, n, s, t, c, e, i) : this.drawVertexPasses(y, g, n, s, t, c, e, i), this.restoreScissorTest(), this.popUniforms(r, n.parameters), this.setDrawCall(r, null)
                    }
                },
                drawForwardPasses: function(n, s, r, o, a, c, h, l) {
                    pc.RenderingUtils.getLightsData(r, o, t), e.copy(a), !c && h ? i.copy(h) : i.clear(), t.addOtherLights(i), this.dispatchLightProbe(i, e, c), this.dispatchVertexLights(t.vertexLights, e), this.dispatchMainLight(l, t.mainLight, e), this.renderMeshInstancePasses(n, e, r);
                    for (let i = 0; i < t.pixelLights.length; i++) {
                        const n = t.pixelLights[i];
                        e.copy(a), this.dispatchMainLight(l, n, e), this.renderMeshInstancePasses(s, e, r)
                    }
                },
                drawVertexPasses: function(i, n, s, r, o, a, c, h) {
                    pc.RenderingUtils.getLightsData(s, r, t), e.copy(o), this.dispatchVertexLights(t.allLights, e);
                    const l = a ? n : i;
                    this.renderMeshInstancePasses(l, e, s)
                },
                renderMeshInstancePasses: function(t, e, i) {
                    for (let n = 0; n < t.length; n++) {
                        const s = t[n];
                        this.renderMeshInstancePass(s, e, i)
                    }
                },
                renderGrabPass: function(t, e) {
                    const i = this.device,
                        n = e.grabPassTextureName,
                        s = this.initializeGrabPassTexture(t, n);
                    i.setTexture(s, 0), i.gl.copyTexSubImage2D(i.gl.TEXTURE_2D, 0, 0, 0, 0, 0, s._width, s._height), i.scope.resolve(n).setValue(s)
                },
                initializeGrabPassTexture: function(t, e) { let i = A[e]; const n = t ? t._screenParams : [this.device.width, this.device.height]; return i && i._width === n[0] && i._height === n[1] || (i = new pc.Texture(this, { format: pc.PIXELFORMAT_R8_G8_B8, autoMipmap: !0, mipmaps: !1, width: n[0], height: n[1], minFilter: pc.FILTER_LINEAR, magFilter: pc.FILTER_LINEAR, addressU: pc.ADDRESS_CLAMP_TO_EDGE, addressV: pc.ADDRESS_CLAMP_TO_EDGE, levels: [null] }), this.device.initializeTexture(i), A[e] = i), i },
                restoreScissorTest: function() { this.device.setScissor(d[0], d[1], d[2], d[3]) },
                dispatchMainLight: function(t, e, i) { e ? (n.set(e._finalColor), e._type === pc.LIGHTTYPE_DIRECTIONAL ? (s[0] = e._directionToLight.x, s[1] = e._directionToLight.y, s[2] = e._directionToLight.z, s[3] = 0) : (s[0] = e._position.x, s[1] = e._position.y, s[2] = e._position.z, s[3] = 1), this.lightIds.matrix.setValue(e._worldToLightMatrix.data)) : (n[0] = 0, n[1] = 0, n[2] = 0, n[3] = 0, s[0] = 0, s[1] = 0, s[2] = 0, s[3] = 0), this.lightIds.color.setValue(n), this.lightIds.position.setValue(s), e && e._type === pc.LIGHTTYPE_POINT ? e._cookie ? (i.enableKeywordId(pc.Keywords.POINT_COOKIE), this.lightIds.attenuationTexture.setValue(e._cookie || UnityEngine.Texture2D.spotTexture.handle), this.lightIds.fallOffTexture.setValue(UnityEngine.Texture2D.attenuationTexture.handle)) : (i.enableKeywordId(pc.Keywords.POINT), this.lightIds.attenuationTexture.setValue(UnityEngine.Texture2D.attenuationTexture.handle)) : e && e._type === pc.LIGHTTYPE_SPOT ? (i.enableKeywordId(pc.Keywords.SPOT), this.lightIds.attenuationTexture.setValue(e._cookie || UnityEngine.Texture2D.spotTexture.handle), this.lightIds.fallOffTexture.setValue(UnityEngine.Texture2D.attenuationTexture.handle)) : e && e._cookie ? (i.enableKeywordId(pc.Keywords.DIRECTIONAL_COOKIE), this.lightIds.attenuationTexture.setValue(e._cookie)) : i.enableKeywordId(pc.Keywords.DIRECTIONAL) },
                dispatchVertexLights: function(t, e) {
                    if (0 === t.length) e.disableKeywordId(pc.Keywords.VERTEXLIGHT_ON);
                    else {
                        e.enableKeywordId(pc.Keywords.VERTEXLIGHT_ON);
                        for (let e = 0; e < 4; e++)
                            if (e < t.length) {
                                const i = t[e],
                                    n = i._type === pc.LIGHTTYPE_DIRECTIONAL ? i._directionToLight : i._position,
                                    s = i._finalColor,
                                    u = i._range;
                                r[e] = n.x, o[e] = n.y, a[e] = n.z, h[4 * e + 0] = s[0], h[4 * e + 1] = s[1], h[4 * e + 2] = s[2], h[4 * e + 3] = s[3], l[4 * e + 0] = n.x, l[4 * e + 1] = n.y, l[4 * e + 2] = -n.z, l[4 * e + 3] = i._type === pc.LIGHTTYPE_DIRECTIONAL ? 0 : 1, c[e] = 25 / (u * u)
                            } else r[e] = 0, o[e] = 0, a[e] = 0, h[4 * e + 0] = 0, h[4 * e + 1] = 0, h[4 * e + 2] = 0, h[4 * e + 3] = 0, l[4 * e + 0] = 0, l[4 * e + 1] = 0, l[4 * e + 2] = 0, l[4 * e + 3] = 0, c[e] = 0;
                        this.lightIds.vertexX.setValue(r), this.lightIds.vertexY.setValue(o), this.lightIds.vertexZ.setValue(a), this.lightIds.vertexAttenuation.setValue(c), this.lightIds.vertexLightColors.setValue(h), this.lightIds.vertexLightPositions.setValue(l)
                    }
                },
                dispatchLightProbe: function(t, e, i) {
                    if (i) e.disableKeywordId(pc.Keywords.LIGHTPROBE_SH);
                    else { e.enableKeywordId(pc.Keywords.LIGHTPROBE_SH), t.updateUniforms(); for (let e = 0; e < this.unityIds.lightProbeIds.length; e++) this.unityIds.lightProbeIds[e].setValue(t.uniforms[e]._data) }
                },
                renderMeshInstancePass: function(t, e, i) {
                    const n = this.device,
                        s = i.material,
                        r = i.mesh;
                    if (!r || !r.indexBuffer[0]) return;
                    if (window.spector && i.node) {
                        const e = i.node._unityComponents,
                            n = e && e.canvasRenderer && e.canvasRenderer[0] ? e.canvasRenderer[0]._parentCanvas.entity.name : "",
                            s = "" === n ? i.node.name : n + " - " + i.node.name;
                        window.spector.setMarker(s + ": " + pc.LIGHT_MODE_NAMES[t.lightMode])
                    }
                    t.updateRenderState(s), this.updateRenderState(i, t, e);
                    let o = t.getVariant(e);
                    o || (o = t.applyMissingVariant(e));
                    let a = o.getShader(i._shaderDefs);
                    if (!n.setShader(a)) return a = o.applyMissingShader(i._shaderDefs), void n.setShader(a);
                    if (S)
                        for (let t = 0; t < a.samplers.length; t++) {
                            const e = a.samplers[t].scopeId.name,
                                i = C[e];
                            !i || "_GrabTexture" !== e && b[e] || (this.renderGrabPass(T, i), b[e] = !0)
                        }
                    if (window.spector) {
                        const e = o.keywords.getEnabledKeywords().join(" "),
                            n = i.node._unityComponents,
                            s = n && n.canvasRenderer && n.canvasRenderer[0] ? n.canvasRenderer[0]._parentCanvas.entity.fullname : "";
                        a._glProgram.__SPECTOR_Metadata = { Material: "[" + i.material.$id + "] " + i.material.name, Shader: "[" + t.sourceShader.$id + "] " + t.sourceShader.name, RenderType: pc.RENDER_TYPE_NAMES[t.renderType], LightMode: pc.LIGHT_MODE_NAMES[t.lightMode], Keywords: 0 === o.keywords.cardinality ? "<none>" : e, RenderQueue: i.material.renderQueue, SortingLayerIndex: i.sortingLayerIndex, SortingOrder: i.sortingOrder, DrawOrder: i.drawOrder, ZDist: i.zdist, ParentCanvas: s }
                    }
                    this.drawInstance(n, i, r, 0, !0)
                },
                setMaterial: function(t, e, i) { this._material && (i || this._material !== e) && this.popUniforms(t, this._material.parameters), (this._material !== e || i) && this.pushUniforms(t, e.parameters), this._material = e },
                pushUniforms: function(t, e) {
                    for (const i in e)
                        if (e.hasOwnProperty(i)) {
                            const n = e[i];
                            n.scopeId || (n.scopeId = t.scope.resolve(i)), n.scopeId.pushValue(n.data)
                        }
                    t.scope.resolve("_ClipRect").setValue([Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY])
                },
                popUniforms: function(t, e) {
                    for (const t in e)
                        if (e.hasOwnProperty(t)) { e[t].scopeId.popValue() }
                },
                setDrawCall: function(t, e) { null !== e && (u[3] = e._flipFaces ? -1 : 1, this.unityIds.worldTransformParamsId.setValue(u)) },
                setPass: function(t, e) {
                    e.updateRenderState(t);
                    const i = this.device,
                        n = e,
                        s = pc.RenderingUtils.unityCullModeToPlaycanvas(0 | n.culling.val);
                    i.setCullMode(s);
                    const r = pc.RenderingUtils.unityCompareFunctionToPlaycanvas(0 | n.zTest.val),
                        o = r >= 0 && r <= 7,
                        a = n.zWrite.val > 0;
                    i.setBlending(!0), i.setDepthTest(o), i.setDepthWrite(a);
                    const c = n.offsetUnits.val,
                        h = n.offsetFactor.val;
                    c || h ? (i.setDepthBias(!0), i.setDepthBiasValues(c, h)) : i.setDepthBias(!1), this.setBlendFunctionAndEquation(n), o && i.setDepthFunc(r);
                    const l = n.colorWriteMask.val,
                        u = (8 & l) > 0,
                        d = (4 & l) > 0,
                        _ = (2 & l) > 0,
                        f = (1 & l) > 0;
                    i.setColorWrite(u, d, _, f);
                    const m = this.device;
                    p.copy(this.keywords), p.merge(t.keywords);
                    let y = e.getVariant(p);
                    y || (y = e.applyMissingVariant(p));
                    let g = y.getShader(0);
                    if (!m.setShader(g)) return g = y.applyMissingShader(0), void m.setShader(g);
                    this.setMaterial(m, t, !0)
                },
                renderForward: function(t, e, i, n, s) {
                    const r = this.device,
                        o = pc.time.now();
                    r._enableAutoInstancing && this.prepareAutoInstancing(e, i), b = {}, C = {}, S = !1;
                    for (let s = 0; s < i; s++) {
                        const i = e[s],
                            r = i._lightProbe || this._ambientProbe;
                        p.copy(this.keywords), i.isCanvas ? i.render(p, r, t, i, n) : this.renderMeshInstance(p, r, t, i, n)
                    }
                    r.updateEnd(), this._forwardTime += pc.time.now() - o
                }
            }
        }
    }()), Object.assign(pc, function() {
        const t = [];
        for (let e = 0; e < 8; e++) t.push(new pc.Vec3);
        const e = new pc.Mat4,
            i = new pc.Mat4,
            n = new pc.Mat4,
            s = new pc.Mat4,
            r = new pc.Mat4,
            o = new pc.Mat4,
            a = new pc.Mat4,
            c = new pc.Mat4,
            h = new pc.Mat4,
            l = [0, 0, 0, 0],
            u = new Float32Array(4),
            d = new pc.Mat4,
            p = new pc.Mat4,
            _ = [0, 0];
        let f, m;
        const y = new Float32Array(24),
            g = pc.Mat4.IDENTITY.clone(),
            E = ["unity_SHAr", "unity_SHAg", "unity_SHAb", "unity_SHBr", "unity_SHBg", "unity_SHBb", "unity_SHC"],
            A = ["unity_SpecCube0", "unity_SpecCube0_BoxMin", "unity_SpecCube0_BoxMax", "unity_SpecCube0_ProbePosition", "unity_SpecCube1", "unity_SpecCube1_BoxMin", "unity_SpecCube1_BoxMax", "unity_SpecCube1_ProbePosition"],
            b = { min0: [-1 / 0, -1 / 0, -1 / 0, 0], max0: [1 / 0, 1 / 0, 1 / 0, 1], position0: [0, 0, 0, 0], min1: [-1 / 0, -1 / 0, -1 / 0, 1], max1: [1 / 0, 1 / 0, 1 / 0, 1], position1: [0, 0, 0, 0] };
        let C = null,
            T = null;
        const S = new pc.SphericalHarmonicsL2(null),
            M = new pc.BoundingBox,
            x = function(t) { return !(0 === t.comp.val || 8 === t.comp.val && 0 === t.pass.val && 0 === t.fail.val && 0 === t.zFail.val) },
            P = pc.RenderingUtils.unityCompareFunctionToPlaycanvas,
            O = pc.RenderingUtils.unityStencilOpToPlaycanvas,
            R = pc.RenderingUtils.unityBlendModeToPlaycanvas,
            v = pc.RenderingUtils.unityCullModeToPlaycanvas,
            D = pc.RenderingUtils.unityBlendOpToPlaycanvas;

        function w(t, e) { return e ? "hlslcc_mtx4x4" + t + "[0]" : t }

        function I(t) {
            this.device = t;
            const e = this.device;
            T = new pc.StencilParameters({}), C = new pc.StencilParameters({}), this._forwardTime = 0, this._skinTime = 0, this._morphTime = 0, this._instancingTime = 0, this.clearMaskStencil = new pc.StencilParameters({});
            const i = e.getProgramLibrary();
            this.library = i;
            const n = e.scope;
            this.viewProjId = n.resolve("matrix_viewProjection"), this.viewInvId = n.resolve("matrix_viewInverse"), this.modelMatrixId = n.resolve("matrix_model"), this.poseMatrixId = n.resolve("matrix_pose[0]"), this.boneTextureId = n.resolve("texture_poseMap"), this.boneTextureSizeId = n.resolve("texture_poseMapSize");
            const s = UnityEngine.UnityVersion.IsOrNewer("2018.3");
            this.needsMatrixVectorization = s, this.unityIds = { modelViewProjId: n.resolve(w("unity_MatrixMVP", s)), modelViewId: n.resolve(w("unity_MatrixMV", s)), viewProjId: n.resolve(w("unity_MatrixVP", s)), viewId: n.resolve(w("unity_MatrixV", s)), invViewId: n.resolve(w("unity_MatrixInvV", s)), legacyProjId: n.resolve(w("glstate_matrix_projection", s)), transposeModelViewId: n.resolve(w("unity_MatrixTMV", s)), inverseTransposeModelViewId: n.resolve(w("unity_MatrixITMV", s)), modelMatrixId: n.resolve(w("unity_ObjectToWorld", s)), modelMatrixInvId: n.resolve(w("unity_WorldToObject", s)), cameraProjectionId: n.resolve(w("unity_CameraProjection", s)), cameraInvProjectionId: n.resolve(w("unity_CameraInvProjection", s)), worldSpaceCameraPos: n.resolve("_WorldSpaceCameraPos"), projectionParamsId: n.resolve("_ProjectionParams"), screenParamsId: n.resolve("_ScreenParams"), zbufferParams: n.resolve("_ZBufferParams"), cameraOrthoParamsId: n.resolve("unity_OrthoParams"), cameraWorldClipPlanesId: n.resolve("unity_CameraWorldClipPlanes[0]"), time: n.resolve("_Time"), sinTime: n.resolve("_SinTime"), cosTime: n.resolve("_CosTime"), deltaTime: n.resolve("unity_DeltaTime"), timeParameters: n.resolve("_TimeParameters"), ambientSky: n.resolve("unity_AmbientSky"), ambientEquator: n.resolve("unity_AmbientEquator"), ambientGround: n.resolve("unity_AmbientGround"), glstateLightModelAmbient: n.resolve("glstate_lightmodel_ambient"), fogParamsId: n.resolve("unity_FogParams"), fogColorId: n.resolve("unity_FogColor"), indirectSpecularId: n.resolve("unity_IndirectSpecColor"), lightProbeIds: new Array(E.length), reflectionProbeIds: new Array(A.length), worldTransformParamsId: n.resolve("unity_WorldTransformParams"), roughness: n.resolve("unity_NHxRoughness") }, this.lightIds = { color: n.resolve("_LightColor0"), position: n.resolve("_WorldSpaceLightPos0"), vertexX: n.resolve("unity_4LightPosX0"), vertexY: n.resolve("unity_4LightPosY0"), vertexZ: n.resolve("unity_4LightPosZ0"), vertexAttenuation: n.resolve("unity_4LightAtten0"), vertexLightColors: n.resolve("unity_LightColor[0]"), vertexLightPositions: n.resolve("unity_LightPosition[0]"), attenuationTexture: n.resolve("_LightTexture0"), fallOffTexture: n.resolve("_LightTextureB0"), matrix: n.resolve(w("unity_WorldToLight", s)) };
            for (let t = 0; t < E.length; t++) this.unityIds.lightProbeIds[t] = n.resolve(E[t]);
            for (let t = 0; t < A.length; t++) this.unityIds.reflectionProbeIds[t] = n.resolve(A[t]);
            this.fogColor = new Float32Array(4), this.fogParams = new Float32Array(4), this.ambientSky = new Float32Array(4), this.lightmodel_ambient = new Float32Array(4), this.removeShadows = !1, this.keywords = new pc.KeywordSet, Object.assign(this, pc.BuiltInForwardRenderer)
        }
        return Object.assign(I.prototype, {
            updateRenderState: function(t, e, i) {
                const n = this.device;
                let s = v(0 | e.culling.val);
                t._flipFaces && (s === pc.CULLFACE_BACK ? s = pc.CULLFACE_FRONT : s === pc.CULLFACE_FRONT && (s = pc.CULLFACE_BACK)), n.setCullMode(s);
                const r = P(0 | e.zTest.val),
                    o = r >= 0 && r <= 7,
                    a = e.zWrite.val > 0;
                n.setBlending(!0), n.setDepthTest(o), o && n.setDepthFunc(r), n.setDepthWrite(a);
                const c = e.offsetUnits.val,
                    h = e.offsetFactor.val;
                if (c || h ? (n.setDepthBias(!0), n.setDepthBiasValues(c, h)) : n.setDepthBias(!1), this.setBlendFunctionAndEquation(e), (t._shaderDefs & pc.SHADERDEF_REVERT_STENCIL) > 0) {
                    const e = t.stencilFront.ref,
                        i = 1 === e;
                    this.clearMaskStencil.func = i ? pc.FUNC_ALWAYS : pc.FUNC_EQUAL, this.clearMaskStencil.zpass = i ? pc.STENCILOP_ZERO : pc.STENCILOP_REPLACE, this.clearMaskStencil.ref = e >> 1, this.clearMaskStencil.readMask = i ? 255 : e >> 1, this.clearMaskStencil.writeMask = i ? 255 : e, n.applyStencilState(this.clearMaskStencil, this.clearMaskStencil, !0)
                } else {
                    const i = this.isUiStencil(t),
                        s = (t._shaderDefs & pc.SHADERDEF_STENCIL_OVERRIDE) === pc.SHADERDEF_STENCIL_OVERRIDE,
                        r = x(e.stencilOp),
                        o = x(e.stencilOpFront) || x(e.stencilOpBack);
                    (i || s) && t.stencilFront && t.stencilBack ? (t.node.element && i && (this._materialToStencilState(t.material, t.stencilFront), this._materialToStencilState(t.material, t.stencilBack)), n.applyStencilState(t.stencilFront, t.stencilBack, !0)) : r ? (this._renderStateToStencilState(e, e.stencilOp, C), t.stencilFront && (C = t.stencilFront), n.applyStencilState(C, C, !0)) : o ? (this._renderStateToStencilState(e, e.stencilOpFront, C), this._renderStateToStencilState(e, e.stencilOpBack, T), n.applyStencilState(C, T, !0)) : n.applyStencilState(null, null, !0)
                }
                let l = t.parameters.hasOwnProperty("_ColorMask") ? t.parameters._ColorMask.data : e.colorWriteMask.val;
                (t._shaderDefs & pc.SHADERDEF_REVERT_STENCIL) > 0 && (l = 0);
                const u = (8 & l) > 0,
                    d = (4 & l) > 0,
                    p = (2 & l) > 0,
                    _ = (1 & l) > 0;
                n.setColorWrite(u, d, p, _), t.parameters.hasOwnProperty("UNITY_UI_ALPHACLIP") && 0 !== t.parameters.UNITY_UI_ALPHACLIP.data && i.enableKeyword("UNITY_UI_ALPHACLIP")
            },
            setBlendFunctionAndEquation(t) {
                const e = R(0 | t.blending.src.val),
                    i = R(0 | t.blending.dst.val),
                    n = D(0 | t.blending.op.val),
                    s = R(0 | t.alphaBlending.src.val),
                    r = R(0 | t.alphaBlending.dst.val),
                    o = D(0 | t.alphaBlending.op.val);
                this.device.setBlendFunctionSeparate(e, i, s, r), this.device.setBlendEquationSeparate(n, o)
            },
            isUiStencil: function(t) { return !!(t.material.parameters._Stencil && t.material.parameters._StencilOp && t.material.parameters._StencilComp && t.material.parameters._StencilReadMask && t.material.parameters._StencilWriteMask && t.material.parameters._ColorMask) },
            _renderStateToStencilState: function(t, e, i) { i.func = P(0 | e.comp.val), i.ref = 0 | t.stencilRef.val, i.readMask = 0 | t.stencilReadMask.val, i.writeMask = 0 | t.stencilWriteMask.val, i.fail = O(0 | e.fail.val), i.zfail = O(0 | e.zFail.val), i.zpass = O(0 | e.pass.val) },
            _materialToStencilState: function(t, e) { e.func = P(0 | t.parameters._StencilComp.data), e.ref = 0 | t.parameters._Stencil.data, e.readMask = 0 | t.parameters._StencilReadMask.data, e.writeMask = 0 | t.parameters._StencilWriteMask.data, e.fail = O(0 | t.parameters._StencilZFail), e.zfail = O(0 | t.parameters._StencilZPass), e.zpass = O(0 | t.parameters._StencilOp.data) },
            updateCameraFrustum: function(t) { t.updateVP(), t.frustum.update(t._projMat, t._viewMat) },
            setCamera: function(t, o, a, c) {
                const h = UnityEngine.Object.FromHandle(UnityEngine.Camera, t._component);
                UnityEngine.Camera.TriggerOnPreRender(h), UnityEngine.Canvas.TriggerWillRenderCanvases(), t.updateVP(), i.copy(t._viewMat), e.copy(t._viewInvMat), s.copy(t._projMat), r.copy(t._projInvMat), n.copy(t._viewProjMat), this.viewInvId.setValue(e.data), this.unityIds.invViewId.setValue(e.data), this.unityIds.viewId.setValue(i.data), this.unityIds.viewProjId.setValue(n.data), this.unityIds.legacyProjId.setValue(s.data), this.unityIds.cameraProjectionId.setValue(s.data), this.unityIds.cameraInvProjectionId.setValue(r.data);
                const l = t.projection === pc.PROJECTION_ORTHOGRAPHIC ? t.frustum.unityPlanesOrthographic : t.frustum.unityPlanesPerspective;
                for (let t = 0, e = 0; t < l.length; t++, e += 4) y[e] = l[t][0], y[e + 1] = l[t][1], y[e + 2] = l[t][2], y[e + 3] = l[t][3];
                this.unityIds.cameraWorldClipPlanesId.setValue(y);
                const d = t._node.getPosition();
                u[0] = d.x, u[1] = d.y, u[2] = d.z, u[3] = 0, t._screenParams[0] = t.renderTarget ? t.renderTarget.width : this.device.width, t._screenParams[1] = t.renderTarget ? t.renderTarget.height : this.device.height, t._screenParams[2] = 1 + 1 / t._screenParams[0], t._screenParams[3] = 1 + 1 / t._screenParams[1], this.unityIds.worldSpaceCameraPos.setValue(u), this.unityIds.projectionParamsId.setValue(t._projectionParams), this.unityIds.cameraOrthoParamsId.setValue(t._orthoParams), this.unityIds.screenParamsId.setValue(t._screenParams), this.unityIds.zbufferParams.setValue(t._zbufferParams), t.frustum.update(s, i);
                const p = this.device;
                p.setRenderTarget(o), p.updateBegin();
                let _ = t.getRect();
                const f = o ? o.width : p.width,
                    m = o ? o.height : p.height;
                let g = Math.floor(_.x * f),
                    E = Math.floor(_.y * m),
                    A = Math.floor(_.width * f),
                    b = Math.floor(_.height * m);
                p.setViewport(g, E, A, b), p.setScissor(g, E, A, b), a && p.clear(t._clearOptions), _ = t._scissorRect, g = Math.floor(_.x * f), E = Math.floor(_.y * m), A = Math.floor(_.width * f), b = Math.floor(_.height * m), p.setScissor(g, E, A, b), c && p.setScissor(1, 1, f - 2, m - 2), this.viewProjId.setValue(n.data), UnityEngine.Camera.TriggerOnPostRender(h)
            },
            dispatchGlobalLights: function(t) {
                if (this.ambientSky = UnityEngine.RenderSettings.ambientSkyColor.data, this.lightmodel_ambient[0] = this.ambientSky[0] / 2, this.lightmodel_ambient[1] = this.ambientSky[1] / 2, this.lightmodel_ambient[2] = this.ambientSky[2] / 2, this.lightmodel_ambient[3] = this.ambientSky[3] / 2, this.unityIds.glstateLightModelAmbient.setValue(this.lightmodel_ambient), this.unityIds.ambientSky.setValue(this.ambientSky), this.unityIds.ambientEquator.setValue(UnityEngine.RenderSettings.ambientEquatorColor.data), this.unityIds.ambientGround.setValue(UnityEngine.RenderSettings.ambientGroundColor.data), t.skyboxHelper) {
                    const e = t.skyboxHelper.indirectSpecular;
                    this.unityIds.indirectSpecularId.setValue(e.data)
                }
                this._ambientProbe = UnityEngine.RenderSettings.ambientProbe || S;
                const e = UnityEngine.LightmapSettings.reflectionProbes,
                    i = e && e.environmentProbe ? e.environmentProbe : null;
                null != i ? (this.unityIds.reflectionProbeIds[0].setValue(i.cubemap), this.unityIds.reflectionProbeIds[1].setValue(b.min0), this.unityIds.reflectionProbeIds[2].setValue(b.max0), this.unityIds.reflectionProbeIds[3].setValue(b.position0), this.unityIds.reflectionProbeIds[4].setValue(i.cubemap), this.unityIds.reflectionProbeIds[5].setValue(b.min1), this.unityIds.reflectionProbeIds[6].setValue(b.max1), this.unityIds.reflectionProbeIds[7].setValue(b.position1)) : (this.unityIds.reflectionProbeIds[0].setValue(null), this.unityIds.reflectionProbeIds[1].setValue(pc.Vec4.ZERO.data), this.unityIds.reflectionProbeIds[2].setValue(pc.Vec4.ZERO.data), this.unityIds.reflectionProbeIds[3].setValue(pc.Vec4.ZERO.data), this.unityIds.reflectionProbeIds[4].setValue(null), this.unityIds.reflectionProbeIds[5].setValue(pc.Vec4.ZERO.data), this.unityIds.reflectionProbeIds[6].setValue(pc.Vec4.ZERO.data), this.unityIds.reflectionProbeIds[7].setValue(pc.Vec4.ZERO.data))
            },
            updateCpuSkinMatrices: function(t, e) {
                if (0 === e) return;
                const i = pc.time.now();
                let n, s, r;
                for (let i = 0; i < e; i++)
                    if (n = t[i], r = n.skinInstance, r) {
                        r._dirty = !1;
                        for (let t = 0; t < r.bones.length && (s = r.bones[t], !s || (r._dirty = s._aabbVer !== r.bonesAabbVersions[t], !r._dirty)); t++);
                        if (r._dirty) {
                            for (let t = 0; t < r.bones.length; t++) r.bonesAabbVersions[t] = r.bones[t];
                            r.updateMatrices(t[i].node)
                        }
                    }
                this._skinTime += pc.time.now() - i
            },
            updateGpuSkinMatrices: function(t, e, i) {
                const n = pc.time.now();
                let s, r, o, a, c, h = !1;
                for (s = 0; s < e; s++)
                    if (o = t[s], h = !1, a = o.skinInstance, a && a._dirty) {
                        if (c = a.skin, c.updateWhenOffscreen) h = !0;
                        else { const t = a.skin.rootBone ? a.skin.rootBone : o.node; for (r = 0; r < i.length; r++) M.center = t.transformPoint(c.localBounds.center, M.center), M.halfExtents.copy(t.getLossyScale()), M.halfExtents.mul(c.localBounds.halfExtents), h = h || !!pc.Culling.isAABBVisibleInFrustum(i[r].frustum, M) }
                        h && (a.updateMatrixPalette(), a._dirty = !1)
                    }
                this._skinTime += pc.time.now() - n
            },
            updateMorphedBounds: function(t, e) {
                const i = pc.time.now();
                let n, s;
                for (n = 0; n < e; n++) s = t[n].morphInstance, s && s._dirty && s.updateBounds(t[n].mesh);
                this._morphTime += pc.time.now() - i
            },
            updateMorphing: function(t, e) {
                const i = pc.time.now();
                let n, s;
                for (n = 0; n < e; n++) t[n].visibleThisFrame && (s = t[n].morphInstance, s && s._dirty && (s.update(t[n].mesh), s._dirty = !1));
                this._morphTime += pc.time.now() - i
            },
            setSkinning: function(t, e) { e.skinInstance && (t.supportsBoneTextures ? (f = e.skinInstance.boneTexture, this.boneTextureId.setValue(f), _[0] = f.width, _[1] = f.height, this.boneTextureSizeId.setValue(_)) : this.poseMatrixId.setValue(e.skinInstance.matrixPalette)) },
            setMatrix: function(t, e) { this.device.scope.resolve(w(t, this.needsMatrixVectorization)).setValue(e) },
            drawInstance: function(t, e, n, r, l) {
                const u = t.shader.uniformsUsage;
                let _ = e.node.worldTransform,
                    f = e.node.worldTransformInverse;
                return e.parameters.localToWorldMatrix && (_ = d.set(e.parameters.localToWorldMatrix.data), 0 != (u & pc.UNIFORMS_USAGE_MAP.unity_WorldToObject) && (f = e.parameters.worldToLocalMatrix ? p.set(e.parameters.worldToLocalMatrix.data) : p.copy(_).invert())), this.modelMatrixId.setValue(_.data), this.unityIds.modelMatrixId.setValue(_.data), this.unityIds.modelMatrixInvId.setValue(f.data), 0 != (u & pc.UNIFORMS_USAGE_MAP.unity_MatrixMVP) && (o.copy(s), o.mul2(o, i), o.mul2(o, _), this.unityIds.modelViewProjId.setValue(o.data)), 0 != (u & pc.UNIFORMS_USAGE_MAP.unity_MatrixMV) && (a.copy(i), a.mul2(a, _), this.unityIds.modelViewId.setValue(a.data)), 0 != (u & pc.UNIFORMS_USAGE_MAP.unity_MatrixTMV) && (c.copy(a), c.transpose(), this.unityIds.transposeModelViewId.setValue(c.data)), 0 != (u & pc.UNIFORMS_USAGE_MAP.unity_MatrixITMV) && (0 == (u & pc.UNIFORMS_USAGE_MAP.unity_MatrixTMV) && (c.copy(a), c.transpose()), h.copy(c), h.invert(), this.unityIds.inverseTransposeModelViewId.setValue(h.data)), m = e.instancingData, m ? (this._instancedDrawCalls++, this._removedByInstancing += m.count, t.setVertexBuffer(m._buffer, 1, m.offset), t.draw(n.primitive[r], m.count, e.material._shader.defaultParameters, e.constAttributes), m._buffer === pc._autoInstanceBuffer ? (e.instancingData = null, m.count - 1) : 0) : (t.draw(n.primitive[r], null, e.material._shader.defaultParameters, e.constAttributes, e), 0)
            },
            prepareAutoInstancing: function(t, e) {
                const i = pc.time.now();
                pc._autoInstanceBuffer || this.setupInstancing(this.device);
                let n = 0,
                    s = 0;
                const r = pc._autoInstanceBufferData;
                for (let i = 0; i < e; i++) {
                    const o = i,
                        a = t[i],
                        c = a.material,
                        h = a.mesh;
                    if (!c || !h || !c.enableAutoInstancing) continue;
                    if (null !== a.instancingData) continue;
                    let l = 0;
                    for (l = i + 1; l < e; l++) {
                        const e = t[l],
                            i = e.material,
                            n = e.mesh;
                        if (i !== c || n !== h) break
                    }
                    if (l - o > 1) {
                        for (a.instancingData = { count: l - o, offset: 4 * n, _buffer: pc._autoInstanceBuffer }, a._shaderDefs |= pc.SHADERDEF_INSTANCING, s = o; s < l; s++) {
                            const e = t[s].node.getWorldTransform().data;
                            r.set(e, n), n += 16
                        }
                        i = l - 1
                    } else i = o, a._shaderDefs &= ~pc.SHADERDEF_INSTANCING, a.instancingData = null
                }
                this._instancingTime += (pc.time.now() - i) / 1e3, pc._autoInstanceBuffer.unlock()
            },
            switchRenderingToScreenSpace: function(t) {
                if (t !== this.renderingAsScreenSpace)
                    if (this.renderingAsScreenSpace = t, t) {
                        const t = pc.Mat4.IDENTITY.data,
                            e = this.device;
                        g.setOrtho(0, e._width, 0, e._height, -1e3, 1e3), this.unityIds.viewId.pushValue(t), this.unityIds.legacyProjId.pushValue(g.data), this.viewProjId.pushValue(g.data), this.unityIds.viewProjId.pushValue(g.data)
                    } else this.unityIds.viewId.popValue(), this.unityIds.legacyProjId.popValue(), this.viewProjId.popValue(), this.unityIds.viewProjId.popValue()
            },
            setupInstancing: function(t) {
                if (!pc._instanceVertexFormat) {
                    const e = [{ semantic: pc.SEMANTIC_TEXCOORD2, components: 4, type: pc.TYPE_FLOAT32 }, { semantic: pc.SEMANTIC_TEXCOORD3, components: 4, type: pc.TYPE_FLOAT32 }, { semantic: pc.SEMANTIC_TEXCOORD4, components: 4, type: pc.TYPE_FLOAT32 }, { semantic: pc.SEMANTIC_TEXCOORD5, components: 4, type: pc.TYPE_FLOAT32 }];
                    pc._instanceVertexFormat = new pc.VertexFormat(t, e)
                }
                pc._autoInstanceBuffer || (pc._autoInstanceBuffer = new pc.VertexBuffer(t, pc._instanceVertexFormat, t.autoInstancingMaxObjects, pc.BUFFER_DYNAMIC), pc._autoInstanceBufferData = new Float32Array(pc._autoInstanceBuffer.lock()))
            },
            clearTarget: function(t, e) {
                window.spector && window.spector.setMarker("Clear RT");
                const i = this.device,
                    n = i.renderTarget;
                i.setRenderTarget(t), i.updateBegin(), i.setColorWrite(!0, !0, !0, !0), i.setDepthWrite(!0), this.setupViewport({ x: 0, y: 0, width: 1, height: 1 }, t.width, t.height), this.device.clear(e), i.setRenderTarget(n)
            },
            clearView: function(t, e) {
                window.spector && window.spector.setMarker("Clear");
                const i = t.camera,
                    n = i.renderTarget,
                    s = this.device;
                s.setRenderTarget(n), s.updateBegin(), s.setColorWrite(!0, !0, !0, !0), s.setDepthWrite(!0);
                const r = i.getRect(),
                    o = n ? n.width : s.width,
                    a = n ? n.height : s.height;
                this.setupViewport(r, o, a), s.clear(e || i._clearOptions)
            },
            setupViewport: function(t, e, i) {
                const n = this.device,
                    s = Math.floor(t.x * e),
                    r = Math.floor(t.y * i),
                    o = Math.floor(t.width * e),
                    a = Math.floor(t.height * i);
                n.setViewport(s, r, o, a), n.setScissor(s, r, o, a)
            },
            setSceneConstants: function() {
                const t = this.device,
                    e = this.scene;
                this.keywords.copy(pc.UnityShader.globalKeywords), this.dispatchGlobalLights(e);
                const i = UnityEngine.RenderSettings;
                i.fog && (l[2] = 0, l[3] = 0, i.fogMode === UnityEngine.FogMode.Exponential ? this.keywords.enableKeywordId(pc.Keywords.FOG_EXP) : i.fogMode === UnityEngine.FogMode.ExponentialSquared ? this.keywords.enableKeywordId(pc.Keywords.FOG_EXP2) : (this.keywords.enableKeywordId(pc.Keywords.FOG_LINEAR), l[2] = -1 / (i.fogEnd - i.fogStart), l[3] = i.fogEnd / (i.fogEnd - i.fogStart)), l[0] = i.fogDensity / Math.sqrt(Math.log(2)), l[1] = i.fogDensity / Math.log(2), this.unityIds.fogColorId.setValue(i.fogColor.data), this.unityIds.fogParamsId.setValue(l));
                const n = UnityEngine.Time.time,
                    s = UnityEngine.Time.deltaTime,
                    r = UnityEngine.Time.smoothDeltaTime;
                this.unityIds.time.setValue([n / 20, n, 2 * n, 3 * n]), this.unityIds.sinTime.setValue([Math.sin(n / 8), Math.sin(n / 4), Math.sin(n / 2), Math.sin(n)]), this.unityIds.cosTime.setValue([Math.cos(n / 8), Math.cos(n / 4), Math.cos(n / 2), Math.cos(n)]), this.unityIds.deltaTime.setValue([s, 1 / s, r, 1 / r]), this.unityIds.timeParameters.setValue([n, Math.sin(n), Math.cos(n), 0]), UnityEngine.Texture2D.nhxRoughnessTexture && this.unityIds.roughness.setValue(UnityEngine.Texture2D.nhxRoughnessTexture.handle);
                for (const e in pc.UnityShader.globalUniforms) {
                    if (!pc.UnityShader.globalUniforms.hasOwnProperty(e)) continue;
                    const i = pc.UnityShader.globalUniforms[e];
                    i.scopeId = i.scopeId || t.scope.resolve(e), i.scopeId.setValue(i.value)
                }
            },
            renderComposition: function() {
                window.spector && window.spector.clearMarker();
                const t = this.device,
                    e = this.scene.getMeshInstances(),
                    i = this.scene.meshInstancesCount;
                this.updateCpuSkinMatrices(e, i), this.updateMorphedBounds(e, i), this.setSceneConstants();
                const n = this.scene._cameras;
                n.sort(pc.SortUtils.cameraCompare), this.updateGpuSkinMatrices(e, i, n), this.updateMorphing(e, i);
                for (let t = 0; t < n.length; t++) this.renderCamera(n[t]);
                const s = this.scene.overlayScreens;
                if (s.length > 0) {
                    t.setRenderTarget(null), t.updateBegin();
                    const e = [this.device.width, this.device.height, 1 + 1 / this.device.width, 1 + 1 / this.device.height];
                    this.unityIds.screenParamsId.setValue(e), this.setupViewport({ x: 0, y: 0, width: 1, height: 1 }, t.width, t.height), t.clear({ flags: pc.CLEARFLAG_STENCIL }), this.switchRenderingToScreenSpace(!0);
                    for (let t = 0; t < s.length; t++) { s[t].canvasMeshInstance.render(this.keywords, null, null, null, this.scene._lights) }
                    this.switchRenderingToScreenSpace(!1)
                }
            },
            updateLights: function(t, e) {
                const i = [];
                for (let n = 0; n < e.length; n++) {
                    const s = e[n];
                    s.update(t) && i.push(s)
                }
                return i
            },
            setupWorldScreensVisibility: function(t, e) { for (const i of t._worldScreens) i.screenType === pc.SCREEN_TYPE_CAMERA ? i.canvasMeshInstance.visible = i.camera === e : i.canvasMeshInstance.visible = !0 },
            renderCamera: function(t) {
                const e = t.camera,
                    i = t.camera.renderTarget,
                    n = pc.Application.getApplication();
                t.frameBegin(i), this.updateCameraFrustum(t.camera);
                const s = [];
                this.scene.skyboxHelper.updateSkyDrawCall(e), this.scene.skyboxHelper.setSkyboxEnabled((e._clearOptions.flags & pc.CLEARFLAG_USE_SKYBOX) > 0), UnityEngine.Camera.TriggerOnPreCull(UnityEngine.Object.FromHandle(UnityEngine.Camera, e._component)), this.setupWorldScreensVisibility(this.scene, e);
                const r = this.scene.getMeshInstancesCached(),
                    o = this.scene.meshInstancesCount;
                pc.Culling.cull(e, r, o, s), pc.SortUtils.calculateSortDistances(s, e._node.getPosition(), e._node.forward), s.sort(pc.SortUtils.genericSort);
                const a = this.updateLights(e, this.scene._lights);
                this.clearView(t), this.setCamera(e, e.renderTarget), n.counters.recordDrawCalls(s.length), this.renderForward(e, s, s.length, a), t.frameEnd()
            }
        }), { ForwardRenderer: I, reflectionProbeUniforms: A }
    }()), Object.assign(pc, function() {
        const t = new pc.Vec3,
            e = new pc.Vec3,
            i = new pc.Vec3,
            n = new pc.Vec3,
            s = function() { this._projection = pc.PROJECTION_PERSPECTIVE, this._nearClip = .1, this._farClip = 1e4, this._fov = 45, this._orthoHeight = 10, this._aspect = 16 / 9, this._aspectRatioMode = pc.ASPECT_AUTO, this._horizontalFov = !1, this.cullingMask = 4294967295, this._projMatDirty = !0, this._projMat = new pc.Mat4, this._projInvMat = new pc.Mat4, this._viewMat = new pc.Mat4, this._viewInvMat = new pc.Mat4, this._viewProjMat = new pc.Mat4, this._invViewProjMat = new pc.Mat4, this._projMatOverride = null, this._rect = { x: 0, y: 0, width: 1, height: 1 }, this._scissorRect = { x: 0, y: 0, width: 1, height: 1 }, this.frustum = new pc.Frustum(this._projMat, this._viewMat), this.renderTarget = null, this._clearOptions = { color: [.5, .5, .5, 1], depth: 1, stencil: 0, flags: pc.CLEARFLAG_COLOR | pc.CLEARFLAG_DEPTH | pc.CLEARFLAG_STENCIL | pc.CLEARFLAG_USE_SKYBOX }, this._node = null, this.calculateTransform = null, this.overrideCalculateTransform = !1, this.calculateProjection = null, this.overrideCalculateProjection = !1, this._component = null, this._zbufferParams = new Float32Array(4), this._screenParams = new Float32Array(4), this._orthoParams = new Float32Array(4), this._projectionParams = new Float32Array(4) };
        return Object.assign(s.prototype, {
            worldToScreen: function(t, e, i, s) { return void 0 === s && (s = new pc.Vec3), this.updateVP(), this._viewProjMat.multiplyPoint(t, s), s.x = .5 * (s.x + 1) * e, s.y = .5 * (s.y + 1) * i, n.sub2(t, this._node.getPosition()), s.z = n.dot(this._node.forward), s },
            screenToWorld: function(n, s, r, o, a, c) {
                void 0 === c && (c = new pc.Vec3), this.updateVP();
                const h = this._node.getPosition();
                if (this._projection === pc.PROJECTION_PERSPECTIVE) {
                    e.set(n / o * 2 - 1, s / a * 2 - 1, 1), this._invViewProjMat.transformPoint(e, i);
                    const t = e.x * this._invViewProjMat.data[3] + e.y * this._invViewProjMat.data[7] + e.z * this._invViewProjMat.data[11] + this._invViewProjMat.data[15];
                    i.scale(1 / t);
                    const l = r / this._farClip;
                    c.lerp(h, i, l)
                } else {
                    const e = this._farClip - this._nearClip;
                    t.set(n / o, s / a, (r - this._nearClip) / e), t.scale(2), t.sub(pc.Vec3.ONE), this._invViewProjMat.transformPoint(t, c)
                }
                return c
            },
            _getProjectionMatrix: function() { return this._projMatDirty && this.resetProjectionMatrix(), this._projMat },
            getProjectionMatrix: function() {
                const t = this._projMatDirty;
                if (this._projMatDirty && this._projMatOverride ? this._projMat.copy(this._projMatOverride) : this._getProjectionMatrix(), t) {
                    const t = this._nearClip,
                        e = this._farClip,
                        i = this.aspectRatio,
                        n = this.orthoHeight;
                    this._orthoParams[0] = n * i, this._orthoParams[1] = n, this._orthoParams[2] = 0, this._orthoParams[3] = this.projection === pc.PROJECTION_ORTHOGRAPHIC ? 1 : 0, this._zbufferParams[0] = 1 - e / t, this._zbufferParams[1] = e / t, this._zbufferParams[2] = this._zbufferParams[0] / e, this._zbufferParams[3] = this._zbufferParams[1] / e, this._projectionParams[0] = 1, this._projectionParams[1] = t, this._projectionParams[2] = e, this._projectionParams[3] = 1 / e, this._updateScreens(), this._projInvMat.copy(this._projMat), this._projInvMat.invert()
                }
                return this._projMat
            },
            setProjectionMatrix: function(t) { this._projMatOverride = t ? t.clone() : null, this._projMatDirty = !0 },
            _updateScreens: function() {
                const t = pc.Application.getApplication().scene.worldScreens;
                for (let e = 0; e < t.length; e++) {
                    const i = t[e];
                    i.screenType === pc.SCREEN_TYPE_CAMERA && i._calcProjectionMatrix()
                }
            },
            getRect: function() { return this._rect },
            setRect: function(t, e, i, n) { this._rect.x = t, this._rect.y = e, this._rect.width = i, this._rect.height = n, this._projMatDirty = !0 },
            setScissorRect: function(t, e, i, n) { this._scissorRect.x = t, this._scissorRect.y = e, this._scissorRect.width = i, this._scissorRect.height = n },
            resetProjectionMatrix: function() {
                if (this._projection === pc.PROJECTION_PERSPECTIVE) this._projMat.setPerspective(this._fov, this._aspect, this._nearClip, this._farClip, this._horizontalFov);
                else {
                    const t = this._orthoHeight,
                        e = t * this._aspect;
                    this._projMat.setOrtho(-e, e, -t, t, this._nearClip, this._farClip)
                }
                this._projMatOverride = null, this._projMatDirty = !1
            },
            updateVP: function() {
                const t = this._node;
                if (this.overrideCalculateTransform) this.calculateTransform(this._viewInvMat, pc.VIEW_CENTER);
                else {
                    const e = t.getPosition(),
                        i = t.getRotation();
                    this._viewInvMat.setTRS(e, i, pc.Vec3.REVERSED_Z)
                }
                this._viewMat.copy(this._viewInvMat).invert(), this.overrideCalculateProjection ? this.calculateProjection(this._projMat, pc.VIEW_CENTER) : this.getProjectionMatrix(), this._projInvMat.copy(this._projMat).invert(), this._viewProjMat.mul2(this._projMat, this._viewMat), this._invViewProjMat.copy(this._viewProjMat).invert();
                const e = t.getLossyScale();
                0 !== e.x && 0 !== e.y && 0 !== e.z || console.warn("Camera world transform matrix has 0 scale. That leads to losing rotation data")
            }
        }), Object.defineProperty(s.prototype, "aspectRatio", { get: function() { return this._aspect }, set: function(t) { this._aspect !== t && (this._aspect = t, this._projMatDirty = !0) } }), Object.defineProperty(s.prototype, "projection", { get: function() { return this._projection }, set: function(t) { this._projection !== t && (this._projection = t, this._projMatDirty = !0) } }), Object.defineProperty(s.prototype, "nearClip", { get: function() { return this._nearClip }, set: function(t) { this._nearClip !== t && (this._nearClip = t, this._projMatDirty = !0) } }), Object.defineProperty(s.prototype, "farClip", { get: function() { return this._farClip }, set: function(t) { this._farClip !== t && (this._farClip = t, this._projMatDirty = !0) } }), Object.defineProperty(s.prototype, "fov", { get: function() { return this._fov }, set: function(t) { this._fov !== t && (this._fov = t, this._projMatDirty = !0) } }), Object.defineProperty(s.prototype, "horizontalFov", { get: function() { return this._horizontalFov }, set: function(t) { this._horizontalFov !== t && (this._horizontalFov = t, this._projMatDirty = !0) } }), Object.defineProperty(s.prototype, "orthoHeight", { get: function() { return this._orthoHeight }, set: function(t) { this._orthoHeight !== t && (this._orthoHeight = t, this._projMatDirty = !0) } }), Object.defineProperty(s.prototype, "clearColor", { get: function() { return this._clearOptions.color }, set: function(t) { this._clearOptions.color[0] = t[0], this._clearOptions.color[1] = t[1], this._clearOptions.color[2] = t[2], this._clearOptions.color[3] = t[3] } }), Object.defineProperty(s.prototype, "clearDepth", { get: function() { return this._clearOptions.depth }, set: function(t) { this._clearOptions.depth = t } }), Object.defineProperty(s.prototype, "clearSkybox", { get: function() { return this._clearOptions.skybox }, set: function(t) { this._clearOptions.skybox = t } }), Object.defineProperty(s.prototype, "clearStencil", { get: function() { return this._clearOptions.stencil }, set: function(t) { this._clearOptions.stencil = t } }), Object.defineProperty(s.prototype, "clearFlags", { get: function() { return this._clearOptions.flags }, set: function(t) { this._clearOptions.flags = t } }), { Camera: s }
    }()), Object.assign(pc, function() {
        const t = new pc.Vec3,
            e = new pc.Mat4,
            i = new pc.Mat4,
            n = new pc.Mat4,
            s = (new pc.Mat4).setTRS(new pc.Vec3(-.5, -.5, 0), pc.Quat.IDENTITY, pc.Vec3.ONE);
        let r = 0;
        const o = function() {
            this.id = r++, this._type = pc.LIGHTTYPE_DIRECTIONAL, this._color = new pc.Color(.8, .8, .8), this._intensity = 1, this._castShadows = !1, this._enabled = !1, this._mask = 1, this._cullingMask = -1, this._renderMode = 0, this._nodeAabbVer = 0, this.isStatic = !1, this.key = 0, this._aabb = new pc.BoundingBox, this._attenuationEnd = 10, this._shadowType = pc.SHADOW_PCF3, this._cookie = null, this._cookieScale = new pc.Vec2(1, 1), this._outerConeAngle = 45, this._finalColor = new Float32Array([.8, .8, .8, 1]);
            const t = Math.pow(this._finalColor[0], 2.2);
            this._linearFinalColor = new Float32Array([t, t, t, t]), this._worldToLightMatrix = new pc.Mat4, this._node = null, this._luminance = 0, this._priority = 0, this._directionToLight = new pc.Vec3, this._position = new pc.Vec3
        };
        return o.LightDefaults = { type: "point", color: new pc.Color(1, 1, 1, 1), cookieScale: pc.Vec2.ONE, intensity: 1, range: 10, cullingMask: -1 }, Object.assign(o.prototype, {
            destroy: function() {},
            update: function(r) {
                if (!this._node) return !1;
                if (this._nodeAabbVer === this._node.aabbVersion) return pc.Culling.isAABBVisibleInFrustum(r.frustum, this._aabb);
                const o = this._node.worldTransformInverse,
                    a = 1 / this._attenuationEnd;
                return this._position.copy(this._node.getPosition()), this._type === pc.LIGHTTYPE_POINT ? (this._worldToLightMatrix.copy(o).scale(a), this._worldToLightMatrix.data[15] = 1) : this._type === pc.LIGHTTYPE_SPOT ? (e.setIdentity(), e.data[11] = 2 * Math.tan(pc.math.DEG_TO_RAD * this._outerConeAngle * .5), e.data[15] = 0, i.setScale(a, a, a), i.data[15] = a, this._worldToLightMatrix.mul2(i, e), this._worldToLightMatrix.mul2(this._worldToLightMatrix, o)) : (t.set(this._cookieScale.x, this._cookieScale.x, this._cookieScale.x), n.setTRS(this._node.getPosition(), this._node.getRotation(), t), this._worldToLightMatrix.mul2(n, s).invert(), this._worldToLightMatrix.data[2] = 0, this._worldToLightMatrix.data[6] = 0, this._worldToLightMatrix.data[10] = 0, this._worldToLightMatrix.data[14] = 0, this._directionToLight.copy(this._node.forward).scale(-1)), this._nodeAabbVer = this._node.aabbVersion, this.getBoundingBox(this._aabb), pc.Culling.isAABBVisibleInFrustum(r.frustum, this._aabb)
            },
            getColor: function() { return this._color },
            getBoundingBox: function(t) {
                if (this._type === pc.LIGHTTYPE_SPOT) {
                    const e = this.attenuationEnd,
                        i = this._outerConeAngle,
                        n = this._node,
                        s = Math.abs(Math.tan(i * pc.math.DEG_TO_RAD * .5) * e);
                    t.center.set(0, 0, .5 * e), t.halfExtents.set(s, s, .5 * e), t.setFromTransformedAabb(t, n.getWorldTransform())
                } else this._type === pc.LIGHTTYPE_POINT ? (t.center.copy(this._node.getPosition()), t.halfExtents.set(this.attenuationEnd, this.attenuationEnd, this.attenuationEnd)) : this._type === pc.LIGHTTYPE_DIRECTIONAL && (t.center.copy(this._node.getPosition()), t.halfExtents.set(1 / 0, 1 / 0, 1 / 0))
            },
            _updateFinalColor: function() {
                const t = this._color,
                    e = t.r,
                    i = t.g,
                    n = t.b,
                    s = t.a,
                    r = this._intensity,
                    o = this._finalColor,
                    a = this._linearFinalColor;
                o[0] = e * r, o[1] = i * r, o[2] = n * r, o[3] = s * r, r >= 1 ? (a[0] = Math.pow(e, 2.2) * r, a[1] = Math.pow(i, 2.2) * r, a[2] = Math.pow(n, 2.2) * r, a[3] = Math.pow(s, 2.2) * r) : (a[0] = Math.pow(o[0], 2.2), a[1] = Math.pow(o[1], 2.2), a[2] = Math.pow(o[2], 2.2), a[3] = Math.pow(o[3], 2.2)), this._luminance = (.3 * e + .59 * i + .11 * n) * r
            },
            setColor: function(...t) {
                let e, i, n;
                1 === arguments.length ? (e = t[0].r, i = t[0].g, n = t[0].b) : 3 === arguments.length && (e = t[0], i = t[1], n = t[2]), this._color.set(e, i, n), this._updateFinalColor()
            },
            updateKey: function() {
                const t = this._type << 29 | (this._castShadows ? 1 : 0) << 28 | this._shadowType << 25 | (this._cookie ? 1 : 0) << 24;
                this.key = t
            }
        }), Object.defineProperty(o.prototype, "enabled", { get: function() { return this._type }, set: function(t) { this._type !== t && (this._enabled = t) } }), Object.defineProperty(o.prototype, "type", {
            get: function() { return this._type },
            set: function(t) {
                if (this._type === t) return;
                this._type = t, this.updateKey();
                const e = this._shadowType;
                this._shadowType = null, this.shadowType = e
            }
        }), Object.defineProperty(o.prototype, "mask", { get: function() { return this._mask }, set: function(t) { this._mask !== t && (this._mask = t) } }), Object.defineProperty(o.prototype, "renderMode", { get: function() { return this._renderMode }, set: function(t) { this._renderMode !== t && (this._renderMode = t) } }), Object.defineProperty(o.prototype, "cullingMask", { get: function() { return this._cullingMask }, set: function(t) { this._cullingMask !== t && (this._cullingMask = t) } }), Object.defineProperty(o.prototype, "shadowType", {
            get: function() { return this._shadowType },
            set: function(t) {
                if (this._shadowType === t) return;
                const e = pc.Application.getApplication().graphicsDevice;
                this._type === pc.LIGHTTYPE_POINT && (t = pc.SHADOW_PCF3), t !== pc.SHADOW_PCF5 || e.webgl2 || (t = pc.SHADOW_PCF3), t !== pc.SHADOW_VSM32 || e.textureFloatRenderable || (t = pc.SHADOW_VSM16), t !== pc.SHADOW_VSM16 || e.textureHalfFloatRenderable || (t = pc.SHADOW_VSM8), this._shadowType = t, this.updateKey()
            }
        }), Object.defineProperty(o.prototype, "castShadows", { get: function() { return this._castShadows && this._mask !== pc.MASK_LIGHTMAP && 0 !== this._mask }, set: function(t) { this._castShadows !== t && (this._castShadows = t, this.updateKey()) } }), Object.defineProperty(o.prototype, "outerConeAngle", { get: function() { return this._outerConeAngle }, set: function(t) { this._outerConeAngle !== t && (this._outerConeAngle = t, this._nodeAabbVer = -1) } }), Object.defineProperty(o.prototype, "intensity", { get: function() { return this._intensity }, set: function(t) { this._intensity !== t && (this._intensity = t, this._updateFinalColor()) } }), Object.defineProperty(o.prototype, "cookie", { get: function() { return this._cookie }, set: function(t) { this._cookie !== t && (this._cookie = t, this.updateKey()) } }), Object.defineProperty(o.prototype, "cookieScale", { get: function() { return this._cookieScale }, set: function(t) { this._cookieScale = t, this._nodeAabbVer = -1 } }), Object.defineProperty(o.prototype, "attenuationEnd", { get: function() { return this._attenuationEnd }, set: function(t) { this._attenuationEnd = t, this._nodeAabbVer = -1 } }), { Light: o }
    }()), Object.assign(pc, function() {
        let t = 0;
        const e = function() { this.name = "Untitled", this.id = t++, this._shader = null, this.parameters = {}, this.meshInstances = [], this.dirty = !0, this.enableAutoInstancing = !1 };
        Object.defineProperty(e.prototype, "shader", { get: function() { return this._shader }, set: function(t) { this._shader && this._shader._refCount--, this._shader = t, t && t._refCount++ } }), e.prototype.update = function() { this.dirty = !0 }, e.prototype.getParameter = function(t) { const e = this.parameters[t]; return e ? e.data : null };
        const i = function(t, e, i) { this.scopeId = t, this.data = e, this.passFlags = i };
        return e.prototype.setParameter = function(t, e, n) {
            if (void 0 === n && (n = -524285), void 0 === e && "object" == typeof t) {
                const i = t;
                if (i.length) { for (let t = 0; t < i.length; t++) this.setParameter(i[t]); return }
                t = i.name, e = i.value
            }
            const s = this.parameters[t];
            s ? (s.data = e, s.passFlags = n) : this.parameters[t] = new i(null, e, n)
        }, e.prototype.deleteParameter = function(t) { this.parameters[t] && delete this.parameters[t] }, e.prototype.update = function() {}, e.prototype.init = function(t) { throw Error("Not Implemented in base class") }, { Material: e }
    }()), Object.assign(pc, function() {
        const t = [null, null, pc.Vec2, pc.Vec3, pc.Vec4],
            e = new Float32Array([1, 1, 1, 1]),
            i = new Float32Array([0, 0, 0, 0]),
            n = new Float32Array([0, 0, 0, 1]),
            s = new Float32Array([1, 0, 0, 1]),
            r = new Float32Array([0, 0, 1, 1]),
            o = new pc.BoundingBox;
        const a = function(t) { this.name = "", this._refCount = 0, this.id = a.id++, this.vertexBuffer = t ? null : this.defaultVertexBuffer(this.defaultStreams, 0, new Float32Array), this.indexBuffer = [null], this.primitive = [{ type: 0, base: 0, count: 0 }], this.skin = null, this.morph = null, this.meshInstance = null, this._aabb = new pc.BoundingBox, this.bindposes = [], this.subMeshes = [], this.boneAabb = null, this.version = 0 };
        a.id = 0, Object.defineProperty(a.prototype, "aabb", { get: function() { return this.morph ? this.morph.aabb : this._aabb }, set: function(t) { this.morph ? (this._aabb = this.morph._baseAabb = t, this.morph._calculateAabb()) : this._aabb = t, this.version++ } }), pc.extend(a.prototype, {
            allStreams: [{ semantic: pc.SEMANTIC_POSITION, components: 3, type: pc.TYPE_FLOAT32 }, { semantic: pc.SEMANTIC_NORMAL, components: 3, type: pc.TYPE_FLOAT32 }, { semantic: pc.SEMANTIC_TANGENT, components: 4, type: pc.TYPE_FLOAT32 }, { semantic: pc.SEMANTIC_BLENDWEIGHT, components: 4, type: pc.TYPE_FLOAT32 }, { semantic: pc.SEMANTIC_BLENDINDICES, components: 4, type: pc.TYPE_FLOAT32 }, { semantic: pc.SEMANTIC_COLOR, components: 4, type: pc.TYPE_FLOAT32 }, { semantic: pc.SEMANTIC_TEXCOORD0, components: 2, type: pc.TYPE_FLOAT32 }, { semantic: pc.SEMANTIC_TEXCOORD1, components: 2, type: pc.TYPE_FLOAT32 }, { semantic: pc.SEMANTIC_TEXCOORD2, components: 2, type: pc.TYPE_FLOAT32 }, { semantic: pc.SEMANTIC_TEXCOORD3, components: 2, type: pc.TYPE_FLOAT32 }],
            defaultStreams: [!0, !1, !1, !1, !1, !1, !1, !1, !1, !1],
            uiVertexSemantics: [{ semantic: pc.SEMANTIC_POSITION, components: 3, type: pc.TYPE_FLOAT32 }, { semantic: pc.SEMANTIC_NORMAL, components: 3, type: pc.TYPE_FLOAT32 }, { semantic: pc.SEMANTIC_TANGENT, components: 4, type: pc.TYPE_FLOAT32 }, { semantic: pc.SEMANTIC_COLOR, components: 4, type: pc.TYPE_FLOAT32 }, { semantic: pc.SEMANTIC_TEXCOORD0, components: 2, type: pc.TYPE_FLOAT32 }, { semantic: pc.SEMANTIC_TEXCOORD1, components: 2, type: pc.TYPE_FLOAT32 }],
            destroy: function() { this.vertexBuffer && (this.vertexBuffer.destroy(), this.vertexBuffer = null); for (let t = 0; t < this.indexBuffer.length; t++) this.indexBuffer[t] && this.indexBuffer[t].destroy(), this.indexBuffer = [] },
            defaultVertexBuffer: function(t, e, i) { const n = []; for (let e = 0; e < t.length; e++) t[e] && n.push(this.allStreams[e]); const s = new pc.VertexFormat(UnityEngine.Graphics.graphicsDevice, n); return new pc.VertexBuffer(UnityEngine.Graphics.graphicsDevice, s, e, this.bufferUsage || pc.BUFFER_STATIC, i) },
            getDescriptionForSemantics: function(t, e) {
                if (e) return { semantic: t, components: e, type: pc.TYPE_FLOAT32 };
                for (let e = 0; e < this.allStreams.length; e++)
                    if (this.allStreams[e].semantic === t) return this.allStreams[e];
                throw new Error("Unknown or unsupported semantic requested: " + t)
            },
            defaultIndexBuffer: function(t, e) { return new pc.IndexBuffer(UnityEngine.Graphics.graphicsDevice, pc.INDEXFORMAT_UINT16, t, this.bufferUsage || pc.BUFFER_STATIC, e) },
            markDynamic: function() { this.vertexBuffer && (this.vertexBuffer.lock(), this.vertexBuffer.usage = pc.BUFFER_DYNAMIC, this.vertexBuffer.unlock()), this.indexBuffer[0] && (this.indexBuffer[0].lock(), this.indexBuffer[0].usage = pc.BUFFER_DYNAMIC, this.indexBuffer[0].unlock()), this.bufferUsage = pc.BUFFER_DYNAMIC },
            uploadMeshData: function() {
                this.vertexBuffer && this.vertexBuffer.unlock();
                for (let t = 0; t < this.subMeshes.length; t++) {
                    const e = this.subMeshes[t];
                    e.vertexBuffer = this.vertexBuffer, e.indexBuffer[0] && e.indexBuffer[0].unlock()
                }
            },
            clear: function() { this.vertexBuffer && this.vertexBuffer.resize(0), this.indexBuffer[0] && this.indexBuffer[0].resize(0), this.subMeshes = [this], this.version++ },
            setIndicies: function(t, e, i, n, s) {
                this.subMeshes.length >= i && this.setSubMeshCount(i + 1);
                const r = this.subMeshes[i];
                let o = null;
                switch (e) {
                    case UnityEngine.MeshTopology.Triangles:
                        o = pc.gfx.PRIMITIVE_TRIANGLES;
                        break;
                    case UnityEngine.MeshTopology.Lines:
                        o = pc.gfx.PRIMITIVE_LINES;
                        break;
                    case UnityEngine.MeshTopology.LineStrip:
                        o = pc.gfx.PRIMITIVE_LINESTRIP;
                        break;
                    case UnityEngine.MeshTopology.Points:
                        o = pc.gfx.PRIMITIVE_POINTS
                }
                if (null === o) throw new Error("Unknown or unsupported topology " + e + " passed!");
                r.primitive[0].type = o, r.primitive[0].base = s, r.primitive[0].count = t.length, r.primitive[0].indexed = !0, r.vertexBuffer = this.vertexBuffer, r.indexBuffer[0] = r.indexBuffer[0] || new pc.IndexBuffer(UnityEngine.Graphics.graphicsDevice, pc.INDEXFORMAT_UINT16, 0, pc.BUFFER_STATIC), r.indexBuffer[0].resize(t.length), new Uint16Array(r.indexBuffer[0].lock()).set(t), !1 !== n && this.recalculateBounds(), this.uploadMeshData(), this.version++
            },
            getIndicies: function(t) { const e = this.subMeshes[t]; return new Uint16Array(e.indexBuffer[0].lock()) },
            getUVInTriangle: function(t, e) {
                const i = this.vertexBuffer,
                    n = new pc.Vec2;
                let s = 3 * t;
                if (!i) return n;
                const r = i.format.getStructureFor(pc.SEMANTIC_TEXCOORD0);
                let o = 0,
                    a = this.subMeshes[o].indexBuffer[0].storage;
                for (; s >= a.length;) s -= a.length, o++, a = this.subMeshes[o].indexBuffer[0].storage;
                if (r.offset < 0) return n;
                const c = (a[s + e] * r.stride + r.offset) / 4,
                    h = new Float32Array(i.storage);
                return n.set(h[c + 0], h[c + 1]), n
            },
            getVectorStream: function(e, i, n) {
                const s = this.vertexBuffer;
                if (!s) return;
                const r = s.format.getStructureFor(i);
                if (r.offset < 0) return;
                const o = new Float32Array(s.storage),
                    a = new Array(s.numVertices);
                let c = 0;
                for (let e = r.offset / 4; e < o.length; e += r.stride / 4) {
                    const i = new t[n];
                    i.x = o[e + 0], i.y = o[e + 1], n > 2 && (i.z = o[e + 2]), n > 3 && (i.w = o[e + 3]), a[c++] = i
                }
                e._items = a, e._size = a.length
            },
            setVectorStream: function(t, e, i) {
                if (!t || 0 === t._size) return void this.disableSemantic(e);
                this.enableSemantic(e);
                const n = this.vertexBuffer;
                n.resize(Math.max(t._size, n.numVertices));
                const s = n.format.getStructureFor(e),
                    r = new Float32Array(n.storage);
                let o = 0;
                const a = t._size * s.stride / 4;
                switch (i) {
                    case 2:
                        for (let e = s.offset / 4; e < a; e += s.stride / 4) {
                            const i = t._items[o++];
                            r[e + 0] = i.x, r[e + 1] = i.y
                        }
                        break;
                    case 3:
                        for (let e = s.offset / 4; e < a; e += s.stride / 4) {
                            const i = t._items[o++];
                            r[e + 0] = i.x, r[e + 1] = i.y, r[e + 2] = i.z
                        }
                        break;
                    case 4:
                        for (let e = s.offset / 4; e < a; e += s.stride / 4) {
                            const i = t._items[o++];
                            r[e + 0] = i.x, r[e + 1] = i.y, r[e + 2] = i.z, r[e + 3] = i.w
                        }
                }
                this.meshInstance && this.meshInstance._aabbVer++, this.uploadMeshData(), this.version++
            },
            getColorStream: function(t, e, i) {
                const n = this.vertexBuffer;
                if (!n) return;
                const s = n.format.getStructureFor(e);
                if (s.offset < 0) return;
                const r = new Float32Array(n.storage),
                    o = new Array(n.numVertices);
                let a = 0;
                for (let t = s.offset / 4; t < r.length; t += s.stride / 4) {
                    const e = new pc.Color;
                    e.r = r[t + 0] * i, e.g = r[t + 1] * i, e.b = r[t + 2] * i, e.a = r[t + 3] * i, o[a++] = e
                }
                t._items = o, t._size = o.length
            },
            getUIVertexStream: function(t, e) {
                if (t._size = 0, e._size = 0, !this.vertexBuffer || !this.indexBuffer[0]) return;
                t._size = t._items.length = this.vertexBuffer.numVertices, e._size = e._items.length = this.primitive[0].count, e._items = Array.from(new Uint16Array(this.indexBuffer[0].storage));
                const i = new Float32Array(this.vertexBuffer.storage),
                    n = this.vertexBuffer.format.size / 4,
                    s = this.vertexBuffer.format.getStructureFor(pc.SEMANTIC_POSITION, !0),
                    r = this.vertexBuffer.format.getStructureFor(pc.SEMANTIC_NORMAL, !0),
                    o = this.vertexBuffer.format.getStructureFor(pc.SEMANTIC_TANGENT, !0),
                    a = this.vertexBuffer.format.getStructureFor(pc.SEMANTIC_COLOR, !0),
                    c = this.vertexBuffer.format.getStructureFor(pc.SEMANTIC_TEXCOORD0, !0),
                    h = this.vertexBuffer.format.getStructureFor(pc.SEMANTIC_TEXCOORD1, !0);
                for (let e = 0; e < i.length; e += n) {
                    const l = new UnityEngine.UIVertex;
                    let u = -1;
                    t._items[e / n | 0] = l, (u = s.offset) >= 0 && l.position.set(i[e + u + 0], i[e + u + 1], i[e + u + 2]), (u = r.offset) >= 0 && l.normal.set(i[e + u + 0], i[e + u + 1], i[e + u + 2]), (u = o.offset) >= 0 && l.tangent.set(i[e + u + 0], i[e + u + 1], i[e + u + 2], i[e + u + 3]), (u = a.offset) >= 0 && (l.color.r = 255 * i[e + u + 0] | 0, l.color.g = 255 * i[e + u + 1] | 0, l.color.b = 255 * i[e + u + 2] | 0, l.color.a = 255 * i[e + u + 3] | 0), (u = c.offset) >= 0 && l.uv0.set(i[e + u + 0], i[e + u + 1]), (u = h.offset) >= 0 && l.uv1.set(i[e + u + 0], i[e + u + 1])
                }
            },
            setUIVertexStream: function(t, e) {
                if (this.vertexBuffer) {
                    const t = this.uiVertexSemantics,
                        e = this.vertexBuffer.format;
                    if (e.elements.length !== t.length) this.vertexBuffer.destroy(), this.vertexBuffer = null;
                    else
                        for (let i = 0; i < t.length; i++)
                            if (e.elements[i].name !== t[i].semantic) { this.vertexBuffer.destroy(), this.vertexBuffer = null; break }
                }
                if (!this.vertexBuffer) {
                    const e = new pc.VertexFormat(UnityEngine.Graphics.graphicsDevice, this.uiVertexSemantics);
                    this.vertexBuffer = new pc.VertexBuffer(UnityEngine.Graphics.graphicsDevice, e, t._size, this.bufferUsage || pc.BUFFER_STATIC, null)
                }
                e._items.length = e._size, this.setIndicies(e._items, UnityEngine.MeshTopology.Triangles, 0, !0, 0), this.vertexBuffer.resize(t._size);
                const i = new Float32Array(this.vertexBuffer.storage);
                for (let e = 0; e < i.length; e += 18) {
                    const n = t._items[e / 18];
                    i[e + 0] = n.position.x, i[e + 1] = n.position.y, i[e + 2] = n.position.z, i[e + 3] = n.normal.x, i[e + 4] = n.normal.y, i[e + 5] = n.normal.z, i[e + 6] = n.tangent.x, i[e + 7] = n.tangent.y, i[e + 8] = n.tangent.z, i[e + 9] = n.tangent.w, i[e + 10] = n.color.r / 255, i[e + 11] = n.color.g / 255, i[e + 12] = n.color.b / 255, i[e + 13] = n.color.a / 255, i[e + 14] = n.uv0.x, i[e + 15] = n.uv0.y, i[e + 16] = n.uv1.x, i[e + 17] = n.uv1.y
                }
                this.uploadMeshData(), this.primitive[0].type = pc.gfx.PRIMITIVE_TRIANGLES, this.primitive[0].base = 0, this.primitive[0].count = e._items.length, this.primitive[0].indexed = !0
            },
            setColorStream: function(t, e, i) {
                if (!t || 0 === t._size) return void this.disableSemantic(e);
                this.enableSemantic(e);
                const n = this.vertexBuffer;
                n.resize(Math.max(t._size, n.numVertices));
                const s = n.format.getStructureFor(e),
                    r = new Float32Array(n.storage);
                let o = 0;
                const a = t._size * s.stride / 4,
                    c = 1 / i;
                for (let e = s.offset / 4; e < a; e += s.stride / 4) {
                    const i = t._items[o++];
                    r[e + 0] = i.r * c, r[e + 1] = i.g * c, r[e + 2] = i.b * c, r[e + 3] = i.a * c
                }
                this.uploadMeshData(), this.version++
            },
            initializeBuffers: function() { this.destroy(), this.vertexBuffer = new pc.VertexBuffer(UnityEngine.Graphics.graphicsDevice, new pc.VertexFormat(UnityEngine.Graphics.graphicsDevice, []), 0), this.vertexBuffer.numBytes = 0, this.vertexBuffer.numVertices = 0, this.indexBuffer = [new pc.IndexBuffer(UnityEngine.Graphics.graphicsDevice, pc.INDEXFORMAT_UINT16, 0, pc.BUFFER_STATIC)] },
            enableSemantic: function(t) {
                let e = this.vertexBuffer;
                e || (e = new pc.VertexBuffer(UnityEngine.Graphics.graphicsDevice, new pc.VertexFormat(UnityEngine.Graphics.graphicsDevice, []), 0), e.numBytes = 0, e.numVertices = 0, this.vertexBuffer = e);
                const i = e.format;
                if (i.getStructureFor(t).offset >= 0) return;
                const n = new Float32Array(e.storage),
                    s = [];
                for (let t = 0; t < i.elements.length; t++) {
                    const e = i.elements[t];
                    s.push({ semantic: e.name, type: e.dataType, components: e.numComponents, normalize: e.normalize })
                }
                s.push(this.getDescriptionForSemantics(t));
                const r = new pc.VertexFormat(UnityEngine.Graphics.graphicsDevice, s),
                    o = new Float32Array(r.size / 4 * e.numVertices);
                for (let t = 0; t < e.numVertices; t++)
                    for (let e = 0; e < i.size / 4; e++) o[t * r.size / 4 + e] = n[t * i.size / 4 + e];
                e.invalidateBuffer();
                const a = e.numVertices * e.format.size;
                e.device._vram.vb += a - e.numBytes, e.format = r, e.numBytes = a, e.storage = o.buffer
            },
            disableSemantic: function(t) {
                const e = this.vertexBuffer;
                if (!e) return;
                const i = e.format;
                if (i.getStructureFor(t).offset < 0) return;
                const n = this.getDescriptionForSemantics(t),
                    s = new Float32Array(e.storage),
                    r = [];
                for (let e = 0; e < i.elements.length; e++) {
                    const n = i.elements[e];
                    n.name !== t && r.push({ semantic: n.name, type: n.dataType, components: n.numComponents, normalize: n.normalize })
                }
                const o = new pc.VertexFormat(UnityEngine.Graphics.graphicsDevice, r),
                    a = new Float32Array(o.size / 4 * e.numVertices);
                let c = 0;
                for (let t = 0; t < e.numVertices; t++) {
                    const e = t - Math.floor(t / (o.size / 4));
                    e >= n.offset && e < n.offset + n.components || (a[c++] = s[t])
                }
                e.invalidateBuffer();
                const h = e.numVertices * e.format.size;
                e.device._vram.vb += h - e.numBytes, e.format = o, e.numBytes = h, e.storage = a.buffer
            },
            recalculateBounds: function() {
                const t = new pc.Vec3,
                    e = this.vertexBuffer.format.getStructureFor(pc.SEMANTIC_POSITION, !0);
                if (e.offset < 0) return void this._aabb.setMinMax(pc.Vec3.ZERO, pc.Vec3.ZERO);
                const i = new Float32Array(this.vertexBuffer.lock());
                this._aabb.setToInfinity();
                for (let n = 0; n < this.subMeshes.length; n++) {
                    const s = new pc.Vec3(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER),
                        r = new pc.Vec3(-Number.MAX_SAFE_INTEGER, -Number.MAX_SAFE_INTEGER, -Number.MAX_SAFE_INTEGER),
                        o = this.subMeshes[n],
                        a = new Uint16Array(o.indexBuffer[0].storage);
                    for (let n = 0; n < a.length; n++) {
                        const o = a[n] * e.stride + e.offset;
                        t.set(i[o + 0], i[o + 1], i[o + 2]), s.x = s.x > t.x ? t.x : s.x, s.y = s.y > t.y ? t.y : s.y, s.z = s.z > t.z ? t.z : s.z, r.x = r.x < t.x ? t.x : r.x, r.y = r.y < t.y ? t.y : r.y, r.z = r.z < t.z ? t.z : r.z
                    }
                    a.length > 0 ? o._aabb.setMinMax(s, r) : o._aabb.setToInfinity(), a.length > 0 && (this._aabb.expandToPoint(s), this._aabb.expandToPoint(r))
                }
            },
            getVertexArrayObject: function() {
                if (this.vao) return this.vao;
                const t = UnityEngine.Graphics.graphicsDevice;
                this.vao = t.gl.createVertexArray(), t.gl.bindVertexArray(this.vao), this.vertexBuffer.unlock(), this.indexBuffer[0].unlock();
                const o = this.vertexBuffer.format;
                for (let e = 0; e < 16; e++) t.gl.disableVertexAttribArray(e);
                t.gl.vertexAttrib4fv(pc.ShaderAttributeSlots.POSITION, n), t.gl.vertexAttrib4fv(pc.ShaderAttributeSlots.COLOR, e), t.gl.vertexAttrib4fv(pc.ShaderAttributeSlots.TANGENT, s), t.gl.vertexAttrib4fv(pc.ShaderAttributeSlots.NORMAL, r), t.gl.vertexAttrib4fv(pc.ShaderAttributeSlots.TEXCOORD0, i);
                for (let e = 0; e < o.elements.length; e++) {
                    const i = o.elements[e],
                        n = pc.ShaderAttributeSlots[i.name];
                    t.gl.enableVertexAttribArray(n), t.gl.vertexAttribPointer(n, i.numComponents, t.glType[i.dataType], i.normalize, i.stride, i.offset)
                }
                return t.gl.bindVertexArray(null), this.vao
            },
            setSubMeshCount: function(t) {
                for (let e = t; e < this.subMeshes.length; e++) this.subMeshes[e]._refCount = -1 / 0;
                this.subMeshes.length = t;
                for (let e = 0; e < t; e++) this.subMeshes[e] || (this.subMeshes[e] = new pc.Mesh(!0), this.subMeshes[e].vertexBuffer = this.vertexBuffer, this.subMeshes[e].indexBuffer = [new pc.IndexBuffer(UnityEngine.Graphics.graphicsDevice, pc.INDEXFORMAT_UINT16, 0, pc.BUFFER_STATIC)]);
                this.version++
            },
            recalculateNormals: function() {
                this.enableSemantic(pc.SEMANTIC_NORMAL);
                const t = this.vertexBuffer.format.getStructureFor(pc.SEMANTIC_POSITION, !0),
                    e = this.vertexBuffer.format.getStructureFor(pc.SEMANTIC_NORMAL, !0),
                    i = new Float32Array(this.vertexBuffer.lock()),
                    n = new pc.Vec3,
                    s = new pc.Vec3,
                    r = new pc.Vec3;
                let o = -1;
                for (let a = 0; a < this.subMeshes.length; a++) {
                    if (this.getTopology(a) !== UnityEngine.MeshTopology.Triangles) throw new Error("Cannot recalculate normals for non-triangle mesh");
                    const c = this.subMeshes[a],
                        h = new Uint16Array(c.indexBuffer[0].storage);
                    for (let a = 0; a < h.length; a += 3) o = h[a + 0] * t.stride + t.offset, n.set(i[o + 0], i[o + 1], i[o + 2]), o = h[a + 1] * t.stride + t.offset, s.set(i[o + 0], i[o + 1], i[o + 2]), o = h[a + 2] * t.stride + t.offset, r.set(i[o + 0], i[o + 1], i[o + 2]), s.sub(r), n.sub(r), r.cross(n, s), o = h[a + 0] * e.stride + e.offset, i[o + 0] = r.x, i[o + 1] = r.y, i[o + 2] = r.z, o = h[a + 1] * e.stride + e.offset, i[o + 0] = r.x, i[o + 1] = r.y, i[o + 2] = r.z, o = h[a + 2] * e.stride + e.offset, i[o + 0] = r.x, i[o + 1] = r.y, i[o + 2] = r.z
                }
                this.vertexBuffer.unlock()
            },
            recalculateTangents: function() {
                const t = this.vertexBuffer.format.getStructureFor(pc.SEMANTIC_TEXCOORD0, !0);
                if (t.offset < 0) return;
                this.enableSemantic(pc.SEMANTIC_TANGENT);
                const e = this.vertexBuffer.format.getStructureFor(pc.SEMANTIC_POSITION, !0),
                    i = this.vertexBuffer.format.getStructureFor(pc.SEMANTIC_TANGENT, !0),
                    n = new Float32Array(this.vertexBuffer.lock()),
                    s = new pc.Vec3,
                    r = new pc.Vec3,
                    o = new pc.Vec3,
                    a = new pc.Vec2,
                    c = new pc.Vec2,
                    h = new pc.Vec2,
                    l = new pc.Vec3;
                let u = -1;
                for (let d = 0; d < this.subMeshes.length; d++) {
                    if (this.getTopology(d) !== UnityEngine.MeshTopology.Triangles) throw new Error("Cannot recalculate tangents for non-triangle mesh");
                    const p = this.subMeshes[d],
                        _ = new Uint16Array(p.indexBuffer[0].storage);
                    for (let d = 0; d < _.length; d += 3) {
                        u = _[d + 0] * e.stride + e.offset, s.set(n[u + 0], n[u + 1], n[u + 2]), u = _[d + 1] * e.stride + e.offset, r.set(n[u + 0], n[u + 1], n[u + 2]), u = _[d + 2] * e.stride + e.offset, o.set(n[u + 0], n[u + 1], n[u + 2]), u = _[d + 0] * t.stride + t.offset, a.set(n[u + 0], n[u + 1]), u = _[d + 1] * t.stride + t.offset, c.set(n[u + 0], n[u + 1]), u = _[d + 2] * t.stride + t.offset, h.set(n[u + 0], n[u + 1]);
                        const p = c.x - a.x,
                            f = h.x - a.x,
                            m = c.x - h.x,
                            y = c.y - a.y,
                            g = h.y - a.y,
                            E = c.y - h.y,
                            A = Math.abs(p) + Math.abs(y),
                            b = Math.abs(f) + Math.abs(g),
                            C = Math.abs(m) + Math.abs(E);
                        A > b ? A > C ? (l.sub2(r, s), l.x *= p > 0 ? 1 : -1, l.y *= y > 0 ? 1 : -1) : (l.sub2(o, r), l.x *= m > 0 ? 1 : -1, l.y *= E > 0 ? 1 : -1) : b > C ? (l.sub2(o, s), l.x *= f > 0 ? 1 : -1, l.y *= g > 0 ? 1 : -1) : (l.sub2(o, r), l.x *= m > 0 ? 1 : -1, l.y *= E > 0 ? 1 : -1), u = _[d + 0] * i.stride + i.offset, n[u + 0] = l.x, n[u + 1] = l.y, n[u + 2] = l.z, n[u + 3] = 1, u = _[d + 1] * i.stride + i.offset, n[u + 0] = l.x, n[u + 1] = l.y, n[u + 2] = l.z, n[u + 3] = 1, u = _[d + 2] * i.stride + i.offset, n[u + 0] = l.x, n[u + 1] = l.y, n[u + 2] = l.z, n[u + 3] = 1
                    }
                }
                this.vertexBuffer.unlock()
            },
            getVertexCount: function() { return this.vertexBuffer ? this.vertexBuffer.numVertices : 0 },
            getTopology: function(t) {
                const e = this.subMeshes[t];
                switch (e.primitive[0].type) {
                    case pc.gfx.PRIMITIVE_TRIANGLES:
                        return UnityEngine.MeshTopology.Triangles;
                    case pc.gfx.PRIMITIVE_LINES:
                        return UnityEngine.MeshTopology.Lines;
                    case pc.gfx.PRIMITIVE_LINESTRIP:
                        return UnityEngine.MeshTopology.LineStrip;
                    case pc.gfx.PRIMITIVE_POINTS:
                        return UnityEngine.MeshTopology.Points
                }
                throw new Error("Mesh's topology is set to " + e.primitive[0].type + ", which is not suppored by Unity API")
            },
            configureIndexBufferAsTriangleStrip: function(t, e) { this.primitive[t].type = pc.gfx.PRIMITIVE_TRISTRIP, this.primitive[t].base = 0, this.primitive[t].count = e, this.primitive[t].indexed = !0 },
            configureIndexBufferAsTriangles: function(t, e) { this.primitive[t].type = pc.gfx.PRIMITIVE_TRIANGLES, this.primitive[t].base = 0, this.primitive[t].count = e, this.primitive[t].indexed = !0 },
            clone: function() {
                const t = new pc.Mesh;
                t.name = this.name + " Instance", t.aabb.copy(this.aabb);
                const e = pc.ShaderAttributeSlots,
                    i = [];
                Object.assign(i, this.defaultStreams);
                const n = this.vertexBuffer.format.elements;
                for (let t = 0; t < n.length; t++) i[e[n[t].name]] = !0;
                const s = t.defaultVertexBuffer(i, this.getVertexCount(), this.vertexBuffer.storage.slice(0, this.vertexBuffer.storage.byteLength));
                t.vertexBuffer = s, t.subMeshes = [];
                for (let e = 0; e < this.subMeshes.length; e++) {
                    const i = this.subMeshes[e],
                        n = i.indexBuffer[0],
                        r = n.storage.slice(0, n.storage.byteLength),
                        o = new Uint16Array(r),
                        a = new pc.Mesh(!0);
                    a.aabb.copy(i.aabb);
                    const c = t.defaultIndexBuffer(o.length, o);
                    a.vertexBuffer = s, a.indexBuffer[0] = c, a.primitive[0].type = pc.gfx.PRIMITIVE_TRIANGLES, a.primitive[0].base = 0, a.primitive[0].count = o.length, a.primitive[0].indexed = !0, t.subMeshes.push(a)
                }
                t.indexBuffer = t.subMeshes[0].indexBuffer, t.primitive[0].type = pc.gfx.PRIMITIVE_TRIANGLES, t.primitive[0].base = 0, t.primitive[0].count = t.indexBuffer[0].numIndices, t.primitive[0].indexed = !0;
                for (let e = 0; e < this.bindposes.length; e++) t.bindposes.push(this.bindposes[e].clone());
                return t
            }
        });
        const c = function(t, e, i) { this._key = [0, 0], this.id = a.id++, this.isStatic = !1, this.node = t, this._mesh = e, e._refCount++, e.meshInstance = this, this.material = i, this._shaderDefs = 0, this._shaderDefs |= e.vertexBuffer.format.hasUv0 ? pc.SHADERDEF_UV0 : 0, this._shaderDefs |= e.vertexBuffer.format.hasUv1 ? pc.SHADERDEF_UV1 : 0, this._shaderDefs |= e.vertexBuffer.format.hasColor ? pc.SHADERDEF_VCOLOR : 0, this._shaderDefs |= e.vertexBuffer.format.hasTangents ? pc.SHADERDEF_TANGENTS : 0, this._lightHash = 0, this.visible = !0, this._receiveShadow = !0, this.cull = !0, this.pick = !0, this.drawOrder = 0, this.sortingLayerIndex = 0, this.sortingOrder = 0, this.updateKey(), this._skinInstance = null, this.morphInstance = null, this.instancingData = null, this.aabb = new pc.BoundingBox, this._boneAabb = null, this._aabbVer = -1, this.drawOrder = 0, this.visibleThisFrame = 0, this.parameters = {}, this._lightProbe = null, this.stencilFront = null, this.stencilBack = null, this.lightmapIndex = -1, this.lightmapSceneIndex = -1, this.isCanvas = !1 };
        return Object.defineProperty(c.prototype, "mesh", { get: function() { return this._mesh }, set: function(t) { this._mesh && this._mesh._refCount--, this._mesh = t, t && t._refCount++ } }), Object.defineProperty(c.prototype, "aabb", {
            get: function() {
                if (this.worldAabbOverride) return this.worldAabbOverride;
                let t;
                if (this.skinInstance) {
                    const e = this.mesh.skin.boneNames.length + 5;
                    let i, n;
                    if (!this.mesh.boneAabb) {
                        this.mesh.boneAabb = [], this.mesh.boneUsed = [];
                        const s = this.mesh.vertexBuffer.format.elements,
                            r = this.mesh.vertexBuffer.numVertices,
                            o = this.mesh.vertexBuffer.format.size;
                        let a, c, h, l, u, d, p;
                        for (n = 0; n < s.length; n++) s[n].name === pc.SEMANTIC_POSITION ? c = s[n].offset : s[n].name === pc.SEMANTIC_BLENDINDICES ? h = s[n].offset : s[n].name === pc.SEMANTIC_BLENDWEIGHT && (l = s[n].offset);
                        const _ = new Float32Array(this.mesh.vertexBuffer.storage),
                            f = new Float32Array(this.mesh.vertexBuffer.storage),
                            m = c / 4,
                            y = l / 4,
                            g = h / 4,
                            E = o / 4;
                        let A, b, C, T, S;
                        const M = [],
                            x = [];
                        for (i = this.mesh.boneUsed, n = 0; n < e; n++) M[n] = new pc.Vec3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), x[n] = new pc.Vec3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
                        for (u = 0; u < r; u++)
                            for (d = 0; d < 4; d++) f[u * E + y + d] > 0 && (a = _[u * E + g + d], C = f[u * E + m], T = f[u * E + m + 1], S = f[u * E + m + 2], A = x[a], b = M[a], b.x > C && (b.x = C), b.y > T && (b.y = T), b.z > S && (b.z = S), A.x < C && (A.x = C), A.y < T && (A.y = T), A.z < S && (A.z = S), i[a] = !0);
                        if (this.morphInstance) {
                            let t;
                            const e = this.morphInstance.morph._targets,
                                i = new Float32Array(3 * r),
                                n = new Float32Array(3 * r);
                            let s, o, a, c, h, l, _;
                            for (u = 0; u < r; u++) i[3 * u] = n[3 * u] = f[u * E + m], i[3 * u + 1] = n[3 * u + 1] = f[u * E + m + 1], i[3 * u + 2] = n[3 * u + 2] = f[u * E + m + 2];
                            for (p = 0; p < e.length; p++) {
                                c = e[p];
                                for (let e = 0; e < c.frames.length; e++)
                                    for (h = c.frames[e].indices, l = h.length, _ = c.frames[e].deltaPositions, d = 0; d < l; d++) t = h[d], s = _[3 * d], o = _[3 * d + 1], a = _[3 * d + 2], s < 0 ? i[3 * t] += s : n[3 * t] += s, o < 0 ? i[3 * t + 1] += o : n[3 * t + 1] += o, a < 0 ? i[3 * t + 2] += a : n[3 * t + 2] += a
                            }
                        }
                        for (n = 0; n < e; n++) t = new pc.BoundingBox, t.setMinMax(M[n], x[n]), this.mesh.boneAabb.push(t)
                    }
                    if (!this._boneAabb)
                        for (this._boneAabb = [], n = 0; n < this.mesh.boneAabb.length; n++) this._boneAabb[n] = new pc.BoundingBox;
                    for (i = this.mesh.boneUsed, n = 0; n < this.mesh.boneAabb.length; n++) i[n] && this._boneAabb[n].setFromTransformedAabb(this.mesh.boneAabb[n], this.skinInstance.matrices[n]);
                    const s = this.node.getWorldTransform();
                    let r = !0;
                    for (n = 0; n < this.mesh.boneAabb.length; n++) i[n] && (r ? (o.center.copy(this._boneAabb[n].center), o.halfExtents.copy(this._boneAabb[n].halfExtents), r = !1) : o.add(this._boneAabb[n]));
                    this._aabb.setFromTransformedAabb(o, s)
                } else this.node._aabbVer !== this._aabbVer && (t = this.mesh ? this.mesh.aabb : this._aabb, this.mesh || t.setToInfinity(), this._aabb.setFromTransformedAabb(t, this.parameters.localToWorldMatrix || this.node.getWorldTransform()), this._aabbVer = this.node._aabbVer);
                return this._aabb
            },
            set: function(t) { this._aabb = t }
        }), Object.defineProperty(c.prototype, "worldAabbOverride", { get: function() { return this._worldAabbOverride }, set: function(t) { this._worldAabbOverride = t } }), Object.defineProperty(c.prototype, "material", { get: function() { return this._material }, set: function(t) { this._material = t } }), Object.defineProperty(c.prototype, "skinInstance", { get: function() { return this._skinInstance }, set: function(t) { this._skinInstance = t, this._shaderDefs = t ? this._shaderDefs | pc.SHADERDEF_SKIN : this._shaderDefs & ~pc.SHADERDEF_SKIN } }), Object.defineProperty(c.prototype, "morphInstance", { get: function() { return this._morphInstance }, set: function(t) { this._morphInstance = t } }), Object.defineProperty(c.prototype, "key", { get: function() { return this._key[pc.SORTKEY_FORWARD] }, set: function(t) { this._key[pc.SORTKEY_FORWARD] = t } }), Object.defineProperty(c.prototype, "renderQueue", { get: function() { return this.material ? this.material.renderQueue : 2e3 } }), Object.defineProperty(c.prototype, "isIndexBufferEmpty", { get: function() { return this.mesh.indexBuffer[0].length <= 0 } }), Object.assign(c.prototype, {
            updateKey: function() {
                const t = this.material,
                    e = 2e7 - 1e3 * ((t ? t.renderQueue : null) || 2e3) + (t ? t.id : 0);
                this._key[pc.SORTKEY_FORWARD] = function(t, e) { return (t ? 1 : 0) << 26 | (33554431 & e) << 0 }(!1, e)
            },
            configureLightmap: function() {
                const t = UnityEngine.LightmapSettings.manager.getLightmap(this.lightmapSceneIndex, this.lightmapIndex);
                t && t.lightmapColor ? this.setParameter("unity_Lightmap", t.lightmapColor.handle) : this.setParameter("unity_Lightmap", null), (this._shaderDefs & pc.SHADERDEF_DIRLM) > 0 && (t && t.lightmapDirection ? this.setParameter("unity_LightmapInd", t.lightmapDirection.handle) : this.setParameter("unity_LightmapInd", null))
            },
            getParameter: pc.Material.prototype.getParameter,
            setParameter: pc.Material.prototype.setParameter,
            deleteParameter: pc.Material.prototype.deleteParameter
        }), { Mesh: a, MeshInstance: c }
    }()), Object.assign(pc, function() {
        const t = new pc.Mat4,
            e = function(t) {
                this.skin = t, this._dirty = !0, this.bones = [];
                const e = t.inverseBindPose.length,
                    i = t.device;
                if (i.supportsBoneTextures) {
                    let t;
                    t = e > 256 ? 64 : e > 64 ? 32 : e > 16 ? 16 : 8, this.boneTexture = new pc.Texture(i, { width: t, height: t, format: pc.PIXELFORMAT_RGBA32F, mipmaps: !1, minFilter: pc.FILTER_NEAREST, magFilter: pc.FILTER_NEAREST }), this.matrixPalette = this.boneTexture.lock()
                } else this.matrixPalette = new Float32Array(16 * e);
                this.matrices = [], this.bonesAabbVersions = [];
                for (let t = 0; t < e; t++) this.matrices[t] = new pc.Mat4, this.bonesAabbVersions[t] = -1
            };
        return Object.assign(e.prototype, {
            updateMatrices: function(e) { t.copy(e.getWorldTransform()).invert(); for (let e = this.bones.length - 1; e >= 0; e--) null !== this.bones[e] && (this.matrices[e].mul2(t, this.bones[e].getWorldTransform()), this.matrices[e].mul2(this.matrices[e], this.skin.inverseBindPose[e])) },
            updateMatrixPalette: function() {
                let t;
                const e = this.matrixPalette;
                let i;
                for (let n = this.bones.length - 1; n >= 0; n--) t = this.matrices[n].data, i = 16 * n, e[i] = t[0], e[i + 1] = t[1], e[i + 2] = t[2], e[i + 3] = t[3], e[i + 4] = t[4], e[i + 5] = t[5], e[i + 6] = t[6], e[i + 7] = t[7], e[i + 8] = t[8], e[i + 9] = t[9], e[i + 10] = t[10], e[i + 11] = t[11], e[i + 12] = t[12], e[i + 13] = t[13], e[i + 14] = t[14], e[i + 15] = t[15];
                this.skin.device.supportsBoneTextures && (this.boneTexture.lock(), this.boneTexture.unlock())
            }
        }), { Skin: function(t, e, i) { this.device = t, this.inverseBindPose = e, this.boneNames = i }, SkinInstance: e }
    }()), Object.assign(pc, function() {
        const t = new pc.Vec3,
            e = new pc.Vec3,
            i = function(t) { this.frames = t ? t.frames : [], this.name = t ? t.name : "", this.aabb = t ? t.aabb : void 0 };
        i.prototype = new i, Object.defineProperty(i.prototype, "indices", { get: function() { return this.frames[0].indices } });
        const n = function(t) { this.aabb = new pc.BoundingBox, this._baseBuffer = null, this._baseAabb = null, this._targets = t, this._dirty = !0, this._aabbDirty = !0, this._baseData = null, this._offsetPF = 0, this._offsetNF = 0, this._offsetTF = 0, this._vertSizeF = 0 };
        Object.assign(n.prototype, {
            _setBaseMesh: function(t) {
                this._baseBuffer = t.vertexBuffer, this._baseAabb = t._aabb, this._baseData = new Float32Array(this._baseBuffer.storage);
                let e = -1,
                    i = -1,
                    n = -1;
                const s = this._baseBuffer.format.elements,
                    r = this._baseBuffer.format.size;
                for (let t = 0; t < s.length; t++) s[t].name === pc.SEMANTIC_POSITION ? e = s[t].offset : s[t].name === pc.SEMANTIC_NORMAL ? i = s[t].offset : s[t].name === pc.SEMANTIC_TANGENT && (n = s[t].offset);
                this._offsetPF = e / 4, this._offsetNF = i / 4, this._offsetTF = n / 4, this._vertSizeF = r / 4, this._dirty = !0
            },
            _calculateAabb: function() {
                if (!this._baseBuffer) return;
                let i, n, s, r, o, a, c, h, l;
                this.aabb.copy(this._baseAabb);
                const u = this._vertSizeF,
                    d = this._offsetPF,
                    p = this._baseData;
                for (n = 0; n < this._targets.length; n++) {
                    if (r = this._targets[n], !r.aabb && r.indices.length > 0) {
                        r.aabb = this.aabb.clone(), t.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), e.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE), i = r.indices.length;
                        for (let n = 0; n < r.frames.length; n++) { const _ = r.frames[n]; for (s = 0; s < i; s++) o = r.indices[s], a = o * u + d, c = p[a] + _[3 * s], h = p[a + 1] + _[3 * s + 1], l = p[a + 2] + _[3 * s + 2], t.x > c && (t.x = c), t.y > h && (t.y = h), t.z > l && (t.z = l), e.x < c && (e.x = c), e.y < h && (e.y = h), e.z < l && (e.z = l) }
                        r.aabb.setMinMax(t, e)
                    }
                    r.aabb && this.aabb.add(r.aabb)
                }
                this._aabbDirty = !1
            },
            addTarget: function(t) { this._targets.push(t), this._aabbDirty = !0 },
            removeTarget: function(t) { const e = this._targets.indexOf(t); - 1 !== e && (this._targets.splice(e, 1), this._aabbDirty = !0) },
            getTarget: function(t) { return this._targets[t] }
        });
        const s = function(t) { this.morph = t, this._vertexBuffer = null, this._vertexData = null, this.weights = {}, this._dirty = !0 };
        return Object.assign(s.prototype, {
            _setBaseMesh: function(t) {
                this.destroy(), this._vertexBuffer = new pc.VertexBuffer(this.morph._baseBuffer.device, this.morph._baseBuffer.format, this.morph._baseBuffer.numVertices, pc.BUFFER_DYNAMIC, this.morph._baseBuffer.storage.slice(0)), this._vertexData = new Float32Array(this._vertexBuffer.storage), this.weights = {};
                for (let t = 0; t < this.morph._targets.length; t++) this.weights[this.morph._targets[t].name] = 0;
                this._dirty = !0
            },
            destroy: function() { this._vertexBuffer && (this._vertexBuffer.destroy(), this._vertexBuffer = null) },
            getWeight: function(t) { return Object.values(this.weights)[t] },
            setWeight: function(t, e) {
                const i = Object.keys(this.weights)[t];
                this.weights[i] = e, this._dirty = !0
            },
            updateBounds: function(t) { this.morph._baseBuffer !== t.vertexBuffer && this.morph._setBaseMesh(t), this._vertexData || this._setBaseMesh(t), this.morph._aabbDirty && this.morph._calculateAabb() },
            update: function(t) {
                this.morph._baseBuffer !== t.vertexBuffer && this.morph._setBaseMesh(t), this._vertexData || this._setBaseMesh(t);
                const e = this.morph._targets,
                    i = Object.values(this.weights);
                let n, s;
                this._vertexData.set(this.morph._baseData);
                for (let t = 0; t < e.length; t++) {
                    if (s = i[t], 0 === s) continue;
                    n = e[t];
                    const r = n.frames;
                    if (1 === r.length && this._applyFrame(r[0], s, n), r.length > 1) {
                        if (s < r[0].weight) {
                            const t = r[0],
                                e = s / t.weight;
                            this._applyFrame(t, e, n);
                            continue
                        }
                        if (s > r[r.length - 1].weight) {
                            const t = r[r.length - 1],
                                e = s / t.weight;
                            this._applyFrame(t, e, n);
                            continue
                        }
                        if (2 === r.length) {
                            const t = r[0],
                                e = r[1];
                            this._applyFrame(t, 1, n);
                            const i = (s - t.weight) / (e.weight - t.weight);
                            this._applyFrame(e, i, n);
                            continue
                        }
                        let t, e;
                        for (let i = 0; i < r.length - 1 && (t = i, e = i + 1, !(r[t].weight < s && s < r[e].weight)); i++);
                        const i = (s - r[t].weight) / (r[e].weight - r[t].weight);
                        this._applyFrame(r[t], 1 - i, n), this._applyFrame(r[e], i, n)
                    }
                }
                this._vertexBuffer.unlock()
            },
            _applyFrame: function(t, e, i) {
                e /= 100;
                const n = t.indices.length,
                    s = this.morph._vertSizeF,
                    r = this.morph._offsetPF,
                    o = this.morph._offsetNF,
                    a = this.morph._offsetTF,
                    c = this._vertexData;
                for (let o = 0; o < n; o++) {
                    const n = t.deltaPositions,
                        a = 3 * o,
                        h = i.indices[o] * s + r;
                    c[h] += n[a] * e, c[h + 1] += n[a + 1] * e, c[h + 2] += n[a + 2] * e
                }
                if (t.deltaNormals) {
                    const r = t.deltaNormals;
                    for (let t = 0; t < n; t++) {
                        const n = 3 * t,
                            a = i.indices[t] * s + o;
                        c[a] += r[n] * e, c[a + 1] += r[n + 1] * e, c[a + 2] += r[n + 2] * e
                    }
                }
                if (t.deltaTangents) {
                    const r = t.deltaTangents;
                    for (let t = 0; t < n; t++) {
                        const n = 4 * t,
                            o = i.indices[t] * s + a;
                        c[o] += r[n] * e, c[o + 1] += r[n + 1] * e, c[o + 2] += r[n + 2] * e, c[o + 3] += r[n + 3] * e, c[o + 3] = c[o + 3] > 0 ? 1 : -1
                    }
                }
            }
        }), {
            MorphTarget: i,
            MorphTargetFrame: function(t) {
                const e = t.deltaPositions;
                this.indices = [], this.indices.length = e.length;
                for (let t = 0; t < e.length; t++) this.indices[t] = t;
                this.deltaPositions = t.deltaPositions, this.deltaNormals = t.deltaNormals, this.deltaTangents = t.deltaTangents, this.weight = t.weight
            },
            Morph: n,
            MorphInstance: s
        }
    }()), Object.assign(pc, function() {
        const t = function() { this.meshInstances = [], this.morphInstance = null, this._materials = [], this._mesh = null, this._skin = null, this._bones = null, this._sortingLayerIndex = 0, this._sortingOrder = 0, this._cullingLayer = 0, this._entity = null, this._lightmapIndex = -1, this._lightmapSceneIndex = 0, this._lightmapScaleOffset = new pc.Vec4, this._sortingLayerIndex = 0, this._sortingOrder = 0, this._drawOrder = 0, this._nearestScreen = null, this._stencil = null, this._element = null, this._visible = !0, this._parameters = {}, this._constAttributes = {}, this._isStatic = !1, this._needsUpdate = !0, this._masksChildren = !1 };
        return Object.assign(t.prototype, {
            setParameter: function(t, e) { this._parameters[t] = e, this._needsUpdate || this._updateParameters() },
            deleteParameter: function(t) { delete this._parameters[t], this._needsUpdate || this._updateParameters() },
            setConstant: function(t, e) { this._constAttributes[t] = e, this._needsUpdate || this._updateConstants() },
            deleteConstant: function(t) { delete this._constAttributes[t], this._needsUpdate || this._updateConstants() },
            setLightProbe: function(t, e) { this._lightProbe = t, this._updateLightProbe(e) },
            update: function() { this._needsUpdate && (this._needsUpdate = !1, this._configureMeshInstances()) },
            setMeshDirectlyToMeshInstance: function(t) {
                if (0 === this.meshInstances.length) this.mesh !== t && (this.mesh = t);
                else {
                    const e = this.meshInstances[0];
                    e.mesh !== t && (e.mesh = t)
                }
            },
            setBlendShapeWeight: function(t, e) { this.morphInstance ? this.morphInstance.setWeight(t, e) : console.error("SetBlendShapeWeight called for non blendable mesh.") },
            _configureMeshInstances: function() {
                if (!this._mesh) return void(this.meshInstances.length = 0);
                if (!this._materials) return void console.log("Missing materials on " + this.entity.name);
                const t = this._mesh.subMeshes.length,
                    e = this._materials.length;
                let i = 0,
                    n = !1;
                i = 1 === t ? Math.max(1, e) : t, this.meshInstances.length = i;
                for (let t = 0; t < this.meshInstances.length; t++) {
                    const e = this._materials[Math.min(this._materials.length - 1, t)],
                        i = this._mesh.subMeshes[Math.min(this._mesh.subMeshes.length - 1, t)];
                    if (this.meshInstances[t]) {
                        const s = this.meshInstances[t].mesh !== i;
                        n = n || s || this.meshInstances[t].material !== e, this.meshInstances[t].mesh = i, this.meshInstances[t].material = e, s && (this.meshInstances[t]._aabbVer = -1)
                    } else this.meshInstances[t] = new pc.MeshInstance(this.entity, i, e), n = !0, this.morphInstance && (this.meshInstances[t].morphInstance = this.morphInstance)
                }
                this.entity && (this._flipFaces = this.entity._isOddlyScaled()), this._updateParameters(), this._updateConstants(), this._updateSkin(), this._updateFlipFaces(), this._updateSortingIndexes(), this._updateCulling(), this._updateEntity(), this._configureLightmaps(), this._updateLightProbe(), this._updateReflectionProbes(), this._updateReflectionProbesBlending(), this._updateVisibility(), this._updateElement(), this._updateNearestScreen(), this._updateDrawOrder(), this._updateStencil(), this._updateMasksChildren()
            },
            _configureLightmaps: function() {
                if (!this._mesh) return;
                let t = 0;
                this._mesh.vertexBuffer.format.hasUv1 || (t |= pc.SHADERDEF_LMUV0), 1 === UnityEngine.LightmapSettings.environmentLightingMode && (t |= pc.SHADERDEF_LM_BAKED_AMBIENT), UnityEngine.LightmapSettings.lightmapsMode === UnityEngine.LightmapsMode.CombinedDirectional && (t |= pc.SHADERDEF_DIRLM);
                for (let e = 0; e < this.meshInstances.length; e++) { const i = this.meshInstances[e];!this._lightmapScaleOffset || this._lightmapIndex < 0 ? (i._shaderDefs &= ~(pc.SHADERDEF_LM | pc.SHADERDEF_DIRLM | pc.SHADERDEF_LMUV0 | pc.SHADERDEF_LM_DLDR), i.deleteParameter("unity_Lightmap"), i.deleteParameter("unity_LightmapInd"), i.deleteParameter("unity_LightmapST")) : (i._shaderDefs |= t | pc.SHADERDEF_LM, i.setParameter("unity_LightmapST", [this._lightmapScaleOffset.x, this._lightmapScaleOffset.y, this._lightmapScaleOffset.z, this._lightmapScaleOffset.w]), i.lightmapIndex = this._lightmapIndex, i.lightmapSceneIndex = this._lightmapSceneIndex) }
            },
            _updateParameters: function() {
                const t = Object.keys(this._parameters);
                for (let e = 0; e < this.meshInstances.length; e++) {
                    const i = this.meshInstances[e];
                    i.parameters = {};
                    for (let e = 0; e < t.length; e++) i.setParameter(t[e], this._parameters[t[e]])
                }
            },
            _updateConstants: function() {
                const t = Object.keys(this._constAttributes);
                for (let e = 0; e < this.meshInstances.length; e++) {
                    const i = this.meshInstances[e];
                    i.constAttributes = {};
                    for (let e = 0; e < t.length; e++) i.constAttributes[t[e]] = this._constAttributes[t[e]]
                }
            },
            _updateSkin: function() {
                if (!this._skin) return;
                const t = new pc.SkinInstance(this._skin);
                t.bones = this._bones;
                for (let e = 0; e < this.meshInstances.length; e++) this.meshInstances[e].mesh.skin = this._skin, this.meshInstances[e].skinInstance = t
            },
            _updateSortingIndexes: function() { for (let t = 0; t < this.meshInstances.length; t++) this.meshInstances[t].sortingLayerIndex = this._sortingLayerIndex, this.meshInstances[t].sortingOrder = this._sortingOrder },
            _updateFlipFaces: function() { for (let t = 0; t < this.meshInstances.length; t++) this.meshInstances[t]._flipFaces = this._flipFaces },
            _updateReflectionProbes: function() {
                const t = this._reflectionProbes ? this._reflectionProbes[0] : null,
                    e = this._reflectionProbes ? this._reflectionProbes[1] : null,
                    i = pc.reflectionProbeUniforms;
                for (let n = 0; n < this.meshInstances.length; n++) {
                    const s = this.meshInstances[n];
                    if (null != t) {
                        const e = t.getBox(s.aabb);
                        s.setParameter(i[0], t.cubemap), s.setParameter(i[1], e.min.data), s.setParameter(i[2], e.max.data), s.setParameter(i[3], e.position.data)
                    } else s.deleteParameter(i[0]), s.deleteParameter(i[1]), s.deleteParameter(i[2]), s.deleteParameter(i[3]);
                    if (null != e) {
                        const t = e.getBox(s.aabb);
                        s.setParameter(i[4], e.cubemap), s.setParameter(i[5], t.min.data), s.setParameter(i[6], t.max.data), s.setParameter(i[7], t.position.data)
                    } else s.deleteParameter(i[4]), s.deleteParameter(i[5]), s.deleteParameter(i[6]), s.deleteParameter(i[7])
                }
            },
            _updateReflectionProbesBlending: function() {
                for (let t = 0; t < this.meshInstances.length; t++) {
                    const e = this.meshInstances[t];
                    this._blendReflectionProbes ? e._shaderDefs |= pc.SHADERDEF_BLEND_REFLECTION_PROBES : e._shaderDefs &= ~pc.SHADERDEF_BLEND_REFLECTION_PROBES
                }
            },
            _updateLightProbe: function() {
                const t = (!this._lightmapScaleOffset || this._lightmapIndex < 0) && this.lightProbeUsage;
                for (let e = 0; e < this.meshInstances.length; e++) {
                    const i = this.meshInstances[e];
                    t ? (i._shaderDefs |= pc.SHADERDEF_LIGHTPROBES, i._lightProbe = this._lightProbe) : (i._shaderDefs &= ~pc.SHADERDEF_LIGHTPROBES, i._lightProbe = null)
                }
            },
            _updateCulling: function() { for (let t = 0; t < this.meshInstances.length; t++) this.meshInstances[t].mask = 1 << this._cullingLayer },
            _updateVisibility: function() { for (let t = 0; t < this.meshInstances.length; t++) this.meshInstances[t].visible = this._visible },
            _updateEntity: function() { for (let t = 0; t < this.meshInstances.length; t++) this.meshInstances[t].node = this.entity },
            _updateElement: function() { for (let t = 0; t < this.meshInstances.length; t++) this.meshInstances[t]._element = this._element },
            _updateNearestScreen: function() { for (let t = 0; t < this.meshInstances.length; t++) this.meshInstances[t]._nearestScreen = this._nearestScreen },
            _updateDrawOrder: function() { for (let t = 0; t < this.meshInstances.length; t++) this.meshInstances[t].drawOrder = this._drawOrder },
            _updateStencil: function() {
                for (let t = 0; t < this.meshInstances.length; t++) {
                    const e = this.meshInstances[t];
                    e.stencilBack = this._stencil, e.stencilFront = this._stencil, this._stencil ? e._shaderDefs |= pc.SHADERDEF_STENCIL_OVERRIDE : e._shaderDefs &= ~pc.SHADERDEF_STENCIL_OVERRIDE
                }
            },
            _updateMasksChildren: function() {
                for (let t = 0; t < this.meshInstances.length; t++) {
                    const e = this.meshInstances[t];
                    this._masksChildren ? e._shaderDefs |= pc.SHADERDEF_UI_MASK : e._shaderDefs &= ~pc.SHADERDEF_UI_MASK
                }
            },
            destroy: function() {
                const t = this.meshInstances;
                let e, i, n, s, r, o, a, c;
                for (let h = 0; h < t.length; h++) {
                    if (e = t[h], i = e.mesh, i && (i._refCount--, i._refCount < 1)) {
                        for (i.vertexBuffer && (c = c || i.vertexBuffer.device, i.vertexBuffer.destroy(), i.vertexBuffer = null), a = 0; a < i.indexBuffer.length; a++) c = c || i.indexBuffer.device, r = i.indexBuffer[a], r && r.destroy();
                        i.indexBuffer.length = 0
                    }
                    n = e.skinInstance, n && (o = n.boneTexture, o && o.destroy()), e.skinInstance = null, s = e.morphInstance, s && s.destroy(), e.morphInstance = null, e.material = null
                }
            }
        }), Object.defineProperty(t.prototype, "visible", { get: function() { return this._visible }, set: function(t) { this._visible = t, this._needsUpdate || this._updateVisibility() } }), Object.defineProperty(t.prototype, "stencil", { get: function() { return this._stencil }, set: function(t) { this._stencil = t, this._needsUpdate || this._updateStencil() } }), Object.defineProperty(t.prototype, "element", { get: function() { return this._element }, set: function(t) { this._element = t, this._needsUpdate || this._updateElement() } }), Object.defineProperty(t.prototype, "nearestScreen", { get: function() { return this._nearestScreen }, set: function(t) { this._nearestScreen = t, this._needsUpdate || this._updateNearestScreen() } }), Object.defineProperty(t.prototype, "lightmapIndex", { get: function() { return this._lightmapIndex }, set: function(t) { this._lightmapIndex = t, this._needsUpdate || this._configureLightmaps() } }), Object.defineProperty(t.prototype, "lightmapScaleOffset", { get: function() { return this._lightmapScaleOffset }, set: function(t) { this._lightmapScaleOffset = t, this._needsUpdate || this._configureLightmaps() } }), Object.defineProperty(t.prototype, "materials", { get: function() { return this._materials }, set: function(t) { this._materials = t, this._needsUpdate = !0 } }), Object.defineProperty(t.prototype, "material", { get: function() { return this._materials ? this._materials[0] : null }, set: function(t) { this._materials = this._materials || [], this._materials[0] = t, this._needsUpdate = !0 } }), Object.defineProperty(t.prototype, "mesh", { get: function() { return this._mesh }, set: function(t) { this._mesh = t, this._needsUpdate = !0 } }), Object.defineProperty(t.prototype, "skin", { get: function() { return this._skin }, set: function(t) { this._skin = t, this._needsUpdate || this._updateSkin() } }), Object.defineProperty(t.prototype, "bones", { get: function() { return this._bones }, set: function(t) { this._bones = t, this._needsUpdate || this._updateSkin() } }), Object.defineProperty(t.prototype, "sortingLayerIndex", { get: function() { return this._sortingLayerIndex }, set: function(t) { this._sortingLayerIndex = t, this._needsUpdate || this._updateSortingIndexes() } }), Object.defineProperty(t.prototype, "sortingOrder", { get: function() { return this._sortingOrder }, set: function(t) { this._sortingOrder = t, this._needsUpdate || this._updateSortingIndexes() } }), Object.defineProperty(t.prototype, "drawOrder", { get: function() { return this._drawOrder }, set: function(t) { this._drawOrder = t, this._needsUpdate || this._updateDrawOrder() } }), Object.defineProperty(t.prototype, "cullingLayer", { get: function() { return this._cullingLayer }, set: function(t) { this._cullingLayer = t, this._needsUpdate || this._updateCulling() } }), Object.defineProperty(t.prototype, "lightProbe", { get: function() { return this._lightProbe }, set: function(t) { this._lightProbe = t, this._needsUpdate || this._updateLightProbe() } }), Object.defineProperty(t.prototype, "lightProbeUsage", { get: function() { return this._lightProbeUsage }, set: function(t) { t !== this._lightProbeUsage && (this._lightProbeUsage = t, this._needsUpdate || this._updateLightProbe()) } }), Object.defineProperty(t.prototype, "blendReflectionProbes", { get: function() { return this._blendReflectionProbes }, set: function(t) { this._blendReflectionProbes !== t && (this._blendReflectionProbes = t, this._needsUpdate || this._updateReflectionProbesBlending()) } }), Object.defineProperty(t.prototype, "reflectionProbes", { get: function() { return this._reflectionProbes }, set: function(t) { null === this._reflectionProbes && null === t || (this._reflectionProbes = t, this._needsUpdate || this._updateReflectionProbes()) } }), Object.defineProperty(t.prototype, "flipFaces", { get: function() { return this._flipFaces }, set: function(t) { this._flipFaces !== t && (this._flipFaces = t, this._needsUpdate || this._updateFlipFaces()) } }), Object.defineProperty(t.prototype, "isStatic", { get: function() { return this._isStatic }, set: function(t) { if (this._isStatic === t) return; let e, i; if (this._isStatic = t, this.model) { const n = this.model.meshInstances; for (e = 0; e < n.length; e++) i = n[e], i.isStatic = t } } }), Object.defineProperty(t.prototype, "masksChildren", { get: function() { return this._masksChildren }, set: function(t) { this._masksChildren = t, this._needsUpdate || this._updateMasksChildren() } }), { Model: t }
    }()), pc.createMesh = function(t, e, i) {
        const n = i && void 0 !== i.normals ? i.normals : null,
            s = i && void 0 !== i.tangents ? i.tangents : null,
            r = i && void 0 !== i.colors ? i.colors : null,
            o = i && void 0 !== i.uvs ? i.uvs : null,
            a = i && void 0 !== i.uvs1 ? i.uvs1 : null,
            c = i && void 0 !== i.indices ? i.indices : null,
            h = i && void 0 !== i.blendIndices ? i.blendIndices : null,
            l = i && void 0 !== i.blendWeights ? i.blendWeights : null,
            u = [{ semantic: pc.SEMANTIC_POSITION, components: 3, type: pc.TYPE_FLOAT32 }];
        null !== n && u.push({ semantic: pc.SEMANTIC_NORMAL, components: 3, type: pc.TYPE_FLOAT32 }), null !== s && u.push({ semantic: pc.SEMANTIC_TANGENT, components: 4, type: pc.TYPE_FLOAT32 }), null !== r && u.push({ semantic: pc.SEMANTIC_COLOR, components: 4, type: pc.TYPE_UINT8, normalize: !0 }), null !== o && u.push({ semantic: pc.SEMANTIC_TEXCOORD0, components: 2, type: pc.TYPE_FLOAT32 }), null !== a && u.push({ semantic: pc.SEMANTIC_TEXCOORD1, components: 2, type: pc.TYPE_FLOAT32 }), null !== h && u.push({ semantic: pc.SEMANTIC_BLENDINDICES, components: 2, type: pc.TYPE_UINT8 }), null !== l && u.push({ semantic: pc.SEMANTIC_BLENDWEIGHT, components: 2, type: pc.TYPE_FLOAT32 });
        const d = new pc.VertexFormat(t, u),
            p = e.length / 3,
            _ = new pc.VertexBuffer(t, d, p),
            f = new pc.VertexIterator(_);
        for (let t = 0; t < p; t++) f.element[pc.SEMANTIC_POSITION].set(e[3 * t], e[3 * t + 1], e[3 * t + 2]), null !== n && f.element[pc.SEMANTIC_NORMAL].set(n[3 * t], n[3 * t + 1], n[3 * t + 2]), null !== s && f.element[pc.SEMANTIC_TANGENT].set(s[4 * t], s[4 * t + 1], s[4 * t + 2], s[4 * t + 3]), null !== r && f.element[pc.SEMANTIC_COLOR].set(r[4 * t], r[4 * t + 1], r[4 * t + 2], r[4 * t + 3]), null !== o && f.element[pc.SEMANTIC_TEXCOORD0].set(o[2 * t], o[2 * t + 1]), null !== a && f.element[pc.SEMANTIC_TEXCOORD1].set(a[2 * t], a[2 * t + 1]), null !== h && f.element[pc.SEMANTIC_BLENDINDICES].set(h[2 * t], h[2 * t + 1]), null !== l && f.element[pc.SEMANTIC_BLENDWEIGHT].set(l[2 * t], l[2 * t + 1]), f.next();
        f.end();
        let m = null;
        const y = null !== c;
        if (y) {
            m = new pc.IndexBuffer(t, pc.INDEXFORMAT_UINT16, c.length);
            new Uint16Array(m.lock()).set(c), m.unlock()
        }
        const g = new pc.BoundingBox;
        g.compute(e);
        const E = new pc.Mesh;
        return E.vertexBuffer = _, E.indexBuffer[0] = m, E.primitive[0].type = pc.PRIMITIVE_TRIANGLES, E.primitive[0].base = 0, E.primitive[0].count = y ? c.length : p, E.primitive[0].indexed = y, E.aabb = g, E
    }, Object.assign(pc, function() { const t = function(t) { this.func = void 0 === t.func ? pc.FUNC_ALWAYS : t.func, this.ref = t.ref || 0, this.readMask = void 0 === t.readMask ? 255 : t.readMask, this.writeMask = void 0 === t.writeMask ? 255 : t.writeMask, this.fail = t.fail || pc.STENCILOP_KEEP, this.zfail = t.zfail || pc.STENCILOP_KEEP, this.zpass = t.zpass || pc.STENCILOP_KEEP }; return t.prototype.clone = function() { return new pc.StencilParameters({ func: this.func, ref: this.ref, readMask: this.readMask, writeMask: this.writeMask, fail: this.fail, zfail: this.zfail, zpass: this.zpass }) }, { StencilParameters: t } }()), Object.assign(pc, function() {
        function t() { return !("undefined" == typeof AudioContext && "undefined" == typeof webkitAudioContext) }
        const e = function(e) {
            if (t() && ("undefined" != typeof AudioContext ? this.context = new AudioContext : "undefined" != typeof webkitAudioContext && (this.context = new webkitAudioContext), this.context)) {
                const t = this.context;
                if (this.resumeContext = function() { this.context.resume(), window.removeEventListener("mousedown", this.resumeContext), window.removeEventListener("touchend", this.resumeContext) }.bind(this), window.addEventListener("mousedown", this.resumeContext), window.addEventListener("touchend", this.resumeContext), pc.platform.ios) {
                    const i = function() {
                        const n = t.createBuffer(1, 1, 44100),
                            s = t.createBufferSource();
                        s.buffer = n, s.connect(t.destination), s.start(0), s.disconnect(), e.removeEventListener("touchstart", i)
                    };
                    e.addEventListener("touchstart", i)
                }
            }
            this._volume = 1, this.suspended = !1, this.events = new pc.Events(this)
        };
        return e.hasAudio = function() { return "undefined" != typeof Audio }, e.hasAudioContext = t, Object.assign(e.prototype, { suspend: function() { this.suspended = !0, this.events.fire("suspend") }, resume: function() { this.suspended = !1, this.events.fire("resume") } }), Object.defineProperty(e.prototype, "volume", { get: function() { return this._volume }, set: function(t) { t = pc.math.clamp(t, 0, 1), this._volume = t, this.events.fire("volumechange", t) } }), { SoundManager: e }
    }()), Object.assign(pc, function() { const t = function(t) { t instanceof Audio ? this.audio = t : this.buffer = t }; return Object.defineProperty(t.prototype, "duration", { get: function() { let t = 0; return this.buffer ? t = this.buffer.duration : this.audio && (t = this.audio.duration), t || 0 } }), { Sound: t } }()), Object.assign(pc, function() {
        let t;
        const e = function(t, e) { return t % e || 0 };
        return pc.SoundManager.hasAudioContext() ? (t = function(t, e) { this.events = new pc.Events(this), this._volume = 1, this._pitch = 1, this._loop = !1, this._sound = e, this._state = 2, this._suspended = !1, this._suspendEndEvent = !1, this._suspendInstanceEvents = !1, this._startTime = 0, this._duration = 0, this._startedAt = 0, this._startOffset = null, this._currentTime = 0, this._currentOffset = 0, this._playWhenLoaded = !0, this._manager = t, this._inputNode = null, this._connectorNode = null, this._firstNode = null, this._lastNode = null, this._initializeNodes(), this._endedHandler = this._onEnded.bind(this), this.source = null }, Object.assign(t.prototype, {
            _initializeNodes: function() { this.gain = this._manager.context.createGain(), this._inputNode = this.gain, this._connectorNode = this.gain, this._connectorNode.connect(this._manager.context.destination) },
            play: function() { "running" !== this._manager.context.state && this._manager.context.resume(), 2 !== this._state && this.stop(), this.source || this._createSource(); let t = e(this._startOffset, this.duration); return t = e(this._startTime + t, this._sound.duration), this._startOffset = null, this._duration ? this.source.start(0, t, this._duration) : this.source.start(0, t), this._startedAt = this._manager.context.currentTime, this._currentTime = 0, this._currentOffset = t, this._state = 0, this._playWhenLoaded = !1, this.volume = this._volume, this.loop = this._loop, this.pitch = this._pitch, this._manager.events.on("volumechange", this._onManagerVolumeChange, this), this._manager.events.on("suspend", this._onManagerSuspend, this), this._manager.events.on("resume", this._onManagerResume, this), this._manager.suspended && this._onManagerSuspend(), !0 },
            pause: function() { return !(0 !== this._state || !this.source) && (this._updateCurrentTime(), this._state = 1, this._suspendEndEvent = !0, this.source.stop(0), this.source = null, this._playWhenLoaded = !1, this._startOffset = null, !0) },
            resume: function() {
                if (1 !== this._state) return !1;
                this.source || this._createSource();
                let t = this.currentTime;
                return null !== this._startOffset && (t = e(this._startOffset, this.duration), t = e(this._startTime + t, this._sound.duration), this._startOffset = null), this._duration ? this.source.start(0, t, this._duration) : this.source.start(0, t), this._state = 0, this._startedAt = this._manager.context.currentTime, this._currentOffset = t, this.volume = this._volume, this.loop = this._loop, this.pitch = this._pitch, this._playWhenLoaded = !1, !0
            },
            stop: function() { return !(2 === this._state || !this.source) && (this._manager.events.off("volumechange", this._onManagerVolumeChange), this._manager.events.off("suspend", this._onManagerSuspend), this._manager.events.off("resume", this._onManagerResume), this._startedAt = 0, this._currentTime = 0, this._currentOffset = 0, this._startOffset = null, this._playWhenLoaded = !1, this._suspendEndEvent = !0, 0 === this._state && this.source.stop(0), this.source.removeEventListener("ended", this._endedHandler), this.source = null, this._state = 2, !0) },
            setExternalNodes: function(t, e) {
                if (!t) return void console.error("The firstNode must be a valid Audio Node");
                e || (e = t);
                const i = this._manager.context.destination;
                this._firstNode !== t && (this._firstNode ? this._connectorNode.disconnect(this._firstNode) : this._connectorNode.disconnect(i), this._firstNode = t, this._connectorNode.connect(t)), this._lastNode !== e && (this._lastNode && this._lastNode.disconnect(i), this._lastNode = e, this._lastNode.connect(i))
            },
            clearExternalNodes: function() {
                const t = this._manager.context.destination;
                this._firstNode && (this._connectorNode.disconnect(this._firstNode), this._firstNode = null), this._lastNode && (this._lastNode.disconnect(t), this._lastNode = null), this._connectorNode.connect(t)
            },
            getExternalNodes: function() { return [this._firstNode, this._lastNode] },
            _createSource: function() { if (!this._sound) return null; const t = this._manager.context; return this._sound.buffer && (this.source = t.createBufferSource(), this.source.buffer = this._sound.buffer, this.source.connect(this._inputNode), this.source.onended = this._endedHandler, this.source.addEventListener("ended", this._endedHandler), this.source.loopStart = e(this._startTime, this.source.buffer.duration), this._duration && (this.source.loopEnd = Math.max(this.source.loopStart, e(this._startTime + this._duration, this.source.buffer.duration)))), this.source },
            _updateCurrentTime: function() { this._currentTime = e((this._manager.context.currentTime - this._startedAt) * this._pitch + this._currentOffset, this.duration) }
        }), Object.defineProperty(t.prototype, "volume", { get: function() { return this._volume }, set: function(t) { t = pc.math.clamp(t, 0, 1), this._volume = t, this.gain && (this.gain.gain.value = t * this._manager.volume) } }), Object.defineProperty(t.prototype, "pitch", { get: function() { return this._pitch }, set: function(t) { this._currentOffset = this.currentTime, this._startedAt = this._manager.context.currentTime, this._pitch = Math.max(Number(t) || 0, .01), this.source && (this.source.playbackRate.value = this._pitch) } }), Object.defineProperty(t.prototype, "loop", { get: function() { return this._loop }, set: function(t) { this._loop = !!t, this.source && (this.source.loop = this._loop) } }), Object.defineProperty(t.prototype, "sound", { get: function() { return this._sound }, set: function(t) { this._sound = t, 2 !== this._state ? this.stop() : this._createSource() } }), Object.defineProperty(t.prototype, "currentTime", {
            get: function() { return null !== this._startOffset ? this._startOffset : 1 === this._state ? this._currentTime : 2 !== this._state && this.source ? (this._updateCurrentTime(), this._currentTime) : 0 },
            set: function(t) {
                if (!(t < 0))
                    if (0 === this._state) {
                        this.stop();
                        const e = this._suspendInstanceEvents;
                        this._suspendInstanceEvents = !0, this._startOffset = t, this.play(), this._suspendInstanceEvents = e
                    } else this._startOffset = t, this._currentTime = t
            }
        })) : pc.SoundManager.hasAudio() ? (t = function(t, e, i) { this.events = new pc.Events(this), i = i || {}, this._volume = void 0 !== i.volume ? pc.math.clamp(Number(i.volume) || 0, 0, 1) : 1, this._pitch = void 0 !== i.pitch ? Math.max(.01, Number(i.pitch) || 0) : 1, this._loop = !(void 0 === i.loop || !i.loop), this._sound = e, this._state = 2, this._suspended = !1, this._suspendEndEvent = !1, this._suspendInstanceEvents = !1, this._playWhenLoaded = !0, this._startTime = Math.max(0, Number(i.startTime) || 0), this._duration = Math.max(0, Number(i.duration) || 0), this._startOffset = null, this._isReady = !1, this._manager = t, this._loadedMetadataHandler = this._onLoadedMetadata.bind(this), this._timeUpdateHandler = this._onTimeUpdate.bind(this), this._endedHandler = this._onEnded.bind(this), this._onPlayCallback = i.onPlay, this._onPauseCallback = i.onPause, this._onResumeCallback = i.onResume, this._onStopCallback = i.onStop, this._onEndCallback = i.onEnd, this.source = null, this._createSource() }, Object.assign(t.prototype, {
            play: function() { return 2 !== this._state && this.stop(), !(!this.source && !this._createSource()) && (this.volume = this._volume, this.pitch = this._pitch, this.loop = this._loop, this.source.play(), this._state = 0, this._playWhenLoaded = !1, this._manager.events.on("volumechange", this._onManagerVolumeChange, this), this._manager.events.on("suspend", this._onManagerSuspend, this), this._manager.events.on("resume", this._onManagerResume, this), this._manager.suspended && this._onManagerSuspend(), this._suspendInstanceEvents || this._onPlay(), !0) },
            pause: function() { return !(!this.source || 0 !== this._state) && (this._suspendEndEvent = !0, this.source.pause(), this._playWhenLoaded = !1, this._state = 1, this._startOffset = null, this._suspendInstanceEvents || this._onPause(), !0) },
            resume: function() { return !(!this.source || 1 !== this._state) && (this._state = 0, this._playWhenLoaded = !1, this.source.paused && (this.source.play(), this._suspendInstanceEvents || this._onResume()), !0) },
            stop: function() { return !(!this.source || 2 === this._state) && (this._manager.events.off("volumechange", this._onManagerVolumeChange), this._manager.events.off("suspend", this._onManagerSuspend), this._manager.events.off("resume", this._onManagerResume), this._suspendEndEvent = !0, this.source.pause(), this._playWhenLoaded = !1, this._state = 2, this._startOffset = null, this._suspendInstanceEvents || this._onStop(), !0) },
            setExternalNodes: function() {},
            clearExternalNodes: function() {},
            getExternalNodes: function() { return [null, null] },
            _onLoadedMetadata: function() {
                this.source.removeEventListener("loadedmetadata", this._loadedMetadataHandler), this._isReady = !0;
                let t = e(this._startOffset, this.duration);
                t = e(this._startTime + t, this._sound.duration), this._startOffset = null, this.source.currentTime = t
            },
            _createSource: function() { return this._sound && this._sound.audio && (this._isReady = !1, this.source = this._sound.audio.cloneNode(!0), this.source.addEventListener("loadedmetadata", this._loadedMetadataHandler), this.source.addEventListener("timeupdate", this._timeUpdateHandler), this.source.onended = this._endedHandler), this.source },
            _onTimeUpdate: function() { this._duration && this.source.currentTime > e(this._startTime + this._duration, this.source.duration) && (this.loop ? this.source.currentTime = e(this._startTime, this.source.duration) : (this.source.removeEventListener("timeupdate", this._timeUpdateHandler), this.source.pause(), this._onEnded())) }
        }), Object.defineProperty(t.prototype, "volume", { get: function() { return this._volume }, set: function(t) { t = pc.math.clamp(t, 0, 1), this._volume = t, this.source && (this.source.volume = t * this._manager.volume) } }), Object.defineProperty(t.prototype, "pitch", { get: function() { return this._pitch }, set: function(t) { this._pitch = Math.max(Number(t) || 0, .01), this.source && (this.source.playbackRate = this._pitch) } }), Object.defineProperty(t.prototype, "loop", { get: function() { return this._loop }, set: function(t) { this._loop = !!t, this.source && (this.source.loop = this._loop) } }), Object.defineProperty(t.prototype, "sound", { get: function() { return this._sound }, set: function(t) { this.stop(), this._sound = t } }), Object.defineProperty(t.prototype, "currentTime", { get: function() { return null !== this._startOffset ? this._startOffset : 2 !== this._state && this.source ? this.source.currentTime - this._startTime : 0 }, set: function(t) { t < 0 || (this._startOffset = t, this.source && this._isReady && (this.source.currentTime = e(this._startTime + e(t, this.duration), this._sound.duration), this._startOffset = null)) } })) : t = function() {}, Object.assign(t.prototype, { _onPlay: function() { this._onPlayCallback && this._onPlayCallback(this) }, _onPause: function() { this._onPauseCallback && this._onPauseCallback(this) }, _onResume: function() { this.events.fire("resume"), this._onResumeCallback && this._onResumeCallback(this) }, _onStop: function() { this.events.fire("stop"), this._onStopCallback && this._onStopCallback(this) }, _onEnded: function() { pc.SoundInstance.doNotSuspendEndEvent || !this._suspendEndEvent ? (this.events.fire("end"), this._onEndCallback && this._onEndCallback(this), this.stop()) : this._suspendEndEvent = !1 }, _onManagerVolumeChange: function() { this.volume = this._volume }, _onManagerSuspend: function() { 0 !== this._state || this._suspended || (this._suspended = !0, this.pause()) }, _onManagerResume: function() { this._suspended && (this._suspended = !1, this.resume()) } }), Object.defineProperty(t.prototype, "startTime", {
            get: function() { return this._startTime },
            set: function(t) {
                this._startTime = Math.max(0, Number(t) || 0);
                const e = 0 === this._state;
                this.stop(), e && this.play()
            }
        }), Object.defineProperty(t.prototype, "duration", {
            get: function() { return this._sound ? this._duration ? e(this._duration, this._sound.duration) : this._sound.duration : 0 },
            set: function(t) {
                this._duration = Math.max(0, Number(t) || 0);
                const e = 0 === this._state;
                this.stop(), e && this.play()
            }
        }), Object.defineProperty(t.prototype, "isPlaying", { get: function() { return 0 === this._state } }), Object.defineProperty(t.prototype, "isPaused", { get: function() { return 1 === this._state } }), Object.defineProperty(t.prototype, "isStopped", { get: function() { return 2 === this._state } }), Object.defineProperty(t.prototype, "isSuspended", { get: function() { return this._suspended } }), { SoundInstance: t }
    }()), Object.assign(pc, function() {
        const t = new pc.Vec4(0, 0, 1, 1),
            e = new pc.Vec2;
        class i { constructor() { this.clearColor = new pc.Color(.722, .722, .722, 1), this.clearColorBuffer = !0, this.clearDepthBuffer = !0, this.clearStencilBuffer = !0, this.clearSkybox = !0, this.nearClip = .1, this.farClip = 1e3, this.fov = 45, this.orthoHeight = 100, this.projection = pc.PROJECTION_PERSPECTIVE, this.priority = 0, this.rect = new pc.Vec4(0, 0, 1, 1), this.enabled = !0, this.flipFaces = !1, this.camera = null, this.aspectRatio = 16 / 9, this.aspectRatioMode = pc.ASPECT_AUTO, this.renderTarget = null, this.isRendering = !1, this.calculateTransform = null, this.calculateProjection = null } }
        class n extends pc.Component {
            constructor(t, e) { super(t, e), this.data = new i, this.events.on("set_aspectRatioMode", this.onSetAspectRatioMode, this), this.events.on("set_aspectRatio", this.onSetAspectRatio, this), this.events.on("set_camera", this.onSetCamera, this), this.events.on("set_clearColor", this.onSetClearColor, this), this.events.on("set_fov", this.onSetFov, this), this.events.on("set_orthoHeight", this.onSetOrthoHeight, this), this.events.on("set_nearClip", this.onSetNearClip, this), this.events.on("set_farClip", this.onSetFarClip, this), this.events.on("set_projection", this.onSetProjection, this), this.events.on("set_clearColorBuffer", this.updateClearFlags, this), this.events.on("set_clearDepthBuffer", this.updateClearFlags, this), this.events.on("set_clearStencilBuffer", this.updateClearFlags, this), this.events.on("set_clearSkybox", this.updateClearFlags, this), this.events.on("set_renderTarget", this.onSetRenderTarget, this), this.events.on("set_rect", this.onSetRect, this), this.events.on("set_scissorRect", this.onSetScissorRect, this), this.events.on("set_horizontalFov", this.onSetHorizontalFov, this), this.events.on("set_calculateTransform", this.onSetCalculateTransform, this), this.events.on("set_calculateProjection", this.onSetCalculateProjection, this), this.events.on("set_cullingMask", this.onSetCullingMask, this), this.device = pc.Application.getApplication().graphicsDevice, this.layerCullDistancesActivated = !1, this.layerCullDistances = new Array(32).fill(0) }
            screenToWorld(t, e, i, n) { const s = this.system.app.graphicsDevice; return this.data.camera.screenToWorld(t, e, i, s.clientRect.width, s.clientRect.height, n) }
            worldToScreen(t, e) { const i = this.system.app.graphicsDevice; return this.data.camera.worldToScreen(t, i.clientRect.width, i.clientRect.height, e) }
            onSetAspectRatioMode(t, e, i) { this.data.camera.aspectRatioMode = i }
            onSetAspectRatio(t, e, i) { this.data.camera.aspectRatio = i }
            onSetCamera(t, e, i) { e && (e._node = null), i._node = this.entity }
            onSetClearColor(t, e, i) {
                const n = this.data.camera.clearColor;
                n[0] = i.r, n[1] = i.g, n[2] = i.b, n[3] = i.a
            }
            onSetFov(t, e, i) { this.data.camera.fov = i }
            onSetCullingMask(t, e, i) { this.data.camera.cullingMask = i }
            onSetOrthoHeight(t, e, i) { this.data.camera.orthoHeight = i }
            onSetNearClip(t, e, i) { this.data.camera.nearClip = i }
            onSetFarClip(t, e, i) { this.data.camera.farClip = i }
            onSetHorizontalFov(t, e, i) { this.data.camera.horizontalFov = i }
            onSetCalculateTransform(t, e, i) { this._calculateTransform = i, this.camera.overrideCalculateTransform = !!i }
            onSetCalculateProjection(t, e, i) { this._calculateProjection = i, this.camera._projMatDirty = !0, this.camera.overrideCalculateProjection = !!i }
            onSetProjection(t, e, i) { this.data.camera.projection = i }
            addCameraToScene() { this.system.app.scene.addCamera(this) }
            removeCameraFromScene() { this.system.app.scene.removeCamera(this) }
            updateClearFlags() {
                let t = 0;
                this.clearColorBuffer && (t |= pc.CLEARFLAG_COLOR), this.clearDepthBuffer && (t |= pc.CLEARFLAG_DEPTH), this.clearStencilBuffer && (t |= pc.CLEARFLAG_STENCIL), this.clearSkybox && (t |= pc.CLEARFLAG_USE_SKYBOX), this.data.camera.clearFlags = t
            }
            onSetRenderTarget(t, e, i) { this.data.camera.renderTarget = i }
            onSetRect(t, e, i) { this.data.camera.setRect(i.x, i.y, i.z, i.w) }
            onSetScissorRect(t, e, i) { this.data.camera.setScissorRect(i.x, i.y, i.z, i.w) }
            onEnable() { this.system.addCamera(this), this.enabled && this.entity.enabled && this.addCameraToScene() }
            onDisable() { this.removeCameraFromScene(), this.system.removeCamera(this) }
            calculateAspectRatio(t) {
                const e = t || this.system.app.graphicsDevice,
                    i = this.rect;
                return e.width * i.z / (e.height * i.w)
            }
            frameBegin(t) { this.aspectRatioMode === pc.ASPECT_AUTO && (this.aspectRatio = this.calculateAspectRatio(t)), this.data.isRendering = !0 }
            frameEnd() { this.data.isRendering = !1 }
            resetProjectionMatrix() { this.camera.resetProjectionMatrix() }
            changeAspectRatio(t) { this.aspectRatioMode = pc.ASPECT_MANUAL, this.aspectRatio = t }
            resetAspect() { this.aspectRatioMode = pc.ASPECT_AUTO }
            get clearColor() { return this.data.clearColor }
            set clearColor(t) {
                const e = this.data.clearColor;
                this.data.clearColor = t, this.events.fire("set_clearColor", "clearColor", e, t)
            }
            get clearDepthBuffer() { return this.data.clearDepthBuffer }
            set clearDepthBuffer(t) {
                const e = this.data.clearDepthBuffer;
                this.data.clearDepthBuffer = t, this.events.fire("set_clearDepthBuffer", "clearDepthBuffer", e, t)
            }
            get clearSkybox() { return this.data.clearSkybox }
            set clearSkybox(t) {
                const e = this.data.clearSkybox;
                this.data.clearSkybox = t, this.events.fire("set_clearSkybox", "clearSkybox", e, t)
            }
            get clearStencilBuffer() { return this.data.clearStencilBuffer }
            set clearStencilBuffer(t) {
                const e = this.data.clearStencilBuffer;
                this.data.clearStencilBuffer = t, this.events.fire("set_clearStencilBuffer", "clearStencilBuffer", e, t)
            }
            get projection() { return this.data.projection }
            set projection(t) {
                const e = this.data.projection;
                this.data.projection = t, this.events.fire("set_projection", "projection", e, t)
            }
            get fov() { return this.data.fov }
            set fov(t) {
                const e = this.data.fov;
                this.data.fov = t, this.events.fire("set_fov", "fov", e, t)
            }
            get orthoHeight() { return this.data.orthoHeight }
            set orthoHeight(t) {
                const e = this.data.orthoHeight;
                this.data.orthoHeight = t, this.events.fire("set_orthoHeight", "orthoHeight", e, t)
            }
            get nearClip() { return this.data.nearClip }
            set nearClip(t) {
                const e = this.data.nearClip;
                this.data.nearClip = t, this.events.fire("set_nearClip", "nearClip", e, t)
            }
            get farClip() { return this.data.farClip }
            set farClip(t) {
                const e = this.data.farClip;
                this.data.farClip = t, this.events.fire("set_farClip", "farClip", e, t)
            }
            get priority() { return this.data.priority }
            set priority(t) {
                const e = this.data.priority;
                this.data.priority = t, this.events.fire("set_priority", "priority", e, t)
            }
            get rect() { return this.data.rect }
            set rect(t) {
                const e = this.data.rect;
                this.data.rect = t, this.events.fire("set_rect", "rect", e, t)
            }
            get camera() { return this.data.camera }
            set camera(t) {
                const e = this.data.camera;
                this.data.camera = t, this.events.fire("set_camera", "camera", e, t)
            }
            get aspectRatio() { return this.data.aspectRatio }
            set aspectRatio(t) {
                const e = this.data.aspectRatio;
                this.data.aspectRatio = t, this.events.fire("set_aspectRatio", "aspectRatio", e, t)
            }
            get aspectRatioMode() { return this.data.aspectRatioMode }
            set aspectRatioMode(t) {
                const e = this.data.aspectRatioMode;
                this.data.aspectRatioMode = t, this.events.fire("set_aspectRatioMode", "aspectRatioMode", e, t)
            }
            get horizontalFov() { return this.data.horizontalFov }
            set horizontalFov(t) {
                const e = this.data.horizontalFov;
                this.data.horizontalFov = t, this.events.fire("set_horizontalFov", "horizontalFov", e, t)
            }
            get model() { return this.data.model }
            set model(t) {
                const e = this.data.model;
                this.data.model = t, this.events.fire("set_model", "model", e, t)
            }
            get renderTarget() { return this.data.renderTarget }
            set renderTarget(t) {
                const e = this.data.renderTarget;
                this.data.renderTarget = t, this.events.fire("set_renderTarget", "renderTarget", e, t)
            }
            get calculateTransform() { return this.data.calculateTransform }
            set calculateTransform(t) {
                const e = this.data.calculateTransform;
                this.data.calculateTransform = t, this.events.fire("set_calculateTransform", "calculateTransform", e, t)
            }
            get calculateProjection() { return this.data.calculateProjection }
            set calculateProjection(t) {
                const e = this.data.calculateProjection;
                this.data.calculateProjection = t, this.events.fire("set_calculateProjection", "calculateProjection", e, t)
            }
            get flipFaces() { return this.data.flipFaces }
            set flipFaces(t) {
                const e = this.data.flipFaces;
                this.data.flipFaces = t, this.events.fire("set_flipFaces", "flipFaces", e, t)
            }
            get layers() { return this.data.layers }
            set layers(t) {
                const e = this.data.layers;
                this.data.layers = t, this.events.fire("set_layers", "layers", e, t)
            }
            get cullingMask() { return this.data.cullingMask }
            set cullingMask(t) {
                const e = this.data.cullingMask;
                this.data.cullingMask = t, this.events.fire("set_cullingMask", "cullingMask", e, t)
            }
            get clearColorBuffer() { return this.data.clearColorBuffer }
            set clearColorBuffer(t) {
                const e = this.data.clearColorBuffer;
                this.data.clearColorBuffer = t, this.events.fire("set_clearColorBuffer", "clearColorBuffer", e, t)
            }
            get enabled() { return this.data.enabled }
            set enabled(t) {
                const e = this.data.enabled;
                this.data.enabled = t, this.events.fire("set_enabled", "enabled", e, t)
            }
            get projectionMatrix() { return this.data.camera.getProjectionMatrix() }
            set projectionMatrix(t) { this.data.camera.setProjectionMatrix(t) }
            get viewMatrix() { return this.data.camera._node.getWorldTransform().clone().invert() }
            get frustum() { return this.data.camera.frustum }
            get node() { return this.data.camera._node }
            get unityRect() { return this.rect }
            set unityRect(t) { this.rect = t }
            get unityPixelRect() { const i = this.renderTarget; return i ? (e.x = i.width, e.y = i.height) : (e.x = this.device.width, e.y = this.device.height), t.copy(this.rect), t.x *= e.x, t.y *= e.y, t.z *= e.x, t.w *= e.y, t }
            set unityPixelRect(t) {
                const i = this.renderTarget;
                i ? (e.x = i.width, e.y = i.height) : (e.x = this.device.width, e.y = this.device.height), this.rect = new pc.Vec4(t.x / e.x, t.y / e.y, t.z / e.x, t.w / e.y)
            }
        }
        return { CameraComponent: n }
    }()), Object.assign(pc, function() {
        class t extends pc.ComponentSystem {
            constructor(t) { super(t), this.id = "camera", this.description = "Renders the scene from the location of the Entity.", this.ComponentType = pc.CameraComponent, this.cameras = [], this.events.on("beforeremove", this.onBeforeRemove, this), this.events.on("remove", this.onRemove, this), pc.ComponentSystem.events.on("update", this.onUpdate, this) }
            initializeComponentData(t, e, i) {
                const n = {};
                for (let t = 0, s = (i = ["postEffects", "enabled", "model", "camera", "aspectRatio", "aspectRatioMode", "horizontalFov", "renderTarget", "clearColor", "fov", "orthoHeight", "nearClip", "farClip", "projection", "priority", "clearColorBuffer", "clearDepthBuffer", "clearStencilBuffer", "clearSkybox", "rect", "calculateTransform", "calculateProjection", "flipFaces", "layers", "cullingMask"]).length; t < s; t++) {
                    const s = i[t];
                    n[s] = e[s]
                }
                if (n.clearColor && Array.isArray(n.clearColor)) {
                    const t = n.clearColor;
                    n.clearColor = new pc.Color(t[0], t[1], t[2], t[3])
                }
                if (n.rect && Array.isArray(n.rect)) {
                    const t = n.rect;
                    n.rect = new pc.Vec4(t[0], t[1], t[2], t[3])
                }
                n.activate && (console.warn("WARNING: activate: Property is deprecated. Set enabled property instead."), n.enabled = n.activate), n.camera = new pc.Camera, n._node = t.entity, n.camera._component = t;
                const s = t;
                n.camera.calculateTransform = function(t, e) { return s._calculateTransform ? s._calculateTransform(t, e) : null }, n.camera.calculateProjection = function(t, e) { return s._calculateProjection ? s._calculateProjection(t, e) : null }, pc.ComponentSystem.prototype.initializeComponentData.call(this, t, n, i)
            }
            onBeforeRemove(t, e) { this.removeCamera(e) }
            onRemove(t, e) { e.camera = null }
            onUpdate(t) {}
            addCamera(t) { this.cameras.push(t), this.sortCamerasByPriority() }
            removeCamera(t) {
                const e = this.cameras.indexOf(t);
                e >= 0 && (this.cameras.splice(e, 1), this.sortCamerasByPriority())
            }
            sortCamerasByPriority() { this.cameras.sort(((t, e) => t.priority - e.priority)) }
        }
        return { CameraComponentSystem: t }
    }()), Object.assign(pc, function() {
        class t { constructor() { this.enabled = !0, this.light = null, this.type = "directional", this.color = new pc.Color(1, 1, 1), this.intensity = 1, this.castShadows = !1, this.range = 10, this.outerConeAngle = 45, this.shadowType = pc.SHADOW_PCF3, this.cookie = null, this.cookieScale = null, this.mask = 1, this.cullingMask = 1, this.affectDynamic = !0, this.affectLightmapped = !1, this.isStatic = !1, this.renderMode = 0 } }
        class e extends pc.Component {
            constructor(e, i) { super(e, i), this.data = new t }
            addLightToScene() { this.system.app.scene.addLight(this.light) }
            removeLightFromScene() { this.system.app.scene.removeLight(this.light) }
            refreshProperties() {
                let t;
                for (let e = 0; e < i.length; e++) t = i[e], this[t] = this[t];
                this.enabled && this.entity.enabled && this.onEnable()
            }
            onEnable() { this.light.enabled = !0, this.enabled && this.entity.enabled && this.addLightToScene() }
            onDisable() { this.light.enabled = !1, this.removeLightFromScene() }
        }
        const i = [],
            n = [],
            s = function(t, s, r, o) {
                const a = e.prototype;
                i.push(t), n.push(s), Object.defineProperty(a, t, {
                    get: function() { return this.data[t] },
                    set: function(e) {
                        const i = this.data,
                            n = i[t];
                        (o || n !== e) && (i[t] = e, r && r.call(this, e, n))
                    },
                    configurable: !0
                })
            };
        return s("enabled", !0, (function(t, e) { this.onSetEnabled(null, e, t) })), s("light", null), s("type", "directional", (function(t, e) { this.system.changeType(this, e, t), this.refreshProperties() })), s("color", new pc.Color(1, 1, 1), (function(t, e) { this.light.setColor(t) }), !0), s("intensity", 1, (function(t, e) { this.light.intensity = t })), s("castShadows", !1, (function(t, e) { this.light.castShadows = t })), s("range", 10, (function(t, e) { this.light.attenuationEnd = t })), s("outerConeAngle", 45, (function(t, e) { this.light.outerConeAngle = t })), s("shadowType", pc.SHADOW_PCF3, (function(t, e) { this.light.shadowType = t })), s("cookie", null, (function(t, e) { t && (t.minFilter = pc.FILTER_LINEAR), this.light.cookie = t })), s("cookieScale", null, (function(t, e) { this.light.cookieScale = t }), !0), s("mask", 1, (function(t, e) { this.light.mask = t })), s("cullingMask", 1, (function(t, e) { this.light.cullingMask = t })), s("affectDynamic", !0, (function(t, e) { t ? this.light.mask |= pc.MASK_DYNAMIC : this.light.mask &= ~pc.MASK_DYNAMIC, this.light.mask = this.light._mask })), s("affectLightmapped", !1, (function(t, e) { t ? this.light.mask |= pc.MASK_BAKED : this.light.mask &= ~pc.MASK_BAKED, this.light.mask = this.light._mask })), s("isStatic", !1, (function(t, e) { this.light.isStatic = t })), s("renderMode", 0, (function(t, e) { this.light.renderMode = t })), { LightComponent: e, _lightProps: i, _lightPropsDefault: n }
    }()), Object.assign(pc, function() {
        const t = { directional: pc.LIGHTTYPE_DIRECTIONAL, point: pc.LIGHTTYPE_POINT, spot: pc.LIGHTTYPE_SPOT };
        class e extends pc.ComponentSystem {
            constructor(t) { super(t), this.id = "light", this.description = "Enables the Entity to emit light.", this.ComponentType = pc.LightComponent }
            initializeComponentData(e, i) {
                const n = pc._lightProps,
                    s = {};
                for (let t = 0, e = n.length; t < e; t++) {
                    const e = n[t];
                    s[e] = i[e]
                }
                s.type || (s.type = e.data.type), e.data.type = s.type, s.color && Array.isArray(s.color) && (s.color = new pc.Color(s.color[0], s.color[1], s.color[2]));
                const r = new pc.Light;
                r.type = t[s.type], r._node = e.entity, e.data.light = r, r.renderMode = i.renderMode, r.range = i.range, pc.ComponentSystem.prototype.initializeComponentData.call(this, e, s, n)
            }
            removeComponent(t) { t.light.data.light.destroy(), pc.ComponentSystem.prototype.removeComponent.call(this, t) }
            changeType(e, i, n) { i !== n && (e.light.type = t[n]) }
        }
        return { LightComponentSystem: e }
    }()), pc.extend(pc, function() {
        class t { constructor() { this.enabled = !0 } }
        class e extends pc.Component {
            constructor(e, i) { super(e, i), this.data = new t, this._resolution = new pc.Vec2(this.system.app.graphicsDevice.width, this.system.app.graphicsDevice.height), this._referenceResolution = new pc.Vec2(640, 320), this._offset = new pc.Vec2(0, 0), this._scaleMode = pc.ScreenComponent.SCALEMODE_NONE, this.scale = 1, this._scaleBlend = .5, this._scaleFactor = 1, this._planeHeight = 0, this._screenType = pc.SCREEN_TYPE_SCREEN, this._screenDistance = 1, this.parentScreen = null, this._isFallbackOverlay = !1, this.canvasMeshInstance = new pc.CanvasMeshInstance(this), this.registered = !1 }
            _updateScreenInChildren() {
                for (let t = 0; t < this.entity._children.length; t++) {
                    const e = this.entity._children[t].element;
                    e && e._updateScreen(e._findScreen(), !0)
                }
                this.syncDrawOrder()
            }
            syncDrawOrder() {
                const t = pc.Application.getApplication().systems.screen;
                t && (t._dirtyOrder = !0)
            }
            _calcProjectionMatrix() {
                const t = this._screenType,
                    e = this.camera;
                t === pc.SCREEN_TYPE_CAMERA && e && (e.projection === pc.PROJECTION_PERSPECTIVE ? this._planeHeight = Math.tan(e.fov / 2 * (Math.PI / 180)) * Math.abs(2 * this._screenDistance) : this._planeHeight = 2 * e.orthoHeight), this.entity.element.dirtifyScreen()
            }
            _findParentScreen() { return pc.UIUtils.findParentScreen(this.entity.parent) }
            onRemove() { this.reparentChildrenToNewCanvas() }
            reparentChildrenToNewCanvas() {
                const t = pc.UIUtils.findParentScreen(this.entity.parent),
                    e = this.canvasMeshInstance.renderers;
                for (let i = 0; i < e.length; i++) { e[i].reparentCanvas(t) }
            }
            _updateScale() { this.scale = this._calcScale(this._resolution, this.referenceResolution) }
            _calcScale(t, i) {
                if (this._scaleMode === e.SCALEMODE_NONE) return this.scaleFactor;
                if (this._scaleMode === e.SCALEMODE_EXPAND) return Math.min(t.x / i.x, t.y / i.y);
                if (this._scaleMode === e.SCALEMODE_SHRINK) return Math.max(t.x / i.x, t.y / i.y); {
                    const e = Math.log2(t.x / i.x),
                        n = Math.log2(t.y / i.y),
                        s = pc.math.lerp(e, n, this.scaleBlend);
                    return Math.pow(2, s)
                }
            }
            _onResize(t, e, i, n) {
                const s = this.camera;
                let r = i,
                    o = n;
                s && s.renderTarget && (r = s.renderTarget.width, o = s.renderTarget.height), this._screenType !== pc.SCREEN_TYPE_WORLD && (this._resolution.set(r, o), this.resolution = this._resolution), this.entity.element && this.entity.element.triggerOnElementDimesionsChange(!0, !0)
            }
            _updateStencilRecursive(t, e) {
                const i = t.element,
                    n = !!i,
                    s = n && (i._image && i._image.masksChildren || i._text && i._text.masksChildren);
                n && (i._masked = e.maskingDepth > 0, s && (i._topMostMask = 0 === e.maskingDepth, e.maskingDepth++, e.ref = (1 << e.maskingDepth) - 1), i.stencilLayer = e.ref);
                for (let i = 0; i < t._children.length; i++) this._updateStencilRecursive(t._children[i], e);
                n && s && (e.maskingDepth--, e.ref = (1 << e.maskingDepth) - 1)
            }
            _updateStencilParameters() {
                if (!this.entity) return;
                this._updateStencilRecursive(this.entity, { ref: 0, maskingDepth: 0 })
            }
            addScreenToScene() { this.screenType !== pc.SCREEN_TYPE_SCREEN && this.system.app.scene.addRenderer(this), this.system.app.graphicsDevice.events.on("resizecanvas", this._onResize, this), this.system.app.scene.addScreen(this) }
            removeScreenFromScene() { this.screenType !== pc.SCREEN_TYPE_SCREEN && this.system.app.scene.removeRenderer(this), this.system.app.graphicsDevice.events.off("resizecanvas", this._onResize), this.system.app.scene.removeScreen(this) }
            onEnable() {
                this.registered = !0;
                const t = pc.UIUtils.findParentScreen(this.entity.parent);
                this.setParentScreen(t, !0);
                const e = this.system.app.graphicsDevice;
                this._onResize(e.width, e.height, e._width, e._height)
            }
            onDisable() { this.setParentScreen(null, !1), this.registered = !1 }
            onDestroy() { this.reparentChildrenToNewCanvas() }
            getMeshInstancesForRender() { return this.meshInstances }
            setParentScreen(t, e) { e = !!e, this.registered && (this.parentScreen ? this.parentScreen.canvasMeshInstance.removeRenderer(this.canvasMeshInstance) : this.removeScreenFromScene()), this.parentScreen = t, this.registered && e && (this.parentScreen ? this.parentScreen.canvasMeshInstance.addRenderer(this.canvasMeshInstance) : this.addScreenToScene()) }
            get enabled() { return this.data.enabled }
            set enabled(t) {
                const e = this.data.enabled;
                this.data.enabled = t, this.events.fire("set_enabled", "enabled", e, t)
            }
            get resolution() { return this._resolution }
            set resolution(t) {
                const e = this.camera;
                e && e.renderTarget || (this._screenType !== pc.SCREEN_TYPE_SCREEN ? 0 !== t.x && 0 !== t.y && this._resolution.set(t.x, t.y) : e && e.renderTarget || this._resolution.set(this.system.app.graphicsDevice._width, this.system.app.graphicsDevice._height), this._scaleMode === pc.ScreenComponent.SCALEMODE_NONE && this.referenceResolution.copy(this._resolution), this._updateScale(), this._calcProjectionMatrix(), this.events.fire("set:resolution", this._resolution))
            }
            get offset() { return this._offset }
            set offset(t) { this._offset.set(t.x, t.y), this._calcProjectionMatrix() }
            get referenceResolution() { return this._scaleMode === pc.ScreenComponent.SCALEMODE_NONE ? this._resolution : this._referenceResolution }
            set referenceResolution(t) { this._referenceResolution.set(t.x, t.y), this._updateScale(), this._calcProjectionMatrix(), this.events.fire("set:referenceresolution", this._resolution) }
            get screenType() { return this.parentScreen ? this.parentScreen.screenType : this._screenType }
            set screenType(t) {
                if (this._screenType === t) return;
                this.registered && this.enabled && this.removeScreenFromScene(), this._screenType = t;
                const e = this.screenType;
                if (this._isFallbackOverlay = !1, e === pc.SCREEN_TYPE_CAMERA)
                    if (this._camera) {
                        const t = this._camera._node.getPosition();
                        this.entity.element.anchoredPosition.set(t.x, t.y)
                    } else this._isFallbackOverlay = !0, this._screenType = pc.SCREEN_TYPE_SCREEN;
                e === pc.SCREEN_TYPE_SCREEN && (this.canvasMeshInstance.visible = !0), this._resolution.set(this.system.app.graphicsDevice._width, this.system.app.graphicsDevice._height), this.resolution = this._resolution, this.events.fire("set:screentype", e), this.registered && this.enabled && this.addScreenToScene()
            }
            get screenDistance() { return this._screenDistance }
            set screenDistance(t) { this._screenDistance = t, this._calcProjectionMatrix() }
            get scaleMode() { return this._scaleMode }
            set scaleMode(t) { t !== pc.ScreenComponent.SCALEMODE_NONE && t !== pc.ScreenComponent.SCALEMODE_BLEND && t !== pc.ScreenComponent.SCALEMODE_EXPAND && t !== pc.ScreenComponent.SCALEMODE_SHRINK && (t = pc.ScreenComponent.SCALEMODE_NONE), this._screenType === pc.SCREEN_TYPE_WORLD && t !== pc.ScreenComponent.SCALEMODE_NONE && (t = pc.ScreenComponent.SCALEMODE_NONE), this._scaleMode = t, this.resolution = this._resolution, this.events.fire("set:scalemode", this._scaleMode) }
            get scaleBlend() { return this._scaleBlend }
            set scaleBlend(t) { this._scaleBlend = t, this._updateScale(), this._calcProjectionMatrix(), this.events.fire("set:scaleblend", this._scaleBlend) }
            get camera() { return this.rootScreen._camera }
            set camera(t) { this._camera = t, this._camera || this.screenType !== pc.SCREEN_TYPE_CAMERA || (this.screenType = pc.SCREEN_TYPE_SCREEN, this._isFallbackOverlay = !0), this._camera && this._isFallbackOverlay && (this.screenType = pc.SCREEN_TYPE_CAMERA), t && null != t.renderTarget && this._resolution.set(t.renderTarget.width, t.renderTarget.height), this._calcProjectionMatrix() }
            get meshInstances() { return [this.canvasMeshInstance] }
            get referencePixelsPerUnit() { return this._referencePixelsPerUnit }
            set referencePixelsPerUnit(t) { this._referencePixelsPerUnit = t, this.resolution = this._resolution }
            get rootScreen() {
                let t = this,
                    e = this.entity;
                for (; e;) t = e.screen || t, e = e.parent;
                return t
            }
            get scaleFactor() { return this._scaleFactor }
            set scaleFactor(t) { this._scaleFactor = t, this._updateScale(), this._calcProjectionMatrix() }
            get overrideSorting() { return this["__UnityEngine.Canvas"].overrideSorting }
            set overrideSorting(t) { this._sortingOrder = t }
            get sortingOrder() { return !this.isNested || this["__UnityEngine.Canvas"].overrideSorting ? this._sortingOrder : this.parentScreen.sortingOrder }
            set sortingOrder(t) { this._sortingOrder = t }
            get sortingLayerIndex() { return !this.isNested || this["__UnityEngine.Canvas"].overrideSorting ? this._sortingLayerIndex : this.parentScreen.sortingLayerIndex }
            set sortingLayerIndex(t) { this._sortingLayerIndex = t }
            get isNested() { return null != this.parentScreen }
            get drawOrder() { return this.entity.element.drawOrder }
            get isFallbackOverlay() { return this._isFallbackOverlay }
            set isFallbackOverlay(t) { this._isFallbackOverlay = t }
        }
        return e.SCALEMODE_NONE = "none", e.SCALEMODE_BLEND = "blend", e.SCALEMODE_EXPAND = "expand", e.SCALEMODE_SHRINK = "shrink", { ScreenComponent: e, SCREEN_TYPE_WORLD: "world", SCREEN_TYPE_CAMERA: "camera", SCREEN_TYPE_SCREEN: "screen" }
    }()), Object.assign(pc, function() {
        const t = function(e, i) {
            const n = e.element;
            if (n) {
                const t = e._unityComponents.canvasRenderer[0];
                t && (t._absoluteDepth = i), n.drawOrder = i++
            }
            const s = e._children;
            for (let e = 0; e < s.length; e++) i = t(s[e], i);
            return i
        };
        class e extends pc.ComponentSystem {
            constructor(t) { super(t), this.id = "screen", this.app = t, this.ComponentType = pc.ScreenComponent, pc.ComponentSystem.events.on("update", this._onUpdate, this), this.events.on("beforeremove", this.onRemoveComponent, this) }
            initializeComponentData(t, e, i) { void 0 !== e.priority && (t.priority = e.priority), void 0 !== e.screenSpace && (t.screenSpace = e.screenSpace), t.cull = t.screenSpace, void 0 !== e.screenType && (t.screenType = e.screenType), void 0 !== e.scaleMode && (t.scaleMode = e.scaleMode), void 0 !== e.scaleBlend && (t.scaleBlend = e.scaleBlend), void 0 !== e.screenDistance && (t.screenDistance = e.screenDistance), void 0 !== e.layer && (t.layer = e.layer), void 0 !== e.drawOrder && (t.drawOrder = e.drawOrder), void 0 !== e.resolution && (e.resolution instanceof pc.Vec2 ? t._resolution.copy(e.resolution) : t._resolution.set(e.resolution[0], e.resolution[1]), t.resolution = t._resolution), void 0 !== e.referenceResolution && (e.referenceResolution instanceof pc.Vec2 ? t._referenceResolution.copy(e.referenceResolution) : t._referenceResolution.set(e.referenceResolution[0], e.referenceResolution[1]), t.referenceResolution = t._referenceResolution), t.syncDrawOrder(), pc.ComponentSystem.prototype.initializeComponentData.call(this, t, e, i), t._updateScreenInChildren() }
            destroy() { this.events.off(), this.app.graphicsDevice.events.off("resizecanvas", this._onResize) }
            _syncDrawOrder() { t(pc.Application.getApplication().root, 0) }
            _onUpdate(t) {
                const e = this.store;
                this._dirtyOrder && (this._syncDrawOrder(), this._dirtyOrder = !1);
                for (const i in e) e[i].entity.screen.update && e[i].entity.screen.update(t)
            }
            onRemoveComponent(t, e) { e.onRemove() }
            onDestroy(t, e) { e.onRemove() }
        }
        return { ScreenComponentSystem: e }
    }()), Object.assign(pc, {
        UIUtils: {
            findParentScreen: function(t) {
                let e = t,
                    i = null;
                for (; e;) {
                    if (e.screen) { i = e.screen; break }
                    e = e.parent
                }
                return i
            }
        }
    }), pc.extend(pc, function() {
        pc.ELEMENTTYPE_GROUP = "group", pc.ELEMENTTYPE_IMAGE = "image", pc.ELEMENTTYPE_TEXT = "text";
        const t = new pc.Vec4;
        class e { constructor() { this.enabled = !0 } }
        class i extends pc.Component {
            constructor(t, i) {
                super(t, i), this.data = new e, this._width = 0, this._height = 0, this._stencilLayer = 255, this._anchors = new pc.Vec4, this._pivot = new pc.Vec2(.5, .5), this._sizeDelta = new pc.Vec2(0, 0);
                const n = i.getLocalPosition();
                this._anchoredPosition = new pc.Vec2(n.x, n.y), this.entity.events.on("insert", this._onInsert, this), this._lastSyncAABBVersion = -1, this._dirtyScreen = !1, this._dirtyRect = !1, this.screen = null, this._type = pc.ELEMENTTYPE_GROUP, this._pivotPoint = new pc.Vec3, this._image = null, this._text = null, this._group = null, this._localPositionAnimated = new pc.Vec3, this._dirtyAnimatedLocalPosition = !1, this._anchoredPositionAnimated = new pc.Vec3, this._dirtyAnimatedAnchoredPosition = !1, this._canvasGroups = [], this.cachedRect = new UnityEngine.Rect
            }
            dirtifyScreen() { if (!this._dirtyScreen) { this.entity._app.scene.addDirty(this.entity), this._dirtyScreen = !0; for (const t of this.entity.children) t.element && t.element.dirtifyRect() } }
            dirtifyRect() { if (!this._dirtyRect) { this.entity._app.scene.addDirty(this.entity), this._dirtyRect = !0; for (const t of this.entity.children) t.element && t.element.dirtifyRect() } }
            _getStencilParameters() {
                const t = this._masked ? pc.FUNC_EQUAL : pc.FUNC_ALWAYS,
                    e = this._image && this._image.masksChildren || this._text && this._text.masksChildren;
                return new pc.StencilParameters({ func: t, ref: this._stencilLayer, writeMask: e ? this._stencilLayer : 0, readMask: e ? this._stencilLayer >> 1 : this._stencilLayer, zfail: pc.STENCILOP_KEEP, zpass: pc.STENCILOP_REPLACE, fail: this._masked ? pc.STENCILOP_KEEP : pc.STENCILOP_REPLACE })
            }
            _patch() { this.entity.flags |= pc.GraphNode.Flags.HijackedByElementComponent, this._lastSyncAABBVersion = -1, this.dirtifyRect() }
            _unpatch() { this.entity.flags &= ~pc.GraphNode.Flags.HijackedByElementComponent }
            getRect() { const t = this._findParentElement(); return t && t.element.getRect(), this._dirtyRect && this.entity._sync(), this.cachedRect.m_XMin = -this._pivotPoint.x, this.cachedRect.m_YMin = -this._pivotPoint.y, this.cachedRect.m_Width = this._width, this.cachedRect.m_Height = this._height, this.cachedRect.m_XMax = this.cachedRect.m_XMin + this._width, this.cachedRect.m_YMax = this.cachedRect.m_YMin + this._height, this.cachedRect }
            setVerticesDirty() { this._image && this._image.setVerticesDirty(), this._text && this._text.setVerticesDirty() }
            _onInsert(t) {
                const e = this._findScreen();
                this._updateScreen(e), e && !this.entity.isPrefab && this.entity.getScene() && this.triggerOnElementDimesionsChange(!0, !0)
            }
            _updateScreen(t, e) { this.screen = this._findScreen(), this._patch(), this.events.fire("set:screen", this.screen), this.dirtifyRect(), this.dirtifyScreen(), this._updateScreenForNonElement(this.entity, t, e), this.screen && !e && this.screen.screen.syncDrawOrder() }
            _updateScreenForNonElement(t, e, i) { const n = t.getChildren(); for (let t = 0, s = n.length; t < s; t++) n[t].element ? n[t].element._updateScreen(e, i) : this._updateScreenForNonElement(n[t], e, i) }
            _findScreen() {
                let t = this.entity,
                    e = this.screen;
                for (this._nearestScreen = null; t;) this._nearestScreen = this._nearestScreen || t.screen, e = t.screen || e, t = t._parent;
                return e ? e.entity : null
            }
            _findParentElement() { let t = this.entity._parent; for (; t && !t.element;) t = t._parent; return t }
            _onScreenResize(t) { this.dirtifyScreen(), this.events.fire("screen:set:resolution", t) }
            _onScreenTypeChange() { this.dirtifyScreen(), this.events.fire("screen:set:screentype", this.screen.screen.screenType) }
            addCanvasGroup(t, e) {
                null == e ? e = 0 : this.entity._canvasGroups.length > 0 && e++, this._canvasGroups.splice(e, 0, t);
                const i = this.entity.children;
                for (let n = 0; n < i.length; n++) {
                    const s = i[n].element;
                    s && s.addCanvasGroup(t, e)
                }
            }
            removeCanvasGroup(t) {
                const e = this._canvasGroups.indexOf(t);
                e > -1 && this._canvasGroups.splice(e, 1);
                const i = this.entity.children;
                for (let e = 0; e < i.length; e++) {
                    const n = i[e].element;
                    n && n.removeCanvasGroup(t)
                }
            }
            onRemove() { this.entity.events.off("insert", this._onInsert), this._unpatch(), this._image && this._image.destroy(), this._text && this._text.destroy() }
            triggerOnElementDimesionsChange(t, e) {
                this.entity._elementDimesionsChange();
                const i = this.entity.children;
                for (let n = 0; n < i.length; n++) {
                    if (!i[n]._activeSelf) continue;
                    const s = i[n].element;
                    if (s) {
                        const i = t && s._anchors.x !== s._anchors.z,
                            n = e && s._anchors.y !== s._anchors.w;
                        (i || n) && s.triggerOnElementDimesionsChange(i, n)
                    }
                }
            }
            setupParametersFromImage(t, e, i, n, s, r, o, a, c, h, l, u) {
                const d = this._image;
                if (!d) return;
                const p = d._updateMesh;
                d._updateMesh = function() {}, this["UnityEngine.UI.Image"] = t, d.sprite = e, d.spriteType = i, d.fillMethod = n, d.fillOrigin = s, d.fillAmount = r, d.fillCenter = o, d.pixelsPerUnitMultiplier = a, d.preserveAspect = c, d.ignoreMask = h, d.enabled = l, d.color = t.m_Color, d._updateMesh = p, d._updateMesh(), this.material = u
            }
            get enabled() { return this.data.enabled }
            set enabled(t) {
                const e = this.data.enabled;
                this.data.enabled = t, this.events.fire("set_enabled", "enabled", e, t)
            }
            get type() { return this._type }
            set type(t) { t !== this._type && (this._type = t, this._image && (this._image.destroy(), this._image = null), this._text && (this._text.destroy(), this._text = null), t === pc.ELEMENTTYPE_IMAGE ? this._image = new pc.ImageElement(this) : t === pc.ELEMENTTYPE_TEXT && (this._text = new pc.TextElement(this))) }
            get drawOrder() { return this._drawOrder }
            set drawOrder(t) { this._drawOrder !== t && (this._drawOrder = t, this.events.fire("set:draworder", this._drawOrder)) }
            get width() { return this._width }
            get height() { return this._height }
            get pivot() { return this._pivot }
            set pivot(t) { t instanceof pc.Vec2 ? this._pivot.set(t.x, t.y) : this._pivot.set(t[0], t[1]), this.dirtifyRect() }
            get anchor() { return this._anchors }
            set anchor(e) {
                let i = e;
                if (i instanceof pc.Vec4 || (i = t, i.set(i[0], i[1], i[2], i[3])), i.equals(this._anchors)) return;
                const n = this._anchors.z - this._anchors.x != i.z - i.x,
                    s = this._anchors.w - this._anchors.y != i.w - i.y;
                this._anchors.copy(i), this.dirtifyRect(), (n || s) && this.triggerOnElementDimesionsChange(n, s)
            }
            get anchoredPosition() { return this._anchoredPosition }
            set anchoredPosition(t) { this._anchoredPosition.copy(t), this.dirtifyRect() }
            get sizeDelta() { return this._sizeDelta }
            set sizeDelta(t) {
                const e = this._sizeDelta.x !== t.x,
                    i = this._sizeDelta.y !== t.y;
                (e || i) && (this._sizeDelta.copy(t), this.dirtifyRect(), this.triggerOnElementDimesionsChange(e, i))
            }
            get rect() { return this.getRect() }
            get stencilLayer() { return this._stencilLayer }
            set stencilLayer(t) { this._stencilLayer !== t && (this._stencilLayer = t, this.events.fire("set:stencillayer", t)) }
        }
        const n = function(t) { Object.defineProperty(i.prototype, t, { get: function() { return this._text ? this._text[t] : this._image ? this._image[t] : null }, set: function(e) { this._text ? this._text[t] = e : this._image && (this._image[t] = e) } }) };
        return n("fontSize"), n("color"), n("font"), n("fontAsset"), n("spacing"), n("lineHeight"), n("align"), n("verticalAlign"), n("text"), n("texture"), n("textureAsset"), n("material"), n("materialAsset"), n("opacity"), n("masksChildren"), n("showMaskGraphics"), n("alphaTest"), n("border"), { ElementComponent: i }
    }()), Object.assign(pc, function() {
        class t extends pc.ComponentSystem {
            constructor(t) { super(t), this.id = "element", this.app = t, this.ComponentType = pc.ElementComponent, this.events.on("beforeremove", this.onRemoveComponent, this) }
            destroy() { this._defaultTexture.destroy() }
            initializeComponentData(t, e, i) {
                t._beingInitialized = !0, void 0 !== e.anchor && (e.anchor instanceof pc.Vec4 ? t._anchors.copy(e.anchor) : t._anchors.set(e.anchor[0], e.anchor[1], e.anchor[2], e.anchor[3])), void 0 !== e.pivot && (e.pivot instanceof pc.Vec2 ? t._pivot.copy(e.pivot) : t._pivot.set(e.pivot[0], e.pivot[1])), void 0 !== e.sizeDelta && (e.sizeDelta instanceof pc.Vec2 ? t._sizeDelta.copy(e.sizeDelta) : t._sizeDelta.set(e.sizeDelta[0], e.sizeDelta[1])), void 0 !== e.anchoredPosition && (e.anchoredPosition instanceof pc.Vec2 ? t._anchoredPosition.copy(e.anchoredPosition) : t._anchoredPosition.set(e.anchoredPosition[0], e.anchoredPosition[1]));
                const n = t._findScreen();
                n && n.screen && t._updateScreen(n.screen), pc.ComponentSystem.prototype.initializeComponentData.call(this, t, e, i), t._beingInitialized = !1, t.type === pc.ELEMENTTYPE_IMAGE && t._image._meshDirty && t._image._updateMesh(t._image.mesh)
            }
            onRemoveComponent(t, e) { e.onRemove() }
            _onUpdate(t) { const e = this.store; for (const i in e) e[i].entity.element.update && e[i].entity.element.update(t) }
        }
        return { ElementComponentSystem: t }
    }()), pc.extend(pc, function() {
        let t = null,
            e = null,
            i = null,
            n = 0;
        const s = new pc.Color,
            r = 16,
            o = [0, 1, 2, 0, 2, 3, 0, 3, 4, 0, 4, 5, 0, 5, 6],
            a = [0, 1, 5, 5, 4, 0, 1, 2, 6, 6, 5, 1, 2, 3, 7, 7, 6, 2, 4, 5, 9, 9, 8, 4, 5, 6, 10, 10, 9, 5, 6, 7, 11, 11, 10, 6, 8, 9, 13, 13, 12, 8, 9, 10, 14, 14, 13, 9, 10, 11, 15, 15, 14, 10],
            c = [0, 1, 5, 5, 4, 0, 1, 2, 6, 6, 5, 1, 2, 3, 7, 7, 6, 2, 4, 5, 9, 9, 8, 4, 6, 7, 11, 11, 10, 6, 8, 9, 13, 13, 12, 8, 9, 10, 14, 14, 13, 9, 10, 11, 15, 15, 14, 10],
            h = [0, 0, 0, 0];
        pc.extend(pc, { SPRITE_TYPE_SIMPLE: 0, SPRITE_TYPE_SLICED: 1, SPRITE_TYPE_TILED: 2, SPRITE_TYPE_FILLED: 3, FILL_METHOD_HORIZONTAL: 0, FILL_METHOD_VERTICAL: 1, FILL_METHOD_RADIAL90: 2, FILL_METHOD_RADIAL180: 3, FILL_METHOD_RADIAL360: 4, FILL_ORIGIN_BOTTOM_LEFT: 0, FILL_ORIGIN_TOP_RIGHT: 1, FILL_ORIGIN_RADIAL_BOTTOM: 0, FILL_ORIGIN_RADIAL_RIGHT: 1, FILL_ORIGIN_RADIAL_TOP: 2, FILL_ORIGIN_RADIAL_LEFT: 3 });
        const l = function(t) {
            if (this._element = t, this._entity = t.entity, this._system = t.system, this._textureAsset = null, this._texture = null, this._materialAsset = null, this._material = null, this._masksChildren = !1, this._alphaTest = .01, this._ignoreMask = !1, this._showMaskGraphics = !0, this._enabled = !0, this._rect = new pc.Vec4(0, 0, 1, 1), this._border = new pc.Vec4(0, 0, 0, 0), this._color = new pc.Color(1, 1, 1, 1), this._pivotPoint = new pc.Vec2, this._material = UnityEngine.Canvas.DefaultCanvasMaterial.handle, this._maskMaterial = UnityEngine.Canvas.DefaultCanvasMaterial.handle, this._positions = [], this._normals = [], this._uvs = [], this._indices = [], this._colors = [], this._canvasRenderer = this._entity._unityComponents.canvasRenderer[0], !this._canvasRenderer) {
                const t = new pc.CanvasRendererComponent;
                this._entity.addUnityComponentFromDeserialization("canvasRenderer", t), this._canvasRenderer = this._entity._unityComponents.canvasRenderer[0]
            }
            this._mesh = this._createMesh(), this._model = this._canvasRenderer.model, this._model.setParameter("_TextureSampleAdd", h), this._canvasRenderer.setMesh(this._mesh), this._canvasRenderer.setMaterial(this._material, 0), this._drawOrder = 0, this._fillCenter = !0, this._fillMethod = 0, this._spriteType = 0, this._element.events.on("resize", this._onParentResize, this)
        };
        return pc.extend(l.prototype, {
            destroy: function() { this._canvasRenderer.setMesh(null), this._element.events.off("resize", this._onParentResizes), this._mesh && (this._mesh.destroy(), this._mesh = null) },
            _onParentResize: function() {
                if (this._mesh) {
                    if (this._pivotPoint.equals(this._element._pivotPoint) && this._width === this._element.width && this._height === this._element.height) return;
                    this._updateMesh(this._mesh), this._width = this._element.width, this._height = this._element.height, this._pivotPoint.copy(this._element._pivotPoint)
                }
            },
            setVerticesDirty: function() { this._mesh && this._updateMesh(this._mesh) },
            _updateMaterial: function() {
                const t = this._material || UnityEngine.Canvas.DefaultCanvasMaterial.handle;
                this._canvasRenderer.setMaterial(t, 0)
            },
            _imageIndexBuffer: function() {
                if (t) return t;
                t = new pc.IndexBuffer(this._system.app.graphicsDevice, pc.INDEXFORMAT_UINT16, a.length);
                return new Uint16Array(t.lock()).set(a), t.unlock(), t.destroy = function() {}, t
            },
            _emptyCenterImageIndexBuffer: function() {
                if (e) return e;
                e = new pc.IndexBuffer(this._system.app.graphicsDevice, pc.INDEXFORMAT_UINT16, c.length);
                return new Uint16Array(e.lock()).set(c), e.unlock(), e.destroy = function() {}, e
            },
            _imageRadialIndexBuffer: function() {
                if (i) return i;
                i = new pc.IndexBuffer(this._system.app.graphicsDevice, pc.INDEXFORMAT_UINT16, o.length);
                return new Uint16Array(i.lock()).set(o), i.unlock(), i.destroy = function() {}, i
            },
            _createMesh: function() {
                if (this._entity.isPrefab) return null;
                const t = new pc.VertexFormat(this._system.app.graphicsDevice, [{ semantic: pc.SEMANTIC_POSITION, components: 3, type: pc.TYPE_FLOAT32 }, { semantic: pc.SEMANTIC_TEXCOORD0, components: 2, type: pc.TYPE_FLOAT32 }, { semantic: pc.SEMANTIC_COLOR, components: 4, type: pc.TYPE_FLOAT32 }], r);
                n = 9, this._fillEdges = new pc.Vec4(0, 0, 1, 1), this._buffer = new Float32Array(r * n);
                const e = new pc.VertexBuffer(this._system.app.graphicsDevice, t, r, pc.BUFFER_STATIC, this._buffer.buffer),
                    i = new pc.Mesh(!0);
                return i.vertexBuffer = e, i.indexBuffer[0] = this._imageIndexBuffer(), i.primitive[0].type = pc.PRIMITIVE_TRIANGLES, i.primitive[0].base = 0, i.primitive[0].count = a.length, i.primitive[0].indexed = !0, i.subMeshes = [i], i
            },
            _updateMesh: function() { null == this._texture && (this._spriteType = pc.SPRITE_TYPE_SIMPLE), this._mesh ? (this._spriteType === pc.SPRITE_TYPE_FILLED && this._fillMethod === pc.FILL_METHOD_RADIAL360 ? (this._updateMeshRadial(), this._mesh.indexBuffer[0] = this._imageRadialIndexBuffer(), this._mesh.primitive[0].count = o.length) : (this._updateMeshSquare(), this._fillCenter ? (this._mesh.indexBuffer[0] = this._imageIndexBuffer(), this._mesh.primitive[0].count = a.length) : (this._mesh.indexBuffer[0] = this._emptyCenterImageIndexBuffer(), this._mesh.primitive[0].count = c.length)), this._mesh.alphaCorrected = !1, this._canvasRenderer.setMesh(this._mesh)) : this._canvasRenderer.setMesh(null) },
            _updateMeshSquare: function() {
                const t = this._element.width || 0,
                    e = this._element.height || 0,
                    i = new pc.Vec4(0, 0, 0, 0),
                    s = new pc.Vec2(0, 0);
                this._calculatePaddings(t, e, i, s), this._spriteType === pc.SPRITE_TYPE_FILLED ? (this._fillMethod === pc.FILL_METHOD_HORIZONTAL && this._fillEdges.set(this._fillOrigin === pc.FILL_ORIGIN_BOTTOM_LEFT ? 0 : 1 - this._fillAmount, 0, this._fillOrigin === pc.FILL_ORIGIN_BOTTOM_LEFT ? this._fillAmount : 1, 1), this._fillMethod === pc.FILL_METHOD_VERTICAL && this._fillEdges.set(0, this._fillOrigin === pc.FILL_ORIGIN_BOTTOM_LEFT ? 0 : 1 - this._fillAmount, 1, this._fillOrigin === pc.FILL_ORIGIN_BOTTOM_LEFT ? this._fillAmount : 1)) : this._fillEdges.set(0, 0, 1, 1);
                let r = this._spriteType === pc.SPRITE_TYPE_SLICED || this._spriteType === pc.SPRITE_TYPE_TILED ? 1 : 0;
                this._sprite && this._element.screen && (r = r * this._element.screen.screen.referencePixelsPerUnit / this.multipliedPixelsPerUnit);
                const o = [i.x + t * this._fillEdges.x, i.x + t * this._fillEdges.x + Math.min(this._border.x * r, .5 * t), i.x + (t - i.x - i.z) * this._fillEdges.z - Math.min(this._border.z * r, .5 * t), i.x + (t - i.x - i.z) * this._fillEdges.z],
                    a = [i.y + (e - i.y - i.w) * this._fillEdges.w, i.y + (e - i.y - i.w) * this._fillEdges.w - Math.min(this._border.w * r, .5 * e), i.y + e * this._fillEdges.y + Math.min(this._border.y * r, .5 * e), i.y + e * this._fillEdges.y],
                    c = [pc.math.lerp(this._rect.x, this._rect.x + this._rect.z, this._fillEdges.x), pc.math.lerp(this._rect.x, this._rect.x + this._rect.z, this._fillEdges.x), pc.math.lerp(this._rect.x, this._rect.x + this._rect.z, this._fillEdges.z), pc.math.lerp(this._rect.x, this._rect.x + this._rect.z, this._fillEdges.z)],
                    h = [pc.math.lerp(this._rect.y, this._rect.y + this._rect.w, this._fillEdges.w), pc.math.lerp(this._rect.y, this._rect.y + this._rect.w, this._fillEdges.w), pc.math.lerp(this._rect.y, this._rect.y + this._rect.w, this._fillEdges.y), pc.math.lerp(this._rect.y, this._rect.y + this._rect.w, this._fillEdges.y)];
                if (this._spriteType !== pc.SPRITE_TYPE_SLICED && this._spriteType !== pc.SPRITE_TYPE_TILED || !this._texture) this._spriteType, pc.SPRITE_TYPE_TILED;
                else {
                    if (c[1] += this._border.x / this._texture.width, c[2] -= this._border.z / this._texture.width, o[1] > o[2]) {
                        const t = o[1];
                        o[1] = o[2], o[2] = t
                    }
                    if (h[1] -= this._border.w / this._texture.height, h[2] += this._border.y / this._texture.height, a[2] > a[1]) {
                        const t = a[1];
                        a[1] = a[2], a[2] = t
                    }
                }
                const l = this._mesh.vertexBuffer,
                    u = this.color,
                    d = new Float32Array(l.storage);
                for (let t = 0; t < 4; t++)
                    for (let e = 0; e < 4; e++) {
                        let i = (4 * t + e) * n;
                        d[i++] = -this._element._pivotPoint.x + o[e], d[i++] = -this._element._pivotPoint.y + a[t], d[i++] = 0, d[i++] = c[e], d[i++] = h[t], d[i++] = u.r, d[i++] = u.g, d[i++] = u.b, d[i++] = u.a
                    }
                l.unlock()
            },
            _calculatePaddings: function(t, e, i, n) {
                let s = t,
                    r = e,
                    o = 1,
                    a = 1;
                if (this._texture && (s = this._texture.width, r = this._texture.height), this._sprite) {
                    i.copy(this._sprite.transparency);
                    const t = this._sprite.getTextureRect();
                    s = t.z - t.x + i.x + i.z, r = t.w - t.y + i.y + i.w
                }
                if (t === s && e === r || (o = t / s, a = e / r), n.x = t, n.y = e, this._preserveAspect && this._spriteType !== pc.SPRITE_TYPE_SLICED && this._spriteType !== pc.SPRITE_TYPE_TILED) {
                    const t = Math.min(o, a);
                    n.x = t * s, n.y = t * r, i.scale(t)
                } else 1 === o && 1 === a || (i.x *= o, i.y *= a, i.z *= o, i.w *= a);
                return n.x === t && n.y === e || i.add(new pc.Vec4((t - n.x) * this._element.pivot.x, (e - n.y) * this._element.pivot.y, (t - n.x) * (1 - this._element.pivot.x), (e - n.y) * (1 - this._element.pivot.y))), i
            },
            _updateMeshRadial: function() {
                const t = this._element.width || 0,
                    e = this._element.height || 0,
                    i = new pc.Vec4(0, 0, 0, 0),
                    s = new pc.Vec2(0, 0);
                this._calculatePaddings(t, e, i, s);
                let o = 360 * this._fillAmount;
                const a = s.x / 2,
                    c = i.x + a,
                    h = s.y / 2,
                    l = i.y + h,
                    u = this._rect.z / 2,
                    d = this._rect.w / 2,
                    p = this._rect.x + u,
                    _ = this._rect.y + d,
                    f = [c],
                    m = [l],
                    y = [p],
                    g = [_];
                let E = 0,
                    A = 0,
                    b = !1;
                switch (this._fillOrigin) {
                    case pc.FILL_ORIGIN_RADIAL_BOTTOM:
                        A = 270;
                        break;
                    case pc.FILL_ORIGIN_RADIAL_RIGHT:
                        A = 0;
                        break;
                    case pc.FILL_ORIGIN_RADIAL_TOP:
                        A = 90;
                        break;
                    case pc.FILL_ORIGIN_RADIAL_LEFT:
                        A = 180
                }
                const C = this._element["UnityEngine.UI.Image"].m_FillClockwise ? -1 : 1;
                let T = 0,
                    S = 0;
                for (; o > 0;) {
                    const t = Math.min(o, E);
                    A += C * t, A = (A + 360) % 360, A <= 45 || A > 315 ? (f.push(c + a), y.push(p + u), S = Math.tan(A * pc.math.DEG_TO_RAD), m.push(l + h * S), g.push(_ + d * S)) : A <= 135 ? (T = 1 / Math.tan(A * pc.math.DEG_TO_RAD), f.push(c + a * T), y.push(p + u * T), m.push(l + h), g.push(_ + d)) : A <= 225 ? (f.push(c - a), y.push(p - u), S = -Math.tan(A * pc.math.DEG_TO_RAD), m.push(l + h * S), g.push(_ + d * S)) : A <= 315 && (T = -1 / Math.tan(A * pc.math.DEG_TO_RAD), f.push(c + a * T), y.push(p + u * T), m.push(l - h), g.push(_ - d)), o -= t, b ? E = 90 : (E = 45, b = !0)
                }
                for (; f.length < r;) f.push(c);
                for (; m.length < r;) m.push(l);
                for (; y.length < r;) y.push(p);
                for (; g.length < r;) g.push(_);
                const M = this._mesh.vertexBuffer,
                    x = this.color,
                    P = new Float32Array(M.storage);
                for (let t = 0; t < r; t++) P[t * n + 0] = -this._element._pivotPoint.x + f[t], P[t * n + 1] = -this._element._pivotPoint.y + m[t], P[t * n + 2] = 0, P[t * n + 3] = y[t], P[t * n + 4] = g[t], P[t * n + 5] = x.r, P[t * n + 6] = x.g, P[t * n + 7] = x.b, P[t * n + 8] = x.a;
                M.unlock()
            },
            synchornizeProperties: function(t, e) {
                const i = t.m_OverrideSprite || t.m_Sprite,
                    n = i ? i.handle : null,
                    r = e && t.m_Texture ? t.m_Texture.handle : null,
                    o = e ? this._texture !== r : this._sprite !== n,
                    a = e && (t.m_UVRect.m_XMin !== this._rect.x || t.m_UVRect.m_YMin !== this._rect.y || t.m_UVRect.m_Width !== this._rect.z || t.m_UVRect.m_Height !== this._rect.w);
                (this._fillCenter !== t.m_FillCenter || this._fillAmount !== t.m_FillAmount || this._fillMethod !== t.m_FillMethod || this._fillOrigin !== t.m_FillOrigin || o || a) && (e && this._texture !== r ? this.texture = r : e || this._sprite === n || (this.sprite = n), a && this._rect.set(t.m_UVRect.m_XMin, t.m_UVRect.m_YMin, t.m_UVRect.m_Width, t.m_UVRect.m_Height), e || (this._fillCenter = t.m_FillCenter, this._fillAmount = t.m_FillAmount, this._pixelsPerUnitMultiplier = t.m_PixelsPerUnitMultiplier, this._fillMethod = t.m_FillMethod, this._fillOrigin = t.m_FillOrigin), this._updateMesh()), s.copy(t.m_Color)
            }
        }), Object.defineProperty(l.prototype, "color", { get: function() { return this._color }, set: function(t) { this._color.copy(t) } }), Object.defineProperty(l.prototype, "masksChildren", { get: function() { return this._masksChildren }, set: function(t) { this._masksChildren = t, this._canvasRenderer.model.masksChildren = t, this._element && this._element.screen && (this._element.screen.screen.canvasMeshInstance.renderersDirty = !0) } }), Object.defineProperty(l.prototype, "alphaTest", { get: function() { return this._alphaTest }, set: function(t) { this._alphaTest = t, this._updateMaterial() } }), Object.defineProperty(l.prototype, "opacity", { get: function() { return this._color.data[3] }, set: function(t) { this._color.a = t, this.color = this._color } }), Object.defineProperty(l.prototype, "rect", { get: function() { return this._rect }, set: function(t) { t instanceof pc.Vec4 ? this._rect.set(t.x, t.y, t.z, t.w) : this._rect.set(t[0], t[1], t[2], t[3]), this._mesh && this._updateMesh(this._mesh) } }), Object.defineProperty(l.prototype, "border", { get: function() { return this._border }, set: function(t) { t instanceof pc.Vec4 ? this._border.set(t.x, t.y, t.z, t.w) : this._border.set(t[0], t[1], t[2], t[3]), this._mesh && this._updateMesh(this._mesh) } }), Object.defineProperty(l.prototype, "material", { get: function() { return this._material }, set: function(t) { this._material = t, this._updateMaterial() } }), Object.defineProperty(l.prototype, "texture", { get: function() { return this._texture }, set: function(t) { this._texture = t, this._canvasRenderer.setTexture(this._texture), this._mesh && this._updateMesh(this._mesh) } }), Object.defineProperty(l.prototype, "ignoreMask", { get: function() { return this._ignoreMask }, set: function(t) { this._ignoreMask = t, t && (this.alphaTest = 0), this._updateMaterial() } }), Object.defineProperty(l.prototype, "showMaskGraphics", { get: function() { return this._showMaskGraphics }, set: function(t) { this._showMaskGraphics = t, this._canvasRenderer.showMaskGraphics = t, this._updateMaterial() } }), Object.defineProperty(l.prototype, "enabled", {
            get: function() { return this._enabled },
            set: function(t) {
                if (this._enabled === t) return;
                this._enabled = t, this._canvasRenderer.enabled = t;
                const e = this._enabled ? this._canvasRenderer.findParentCanvas() : null;
                this._canvasRenderer.reparentCanvas(e)
            }
        }), Object.defineProperty(l.prototype, "sprite", {
            set: function(t) {
                if (this._sprite = t, t) {
                    this._texture = t.texture, this._canvasRenderer.setTexture(this._texture);
                    const e = t.uvRect;
                    e instanceof pc.Vec4 ? this._rect.set(e.x, e.y, e.z, e.w) : this._rect.set(e[0], e[1], e[2], e[3]);
                    const i = this.spriteType === pc.SPRITE_TYPE_SIMPLE ? pc.Vec4.ZERO : t.border;
                    i instanceof pc.Vec4 ? this._border.set(i.x, i.y, i.z, i.w) : this._border.set(i[0], i[1], i[2], i[3])
                } else this._texture = null, this._canvasRenderer.setTexture(this._texture);
                this._updateMesh()
            },
            get: function() { return this._sprite }
        }), Object.defineProperty(l.prototype, "spriteType", { set: function(t) { this._spriteType = t, this.sprite = this._sprite }, get: function() { return this._spriteType || pc.SPRITE_TYPE_SLICED } }), Object.defineProperty(l.prototype, "preserveAspect", { set: function(t) { this._preserveAspect = t, this._updateMesh() }, get: function() { return this._preserveAspect } }), Object.defineProperty(l.prototype, "fillMethod", { set: function(t) { this._fillMethod = t, this._updateMesh() }, get: function() { return this._fillMethod } }), Object.defineProperty(l.prototype, "fillCenter", { set: function(t) { this._fillCenter = t, this._updateMesh() }, get: function() { return this._fillCenter } }), Object.defineProperty(l.prototype, "fillOrigin", { set: function(t) { this._fillOrigin = t, this._updateMesh() }, get: function() { return this._fillOrigin } }), Object.defineProperty(l.prototype, "fillAmount", { set: function(t) { this._fillAmount = t, this._updateMesh() }, get: function() { return this._fillAmount } }), Object.defineProperty(l.prototype, "pixelsPerUnitMultiplier", { set: function(t) { this._pixelsPerUnitMultiplier = t, this._updateMesh() }, get: function() { return this._pixelsPerUnitMultiplier } }), Object.defineProperty(l.prototype, "multipliedPixelsPerUnit", { get: function() { return this._sprite.pixelsPerUnit * this._pixelsPerUnitMultiplier } }), { ImageElement: l }
    }()), pc.extend(pc, function() {
        const t = [1, 1, 1, 0],
            e = new pc.Color,
            i = new pc.Vec3,
            n = function(e) {
                if (this._element = e, this._system = e.system, this._entity = e.entity, this._text = "", this._enabled = !0, this._horizontalWrap = !1, this._verticalOverflow = !1, this._align = pc.TEXT_ALIGN_CENTER, this._veticalAlign = pc.TEXT_VERTICAL_ALIGN_MIDDLE, this._fontAsset = null, this._font = null, this._color = new pc.Color(1, 1, 1, 1), this._spacing = 1, this._fontSize = 32, this._lineHeight = 1, this._bestFit = !1, this._minFontSize = 0, this._maxFontSize = 1e3, this.width = 0, this.height = 0, this._material = null, this._canvasRenderer = this._entity._unityComponents.canvasRenderer ? this._entity._unityComponents.canvasRenderer[0] : null, !this._canvasRenderer) {
                    const t = new pc.CanvasRendererComponent;
                    this._entity.addUnityComponentFromDeserialization("canvasRenderer", t), this._canvasRenderer = this._entity._unityComponents.canvasRenderer[0]
                }
                this._mesh = this._createMesh(""), this._model = this._canvasRenderer.model, this._model.setParameter("_TextureSampleAdd", t), this._canvasRenderer.setMesh(this._mesh), this._canvasRenderer.setMaterial(this._material, 0), this._positions = [], this._normals = [], this._uvs = [], this._indices = [], this._spacings = new pc.Vec4(0, 0, 0, 0), this._noResize = !1, this._masksChildren = !1
            };
        return pc.extend(n.prototype, {
            destroy: function() { this._canvasRenderer.setMesh(null), this._element.events.off("resize", this._onParentResize), this._mesh && (this._mesh.destroy(), this._mesh = null) },
            _updateMaterial: function() {
                const t = this._material || UnityEngine.Canvas.DefaultCanvasMaterial.handle;
                this._canvasRenderer.setMaterial(t, 0)
            },
            _createMesh: function() {
                if (this._entity.isPrefab) return null;
                this.bounds = new pc.Vec2, this._textOffsets = new pc.Vec3, this._textGenerator = new pc.TextGenerator(this.canvasRenderer), this._computedAlpha = 1;
                const t = pc.TextGenerator.createEmptyMesh();
                return t.subMeshes = [t], t
            },
            _updateAligns: function(t) { void 0 !== this._element.width && void 0 !== this._element.height && (t || (this.bounds.set(this._element.width, this._element.height), this._textGenerator.populate(this.text, this)), i.set(-this._element._pivotPoint.x, -this._element._pivotPoint.y, 0).add(this._textGenerator.offset), this._textGenerator.updateMesh(this._mesh, this, i)) },
            _updateMesh: function(t, e) {
                if (this._entity.isPrefab) return;
                if (this._element._dirtyRect && this._entity._sync(), !(0 === this._element.width || 0 === this._element.height || this._element && this._element.width && this._element.height)) return;
                this.bounds.set(this._element.width, this._element.height), this._textGenerator.populate(e, this);
                0 !== this._textGenerator.vertexCount ? (this._dirtyVertices && this._textGenerator.updateMesh(this._mesh, this), this._dirtyOffset && this._updateAligns(!0), (this._dirtyVertices || this._dirtyOffset) && this._element.dirtifyRect(), this._canvasRenderer.getMesh() || this._canvasRenderer.setMesh(t)) : this._canvasRenderer.setMesh(null)
            },
            setVerticesDirty: function() { this._updateText(this._text) },
            _updateText: function(t) { this._font && (void 0 === t && (t = this._text), this._mesh || (this._updateMaterial(), this._mesh = this._createMesh(t), this._canvasRenderer.setMesh(this._mesh)), this._updateMesh(this._mesh, t), this._canvasRenderer.setTexture(this._font.texture)) },
            synchornizeProperties: function(t) { e.copy(t.m_Color) }
        }), Object.defineProperty(n.prototype, "text", {
            get: function() { return this._text },
            set: function(t) {
                const e = (t || "").toString();
                this._text !== e && (this._font && this._updateText(e), this._text = e)
            }
        }), Object.defineProperty(n.prototype, "color", { get: function() { return this._color }, set: function(t) { this._color.copy(t) } }), Object.defineProperty(n.prototype, "opacity", { get: function() { return this._color.data[3] }, set: function(t) { this._color.a = t, this.color = this._color } }), Object.defineProperty(n.prototype, "lineHeight", { get: function() { return this._lineHeight }, set: function(t) { this._lineHeight = t } }), Object.defineProperty(n.prototype, "lineSpacing", { get: function() { return this._spacing }, set: function(t) { this._spacing = t } }), Object.defineProperty(n.prototype, "align", { get: function() { return this._align }, set: function(t) { this._align = t } }), Object.defineProperty(n.prototype, "verticalAlign", { get: function() { return this._veticalAlign }, set: function(t) { this._veticalAlign = t } }), Object.defineProperty(n.prototype, "fontSize", { get: function() { return this._fontSize }, set: function(t) { this._fontSize = t } }), Object.defineProperty(n.prototype, "horizontalWrap", { get: function() { return this._horizontalWrap }, set: function(t) { this._horizontalWrap = t } }), Object.defineProperty(n.prototype, "verticalOverflow", { get: function() { return this._verticalOverflow }, set: function(t) { this._verticalOverflow = t } }), Object.defineProperty(n.prototype, "font", { get: function() { return this._font }, set: function(t) { this._font = t } }), Object.defineProperty(n.prototype, "bestFit", { get: function() { return this._bestFit }, set: function(t) { this._bestFit = t } }), Object.defineProperty(n.prototype, "minFontSize", { get: function() { return this._minFontSize }, set: function(t) { this._minFontSize = t } }), Object.defineProperty(n.prototype, "maxFontSize", { get: function() { return this._maxFontSize }, set: function(t) { this._maxFontSize = t } }), Object.defineProperty(n.prototype, "enabled", {
            get: function() { return this._enabled },
            set: function(t) {
                if (this._enabled === t) return;
                this._enabled = t, this._canvasRenderer.enabled = t, !this._enabled && this._textGenerator && this._textGenerator._reset();
                const e = this._enabled ? this._canvasRenderer.findParentCanvas() : null;
                this._canvasRenderer.reparentCanvas(e)
            }
        }), Object.defineProperty(n.prototype, "material", { get: function() { return this._material }, set: function(t) { this._material = t, this._updateMaterial() } }), Object.defineProperty(n.prototype, "masksChildren", {
            get: function() { return this._masksChildren },
            set: function(t) {
                this._masksChildren = t;
                const e = this._canvasRenderer.model.meshInstances;
                for (let i = 0; i < e.length; i++) {
                    const n = e[i];
                    t ? n._shaderDefs |= pc.SHADERDEF_UI_MASK : n._shaderDefs &= ~pc.SHADERDEF_UI_MASK
                }
                this._element && this._element.screen && (this._element.screen.screen.canvasMeshInstance.renderersDirty = !0)
            }
        }), Object.defineProperty(n.prototype, "tintTexture", { set: function(t) { this._tintTexture = t, this._updateText(this._text) }, get: function() { return this._tintTexture } }), { TextElement: n, TEXT_ALIGN_LEFT: "left", TEXT_ALIGN_RIGHT: "right", TEXT_ALIGN_CENTER: "center", TEXT_VERTICAL_ALIGN_TOP: "top", TEXT_VERTICAL_ALIGN_MIDDLE: "middle", TEXT_VERTICAL_ALIGN_BOTTOM: "bottom" }
    }()), Object.assign(pc, function() {
        pc.FONT_MSDF = "msdf", pc.FONT_BITMAP = "bitmap";
        const t = function(t, e) { this.type = t && t.type || pc.FONT_MSDF, this.em = 1, this.intensity = 0, this._data = null, this.data = t, this._name = e.name || "", this._ascent = t.info.ascent || 0, this._lineHeight = e.originalLineHeight || 0, this._fontSize = t.info.fontSize || null, this._originalFontSize = e.originalFontSize || 64, this._characterInfo = e.characterInfo || null, this._textures = e.texture || null };
        return Object.defineProperty(t.prototype, "name", { get: function() { return this._name } }), Object.defineProperty(t.prototype, "ascent", { get: function() { return this._ascent } }), Object.defineProperty(t.prototype, "lineHeight", { get: function() { return this._lineHeight } }), Object.defineProperty(t.prototype, "fontSize", { get: function() { return this._fontSize } }), Object.defineProperty(t.prototype, "characterInfo", { get: function() { return this._characterInfo } }), Object.defineProperty(t.prototype, "texture", { get: function() { return this._textures } }), Object.defineProperty(t.prototype, "data", {
            get: function() { return this._data },
            set: function(t) {
                if (this._data = t, t && (void 0 !== this._data.intensity && (this.intensity = this._data.intensity), this._data.info || (this._data.info = {}), (!this._data.version || this._data.version < 2) && (this._data.info.maps = [{ width: this._data.info.width, height: this._data.info.height }], this._data.chars)))
                    for (const t in this._data.chars) this._data.chars.hasOwnProperty(t) && (this._data.chars[t].map = 0)
            }
        }), { FONT_MSDF: pc.FONT_MSDF, Font: t }
    }()), Object.assign(pc, function() {
        const t = "unity_GUIZTestMode",
            e = function(e) {
                this.id = pc.Mesh.id++, this.entity = e.entity, this.parentScreen = e, this.renderers = [], this.device = pc.Application.getApplication().graphicsDevice, this.renderer = pc.Application.getApplication().renderer, this.renderersDirty = !1, this._aabb = new pc.BoundingBox, this.node = e.entity, this.visible = !0, this.cull = !0, this.isCanvas = !0, this._material = UnityEngine.Canvas.GetDefaultCanvasMaterial().handle, this._material.setParameter(t, pc.FUNC_ALWAYS + 1);
                const i = this._material.parameters[t];
                i.scopeId || (i.scopeId = this.device.scope.resolve(t)), this._mesh = {}, this.scene = pc.Application.getApplication().scene, this.drawCalls = [], this.meshInstances = []
            };
        return Object.assign(e.prototype, {
            uiElementsSort: function(t, e) { return pc.SortUtils.uiElementsSort(t.model, e.model) },
            render: function(e, i, n, s, r) {
                this.checkDirtyAndUpdateHierarchy(), this.drawCalls.length = 0, this.meshInstances.length = 0;
                const o = this.renderers,
                    a = [];
                for (let t = 0; t < o.length; t++) {
                    const e = o[t];
                    if (!e.isCanvas && (0 === e._groupAlpha || e.culledByTransparency)) continue;
                    !e.isCanvas && e.popMaterialCount > 0 && a.push(e);
                    const i = e.model.meshInstances;
                    for (let t = 0; t < i.length; t++) {
                        const e = i[t];
                        (e.isCanvas || 0 !== e._mesh.primitive[0].count) && (e.material && this.meshInstances.push(e))
                    }
                }
                n ? pc.Culling.cullUi(n, this.meshInstances, this.drawCalls) : this.drawCalls = this.meshInstances;
                for (let t = 0; t < a.length; t++) {
                    const e = a[t],
                        i = this.getLastDrawChild(e.entity, this.drawCalls, 0);
                    if (i) {
                        const t = i.node._guid;
                        this.scene.activeUiMasks[t] || (this.scene.activeUiMasks[t] = []), this.scene.activeUiMasks[t].push(e)
                    }
                }
                const c = this.parentScreen.screenType !== pc.SCREEN_TYPE_SCREEN ? pc.FUNC_LESSEQUAL + 1 : pc.FUNC_ALWAYS + 1;
                for (let o = 0; o < this.drawCalls.length; o++) {
                    const a = this.drawCalls[o];
                    if (a.isCanvas) { a.render(e, i, n, s, r); continue }
                    a.material.setParameter(t, c), this.renderer.renderMeshInstance(e, i, n, a, r);
                    const h = this.scene.activeUiMasks[a.node._guid];
                    if (h) {
                        for (let t = 0; t < h.length; t++) {
                            const s = h[t],
                                o = s._popMaterials,
                                a = s.model.meshInstances[0];
                            if (a)
                                for (let t = 0; t < o.length; t++) {
                                    const s = o[t].handle;
                                    this.clearMask(e, i, n, a, r, s)
                                }
                        }
                        this.scene.activeUiMasks[a.node._guid] = null
                    }
                }
                if (!this.parentScreen.parentScreen)
                    for (const t in this.scene.activeUiMasks) this.scene.activeUiMasks[t] = null
            },
            getLastDrawChild(t, e, i) {
                let n = null;
                const s = t.allChildren();
                for (let t = i + 1; t < e.length; t++) {
                    const i = e[t],
                        r = i.node;
                    s.indexOf(r) >= 0 && (n = i)
                }
                return n
            },
            clearMask(t, e, i, n, s, r) {
                const o = n.material,
                    a = n.parameters.hasOwnProperty("_ColorMask") ? n.parameters._ColorMask.data : null;
                n.material = r, a && (n.parameters._ColorMask.data = r.parameters._ColorMask.data), this.renderer.renderMeshInstance(t, e, i, n, s), n.material = o, a && (n.parameters._ColorMask.data = a)
            },
            addRenderer: function(t) { this.renderers.includes(t) || (this.renderers.push(t), this.renderersDirty = !0) },
            removeRenderer: function(t) { this.renderers.includes(t) && (this.renderers.splice(this.renderers.indexOf(t), 1), this.renderersDirty = !0) },
            checkDirtyAndUpdateHierarchy() {
                if (this.updateModel(), !this.renderersDirty) return;
                this.parentScreen.system._syncDrawOrder(), this.parentScreen._updateStencilParameters(), this.renderers.sort(this.uiElementsSort), this._aabb.setToInfinity();
                const t = this.renderers;
                for (let e = 0; e < t.length; e++) { const i = t[e].model.meshInstances; for (let t = 0; t < i.length; t++) this._aabb.add(i[t].aabb) }
                this.renderersDirty = !1
            },
            updateModel: function() {
                const t = this.renderers;
                for (let e = 0; e < t.length; e++) {
                    const i = t[e];
                    i.isCanvas || i.model.update()
                }
            }
        }), Object.defineProperty(e.prototype, "aabb", { get: function() { return this.checkDirtyAndUpdateHierarchy(), this._aabb } }), Object.defineProperty(e.prototype, "mesh", { get: function() { return this._mesh } }), Object.defineProperty(e.prototype, "sortingLayerIndex", { get: function() { return this.parentScreen.sortingLayerIndex } }), Object.defineProperty(e.prototype, "sortingOrder", { get: function() { return this.parentScreen.sortingOrder } }), Object.defineProperty(e.prototype, "drawOrder", { get: function() { return this.parentScreen.drawOrder } }), Object.defineProperty(e.prototype, "material", { get: function() { return this._material }, set: function(t) { this._material = t } }), Object.defineProperty(e.prototype, "model", { get: function() { return this.parentScreen } }), { CanvasMeshInstance: e }
    }()), pc.extend(pc, function() {
        const t = new Set,
            e = 0,
            i = 1,
            n = 2,
            s = 3,
            r = function(t, i) { this.id = t.keyId, this.curve = t, this.value = null, this._value = null, this.target = i, this.idx = null, this.interoplateType = e };
        r.prototype = { set: function(t) { this.dirty = this.dirty || t !== this._value || this.curve.targetsLocalEulerAnglesRaw, this._value = t, this.value = t } };
        const o = function() { this.keys = {}, this.keyArray = [], this.eventsMemo = {}, this.events = [], this.aQuat = new pc.Quat, this.bQuat = new pc.Quat, this.resultQuat = new pc.Quat, this.copiedFrom = {}, this.id = pc.guid.create() };
        return o.prototype = {
            putKey: function(t) { this.keys[t.id] = t, this.keyArray.push(t) },
            pushEvent: function(t) { t.id = t.id || pc.guid.create(), this.eventsMemo[t.id] || (this.eventsMemo[t.id] = !0, this.events.push(t)) },
            popEvents: function() { const t = this.events; return this.events = [], t },
            recycleEvents: function() { let t = -1; for (let e = 0; e < this.events.length; e++) t = Math.max(t, this.events.time); return this.events = [], this.eventsMemo = {}, t },
            copyKeysFromSampler: function(t) {
                for (let e = 0; e < t.keyArray.length; e++) {
                    const i = t.keyArray[e];
                    this.keys[i.id] || this.putKey(new r(i.curve, i.target))
                }
                this.copiedFrom[t.id] = !0, this.targetObjectsSet = !1
            },
            blendSamplers: function(t, r, o, a) {
                this.copiedFrom[t.id] || this.copyKeysFromSampler(t), this.copiedFrom[o.id] || this.copyKeysFromSampler(o);
                const c = a / (r + a);
                if (!Number.isNaN(c))
                    for (let r = 0; r < this.keyArray.length; r++) {
                        const a = this.keyArray[r];
                        if (t.keys[a.id])
                            if (o.keys[a.id]) switch (a.interoplateType === e && (a.interoplateType = this.figureInterpolateType(a.curve, a)), a.interoplateType) {
                                case i:
                                    {
                                        const e = this.keyArray[r + 0],
                                            i = this.keyArray[r + 1],
                                            n = this.keyArray[r + 2],
                                            s = this.keyArray[r + 3];null == this.aQuat ? this.resultQuat = this.bQuat : null == this.bQuat ? this.resultQuat = this.aQuat : (this.aQuat.x = t.keys[e.id].value, this.aQuat.y = t.keys[i.id].value, this.aQuat.z = t.keys[n.id].value, this.aQuat.w = t.keys[s.id].value, this.bQuat.x = o.keys[e.id].value, this.bQuat.y = o.keys[i.id].value, this.bQuat.z = o.keys[n.id].value, this.bQuat.w = o.keys[s.id].value, this.resultQuat = this.resultQuat.slerp(this.aQuat, this.bQuat, c)),
                                        e.set(this.resultQuat.x),
                                        i.set(this.resultQuat.y),
                                        n.set(this.resultQuat.z),
                                        s.set(this.resultQuat.w),
                                        r += 3
                                    }
                                    break;
                                case s:
                                    a.set(t.keys[a.id].value);
                                    break;
                                case n:
                                    { let e = (1 - c) * t.keys[a.id].value + c * o.keys[a.id].value;Object.is(e, -0) && (e = 0), a.set(e) }
                                    break;
                                case e:
                                    console.log("Undefined")
                            } else a.set(t.keys[a.id].value);
                            else a.set(o.keys[a.id].value)
                    }
            },
            figureInterpolateType: function(t, e) { const r = e.curve.targetObject; return e.target && null != e.target[r] && e.target[r].constructor === pc.Quat || "m_LocalRotation" === r ? i : t.objectCurve ? s : n },
            ensureTargetObjects: function(t) {
                t.__defaults__ = t.__defaults__ || {};
                for (let e = 0; e < this.keyArray.length; e++) {
                    const i = this.keyArray[e];
                    if (i.target || (i.target = this.findTargetObject(t.handle, i.curve), i.interoplateType = this.figureInterpolateType(i.curve, i)), i.target && !t.__defaults__.hasOwnProperty(i.id)) {
                        const e = new r(i.curve, i.target);
                        if (i.curve.targetObject) {
                            if (!i.target[i.curve.targetObject]) continue;
                            i.curve.isMaterialPropertyCurve ? this.setMaterialProperty(e, i) : this.setObjectProperty(e, i)
                        } else e.value = i.target[i.curve.targetProperty];
                        t.__defaults__[e.id] = e
                    }
                }
                this.targetObjectsSet = !0
            },
            findTargetObject: function(t, e) { const i = e.path.split("/"); for (let e = 0; e < i.length && null != t; e++) i[e].length > 0 && (t = t.findByNameImmediate(i[e])); if (null == t) return null; if ("UnityEngine.GameObject" === e.componentType) return UnityEngine.Object.FromHandle(UnityEngine.GameObject, t); const n = Bridge._getTypeByName(e.componentType); return UnityEngine.Object.FromHandle(UnityEngine.GameObject, t).GetComponent(n) },
            setMaterialProperty: function(t, e) {
                const i = e.target[e.curve.targetObject],
                    n = e.curve.targetProperty,
                    s = i.handle.parameters[n].data;
                e.curve.isVectorProperty ? t.value = s[e.curve.vectorPropertyIndex] : t.value = s
            },
            setObjectProperty: function(t, e) { t.value = e.target[e.curve.targetObject][e.curve.targetProperty] },
            applyKey: function(t) {
                if (!t.target) return;
                let e = t.target[t.curve.targetObject];
                if (!e) return void(t.target[t.curve.targetProperty] = t.value);
                const i = t.curve.targetProperty;
                t.curve.isMaterialPropertyCurve ? (e = t.target[t.curve.targetObject].handle.parameters, t.curve.isVectorProperty ? (e[i].data[t.curve.vectorPropertyIndex] = t.value, e[i].scopeId && e[i].scopeId.versionObject.increment()) : e[i].data = t.value) : e[t.curve.targetProperty] = t.value
            },
            getOrCreateKey(t, e) { let i = this.keys[e]; return i || (i = new r(t, void 0), this.putKey(i)), i },
            writeDefaults: function(t) {
                if (t.__defaults__)
                    for (const e in t.__defaults__) {
                        const i = t.__defaults__[e];
                        this.applyKey(i);
                        const n = i.target;
                        n.OnDidApplyAnimationProperties && n.OnDidApplyAnimationProperties(), n.entity && n.entity.releaseHijackedProperties()
                    }
            },
            apply: function(e) {
                this.targetObjectsSet || this.ensureTargetObjects(e), t.clear();
                for (let e = 0; e < this.keyArray.length; e++) {
                    const i = this.keyArray[e];
                    i.dirty && (i.dirty = !1, i.target && i.curve.targetObject && !i.target[i.curve.targetObject] || (i.target && (i.target.OnDidApplyAnimationProperties || i.target.entity) && t.add(i.target), this.applyKey(i)))
                }
                for (const e of t) e.OnDidApplyAnimationProperties && e.OnDidApplyAnimationProperties(), e.entity && e.entity.releaseHijackedProperties()
            }
        }, { CurveSampler: o }
    }()), pc.extend(pc, function() {
        const t = function() { pc.Material.prototype.constructor.apply(this), this.keywords = new pc.KeywordSet, this.drawOrder = 0, this.renderQueue = 0, this.enableInstancing = !1 };
        return pc.extend(t.prototype, {
            getPass: function(t, e) {
                if ((e = e || []).length = 0, !this._shader) return e;
                for (let i = 0; i < this._shader.passes.length; i++) {
                    const n = this._shader.passes[i];
                    n.lightMode === t && e.push(n)
                }
                return e
            },
            setPass: function(t) {
                if (!this._shader) return void console.log("Missing shader.");
                const e = this._shader.passes.length;
                if (t < 0 || t > e) return void console.log("Shader pass out of range setup attempt.");
                const i = this._shader.passes[t];
                UnityEngine.GL.SetPassMaterial = this["__UnityEngine.Material"], pc.Application.getApplication().renderer.setPass(this, i)
            },
            setParametersFromShaderDefaults: function() { if (!this.shader) return; const t = this.shader.defaultParameters; for (const e in t) this.setParameter(e, this.cloneParameterData(t[e])), t[e] instanceof pc.Texture && this.setParameter(e + "_ST", this.cloneParameterData([1, 1, 0, 0])) },
            setup: function() {
                for (let t = 0; t < this.floatParameters.length; t++) this.setParameter(this.floatParameters[t].name, this.floatParameters[t].value);
                for (let t = 0; t < this.colorParameters.length; t++) this.setParameter(this.colorParameters[t].name, this.colorParameters[t].value.data);
                for (let t = 0; t < this.vectorParameters.length; t++) this.setParameter(this.vectorParameters[t].name, this.vectorParameters[t].value.data);
                for (let t = 0; t < this.textureParameters.length; t++) {
                    const e = this.textureParameters[t].value;
                    this.setParameter(this.textureParameters[t].name, e ? e.handle : null)
                }
                const t = [];
                for (let e = 0; e < this.materialFlags.length; e++) {
                    const i = this.materialFlags[e];
                    i.enabled && t.push(i.name)
                }
                this.shaderKeywords = t
            },
            deleteParameter: function(t) {
                pc.Material.prototype.deleteParameter.call(this, t);
                const e = this._shader.defaultParameters[t];
                e && this.setParameter(t, e)
            },
            setParameter: function(t, e) {
                if (pc.Material.prototype.setParameter.call(this, t, e), null === e && this._shader) {
                    const e = this._shader.defaultParameters[t];
                    e && this.setParameter(t, e)
                } else e instanceof pc.Texture && !e.device.webgl2 && (e._pot || 0 !== e._addressU || 0 !== e._addressV || console.warn("Material's '" + this.name + "' texture '" + e.name + "' wrap mode is set to 'Repeat', but it's resolution NOT POWER OF TWO (NPOT)\nOnly textures with Power Of Two (POT) resolution can be used with WrapMode=Repeat"))
            },
            getParameter: function(t) { return pc.Material.prototype.getParameter.call(this, t) },
            clone: function() { const t = new pc.UnityMaterial; return t.name = this.name, t._shader = this._shader, t.copyPropertiesFromMaterial(this), t },
            hasProperty: function(t) { return this.parameters.hasOwnProperty(t) || this.shader.defaultParameterNames.hasOwnProperty(t) },
            copyPropertiesFromMaterial: function(t) { this.renderQueue = t.renderQueue, this.enableInstancing = t.enableInstancing, this.keywords.copy(t.keywords), this.$id = t.$id; for (const e in t.parameters) this.setParameter(e, this.cloneParameterData(t.parameters[e].data)) },
            cloneParameterData: function(t) { return t instanceof Float32Array || t instanceof Array ? new Float32Array(t) : t }
        }), Object.defineProperty(t.prototype, "shaderKeywords", { get: function() { return this.keywords.getEnabledKeywords() }, set: function(t) { this.keywords.setEnabledKeywords(t) } }), Object.defineProperty(t.prototype, "passCount", { get: function() { return this._shader.passes.length } }), Object.defineProperty(t.prototype, "shader", { get: function() { return this._shader }, set: function(t) { this._shader && this._shader._refCount--, this._shader = t, t && t._refCount++ } }), { UnityMaterial: t }
    }()), pc.extend(pc, function() { const t = function() { this.parameters = {}, this.parametersCount = 0 }; return pc.extend(t.prototype, { copyFromMeshInstance: function(t) { for (const e in t.parameters) this.setParameter(e, this.cloneParameterData(t.parameters[e].data)) }, applyToMeshInstance: function(t) { t.parameters = {}; for (const e in this.parameters) t.setParameter(e, this.cloneParameterData(this.parameters[e].data)) }, getParameter: function(t) { const e = this.parameters[t]; return e ? this.cloneAsPlainArray(e.data) : null }, setParameter: function(t, e) { this.parameters.hasOwnProperty(t) || this.parametersCount++, pc.Material.prototype.setParameter.call(this, t, this.cloneParameterData(e)) }, clear: function() { this.parameters = {}, this.parametersCount = 0 }, cloneParameterData: function(t) { return t instanceof Float32Array || t instanceof Array ? new Float32Array(t) : t }, cloneAsPlainArray: function(t) { return t instanceof Float32Array ? Array.prototype.slice.call(t) : t } }), Object.defineProperty(t.prototype, "isEmpty", { get: function() { return 0 === this.parametersCount } }), { UnityMaterialPropertyBlock: t } }()), Bridge.assembly("LunaUnity", ((t, e) => {
        const i = {};
        Bridge.define("LunaUnity.Objects.Bundle", {
            statics: { configure: function(t, e) { this.objectSpace = t.objectSpace, this.network = t.network, this.bundles = e, this.handlers = { game_object: new LunaUnity.Objects.Handlers.GameObject(t), audio_mixer: new LunaUnity.Objects.Handlers.AudioMixer(t), audio_mixer_snapshot: new LunaUnity.Objects.Handlers.AudioMixerSnapshot(t), project_settings: new LunaUnity.Objects.Handlers.ProjectSettings(t), material: new LunaUnity.Objects.Handlers.Material(t), physic_material: new LunaUnity.Objects.Handlers.PhysicMaterial(t), physics_material_2d: new LunaUnity.Objects.Handlers.PhysicsMaterial2D(t), mesh: new LunaUnity.Objects.Handlers.Mesh(t), scene: new LunaUnity.Objects.Handlers.Scene(t), shader: new LunaUnity.Objects.Handlers.Shader(t), video: new LunaUnity.Objects.Handlers.Video(t), sound: new LunaUnity.Objects.Handlers.Sound(t), sprite: new LunaUnity.Objects.Handlers.Sprite(t), texture: new LunaUnity.Objects.Handlers.Texture(t), cubemap: new LunaUnity.Objects.Handlers.Cubemap(t), animation_clip: new LunaUnity.Objects.Handlers.AnimationClip(t), blend_tree: new LunaUnity.Objects.Handlers.BlendTree(t), animator_controller: new LunaUnity.Objects.Handlers.AnimatorController(t), font: new LunaUnity.Objects.Handlers.Font(t), resources: new LunaUnity.Objects.Handlers.Resources(t), scriptable_object: new LunaUnity.Objects.Handlers.ScriptableObject(t), text_asset: new LunaUnity.Objects.Handlers.TextAsset(t), prefab_component: new LunaUnity.Objects.Handlers.PrefabComponent(t) } }, tickResource: function() { this._resources = this._resources || 0, this._resources++ }, loadAsync: function(t) { return this.new(t)._loadAsync() }, checkIsObjectAlreadyLoadedFromResources: function(t) { return !t.isPrefabProxy }, loadObject: function(t) { const e = new LunaUnity.Objects.Request; return LunaUnity.Objects.Bundle.handlers.game_object.loadAsync(e, t.prefab, [], !0).result }, loadByNameAsync: function(t) { const e = Object.keys(this.bundles); for (let i = 0; i < e.length; i++) { if (this.bundles[e[i]].name === t) return this.loadAsync(e[i]) } throw new System.FileNotFoundException }, releaseByNameAsync: function(t) { const e = Object.keys(this.bundles); for (let i = 0; i < e.length; i++) { const n = this.bundles[e[i]]; if (n.name === t) { const t = this._bundles[n.id]; return t && t._releaseBundleAndDependencies(), !0 } } return !1 }, new: function(t) { const e = this.bundles[t]; return this._bundles = this._bundles || {}, this._bundles[t] = this._bundles[t] || new LunaUnity.Objects.Bundle({ manifest: e, objectSpace: this.objectSpace, network: this.network }), this._bundles[t] } },
            ctor: function(t) { this.$initialize(), this.objectSpace = t.objectSpace, this.manifest = t.manifest, this.network = t.network, this.namesToId = i, this.refCount = 0 },
            _collectDependencies: function(t, e) { let i = []; if (!t[e]) { t[e] = !0, i.push(e); const n = LunaUnity.Objects.Bundle.bundles[e].dependencies; for (let e = 0; e < n.length; e++) i = i.concat(this._collectDependencies(t, n[e])) } return i },
            _retain: function() { this.refCount++ },
            _release: function() {
                if (this.refCount--, this.refCount > 0) return;
                LunaUnity.Objects.Bundle._bundles[this.manifest.id] = null, console.log("Bundle " + this.manifest.name + " got refcount reduced to 0 and is about to free resources");
                const t = [{ handler: "project_settings", json: "project-settings" }, { handler: "texture", json: "textures" }, { handler: "shader", json: "shaders" }, { handler: "mesh", json: "meshes" }, { handler: "video", json: "videos" }, { handler: "sound", json: "sounds" }, { handler: "animation_clip", json: "animation-clips" }, { handler: "blend_tree", json: "blend-trees" }, { handler: "text_asset", json: "text-assets" }, { handler: "audio_mixer", json: "audio-mixers" }, { handler: "physic_material", json: "physic-materials" }, { handler: "physics_material_2d", json: "physics-materials-2d" }, { handler: "audio_mixer_snapshot", json: "audio-mixer-snapshots" }, { handler: "cubemap", json: "cubemaps" }, { handler: "material", json: "materials" }, { handler: "sprite", json: "sprites" }, { handler: "font", json: "fonts" }, { handler: "animator_controller", json: "animator-controllers" }, { handler: "resources", json: "resources" }, { handler: "scene", json: "scenes" }, { handler: "scriptable_object", json: "scriptable-objects" }, { handler: "game_object", json: "prefabs" }],
                    e = this.json["scriptable-objects"];
                if (e)
                    for (let t = 0; t < e.length; t++) {
                        const i = this.objectSpace.registry.Get(e[t].id);
                        i.CallOnDisable(), i.CallOnDestroy()
                    }
                for (let e = 0; e < t.length; e++) {
                    const i = LunaUnity.Objects.Bundle.handlers[t[e].handler],
                        n = this.json[t[e].json];
                    if (n)
                        for (let t = 0; t < n.length; t++) i.unloadAsync(n[t])
                }
                this.json = null
            },
            _retainBundleAndDependencies: function() { const t = this._collectDependencies({}, this.manifest.id); for (let e = 0; e < t.length; e++) { LunaUnity.Objects.Bundle.new(t[e])._retain() } },
            _releaseBundleAndDependencies: function() { const t = this._collectDependencies({}, this.manifest.id); for (let e = 0; e < t.length; e++) { LunaUnity.Objects.Bundle.new(t[e])._release() } },
            _loadAsync: function() {
                if (this._retainBundleAndDependencies(), this.loadCompletionSource) return this.loadCompletionSource.task;
                this.loadCompletionSource = new System.Threading.Tasks.TaskCompletionSource, this.loadCompletionSource.task.setSynchronous(!0);
                const t = this._collectDependencies({}, this.manifest.id),
                    e = [],
                    i = [],
                    n = new LunaUnity.Objects.Request;
                for (let n = 0; n < t.length; n++) {
                    const s = LunaUnity.Objects.Bundle.new(t[n]);
                    i.push(s), e.push(s._downloadBundleDataAsync(), s._downloadBlobDataAsync())
                }
                return System.Threading.Tasks.Task.whenAll(e).continueWith(Bridge.fn.bind(this, (function(t) {
                    FBInstantManager.getInstance().UpdateLoading(20);
                    console.info("%cBundle chain loaded successfully", "background-color: black; color: white; padding: 1em;"), this._loadSimpleAssetsAsync(n, i).continueWith(Bridge.fn.bind(this, (function(t) {
                        FBInstantManager.getInstance().UpdateLoading(40);
                        console.info("%cSimple assets loaded successfully", "background-color: black; color: white; padding: 1em;"), this._loadComplexAssetsAsync(n, i).continueWith(Bridge.fn.bind(this, (function(t) {
                            FBInstantManager.getInstance().UpdateLoading(60);
                            console.info("%cComplex assets loaded successfully", "background-color: black; color: white; padding: 1em;"), n.resolveReferences(this.objectSpace.registry), this._loadPrefabsAsync(n, i).continueWith(Bridge.fn.bind(this, (function(t) {
                                FBInstantManager.getInstance().UpdateLoading(80);
                                console.info("%cPrefabs loaded successfully", "background-color: black; color: white; padding: 1em;"), n.resolveReferences(this.objectSpace.registry), this._loadScenesAsync(n, i).continueWith(Bridge.fn.bind(this, (function(t) {
                                    FBInstantManager.getInstance().UpdateLoading(100);
                                    console.info("%cScenes loaded successfully", "background-color: black; color: white; padding: 1em;"), n.resolveReferences(this.objectSpace.registry), this.loadCompletionSource.setResult(this)
                                })))
                            })))
                        })))
                    })))
                }))), this.loadCompletionSource.task
            },
            _downloadBlobDataAsync: function() { return this.downloadBlobCompletionSource || (this.downloadBlobCompletionSource = new System.Threading.Tasks.TaskCompletionSource, this.network.GetBlobAsync("assets/bundles/" + this.manifest.id + "/data.blob").continueWith(Bridge.fn.bind(this, (function(t) { this.blob = t.result, this.downloadBlobCompletionSource.setResult(this), LunaUnity.Objects.Bundle.tickResource() })))), this.downloadBlobCompletionSource.task },
            _downloadBundleDataAsync: function(t) { return this.downloadCompletionSource || (this.downloadCompletionSource = new System.Threading.Tasks.TaskCompletionSource, this.network.GetJsonAsync("assets/bundles/" + this.manifest.id + "/bundle.json").continueWith(Bridge.fn.bind(this, (function(t) { this.json = t.result, this.downloadCompletionSource.setResult(this), LunaUnity.Objects.Bundle.tickResource() })))), this.downloadCompletionSource.task },
            _loadSimpleAssetsAsync: function(t, e) { return this._loadAssetsFromBundlesAsync(t, e, [{ handler: "project_settings", json: "project-settings" }, { handler: "texture", json: "textures" }, { handler: "shader", json: "shaders" }, { handler: "mesh", json: "meshes" }, { handler: "video", json: "videos" }, { handler: "sound", json: "sounds" }, { handler: "animation_clip", json: "animation-clips" }, { handler: "blend_tree", json: "blend-trees" }, { handler: "text_asset", json: "text-assets" }, { handler: "audio_mixer", json: "audio-mixers" }, { handler: "physic_material", json: "physic-materials" }, { handler: "physics_material_2d", json: "physics-materials-2d" }, { handler: "audio_mixer_snapshot", json: "audio-mixer-snapshots" }]) },
            _loadComplexAssetsAsync: function(t, e) { return this._loadAssetsFromBundlesAsync(t, e, [{ handler: "cubemap", json: "cubemaps" }, { handler: "material", json: "materials" }, { handler: "sprite", json: "sprites" }, { handler: "font", json: "fonts" }, { handler: "animator_controller", json: "animator-controllers" }]) },
            _loadPrefabsAsync: function(t, e) {
                let i = [],
                    n = [];
                const s = {};
                for (let t = 0; t < e.length; t++) {
                    const r = e[t];
                    s[r.manifest.id] = r, r._guardAssetType("prefabs", (() => { i = i.concat(r.json.prefabs || []) })), r._guardAssetType("scriptable-objects", (() => { n = n.concat(r.json["scriptable-objects"] || []) }))
                }
                const r = LunaUnity.Objects.Bundle.handlers.game_object,
                    o = LunaUnity.Objects.Bundle.handlers.scriptable_object,
                    a = LunaUnity.Objects.Bundle.handlers.project_settings,
                    c = LunaUnity.Application.Instance.app.systems.list;
                for (let t = 0; t < c.length; t++) { c[t].creatingPrefabs = !0 }
                for (let n = 0; n < i.length; n++) r.loadAsync(t, i[n], e, a.autoInstantiatePrefabs).result;
                for (let t = 0; t < c.length; t++) { c[t].creatingPrefabs = !1 }
                const h = [];
                for (let e = 0; e < n.length; e++) {
                    const i = o.loadAsync(t, n[e]).result;
                    h.push(i)
                }
                for (let t = 0; t < h.length; t++) {
                    const e = h[t];
                    e.CallAwake && e.CallAwake(), e.CallOnEnable && e.CallOnEnable()
                }
                return System.Threading.Tasks.Task.fromResult(!0)
            },
            _loadScenesAsync: function(t, e) { return this._loadAssetsFromBundlesAsync(t, e, [{ handler: "resources", json: "resources" }, { handler: "scene", json: "scenes" }], !0) },
            _loadAssetsFromBundlesAsync: function(t, e, i, n) {
                const s = [],
                    r = {};
                for (let n = 0; n < i.length; n++) {
                    const o = i[n].handler,
                        a = i[n].json,
                        c = LunaUnity.Objects.Bundle.handlers[o];
                    let h = [];
                    for (let t = 0; t < e.length; t++) {
                        const i = e[t];
                        r[i.manifest.id] = i, i._guardAssetType(a, (() => { h = h.concat(i.json[a] || []) }))
                    }
                    for (let i = 0; i < h.length; i++) {
                        let n = h[i];
                        window.playgroundBundlesOverrides && (n = window.playgroundBundlesOverrides[n.id] || n);
                        const a = c.loadAsync(t, n, e);
                        "texture" !== o && "sound" !== o && "video" !== o || (s.push(a), a.continueWith((() => { LunaUnity.Objects.Bundle.tickResource() }))), r[n.assetBundleId].namesToId[(n.name || "").toLowerCase()] = h[i].id || n.$id
                    }
                }
                return System.Threading.Tasks.Task.whenAll(s)
            },
            _remove: function() { console.warn("Requested removal of asset bundle id = " + this.manifest.id + " - this is no-op for now") },
            _guardAssetType: function(t, e) { this._guardAssetTypes = this._guardAssetTypes || {}, this._guardAssetTypes[t] || e(), this._guardAssetTypes[t] = !0 }
        })
    })), pc.extend(pc, function() {
        const t = new Uint8Array([0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1]),
            e = new pc.Vec3(1, 1, -1),
            i = new pc.Vec3(1, -1, -1);
        let n = null,
            s = null;
        const r = function(t) { this.app = t, this.indirectSpecular = new pc.Color(.4465786, .4964123, .5748172, 1), this.meshInstances = [] };
        return pc.extend(r.prototype, {
            install: function(e) {
                const i = new pc.GraphNode;
                i.cullingLayer = -1;
                const n = new pc.SkyboxLoader,
                    s = new pc.MeshInstance(i, n.loadSkyboxMesh(), new pc.Material);
                s.cull = !1, s._shaderDefs = pc.SHADERDEF_RENDERTYPE_BACKGROUND;
                (new pc.Model).meshInstances = [s], i._sync(), this.meshInstance = s, this.meshInstances.push(s), this.matrix_projection = new pc.Mat4, this.matrix_view = new pc.Mat4, this.matrix_viewProjection = new pc.Mat4, this.sunPosition = new pc.Vec3, this.blackCube = new pc.Texture(UnityEngine.Graphics.graphicsDevice, { cubemap: !0, rgbm: !1, width: 2, height: 2 }), this.blackCube._levels[0] = [t, t, t, t, t, t], this.environmentCubemap = this.blackCube, e.addRenderer(this)
            },
            getMeshInstancesForRender: function() { return this.meshInstances },
            setSkyboxEnabled: function(t) { this.meshInstance.cull = !t },
            update: function() {
                const t = UnityEngine.RenderSettings._skybox;
                if (!t || !t.handle) return this.indirectSpecular.set(0, 0, 0, 1), void(this.meshInstance.visible = !1);
                this.meshInstance.material = t.handle, this.meshInstance.visible = !0, this.app.systems.reflectionprobe.scheduleProbeUpdate(), this.app.scene.root && this.app.scene.root.syncHierarchy()
            },
            updateSkyDrawCall: function(t, n) {
                this.matrix_view.setTRS(pc.Vec3.ZERO, t._node.getRotation(), n ? i : e).invert(), t._projection === pc.PROJECTION_PERSPECTIVE ? this.matrix_projection.setPerspective(t._fov, t._aspect, .01, 1, t._horizontalFov) : this.matrix_projection.setPerspective(90, t._aspect, .01, 1, t._horizontalFov), this.matrix_viewProjection.mul2(this.matrix_projection, this.matrix_view), this.meshInstance.setParameter(this.app.renderer.unityIds.viewProjId.name, this.matrix_viewProjection.data);
                let s = UnityEngine.RenderSettings.sun;
                if (s) s = s.handle;
                else {
                    const t = this.app.systems.light.store,
                        e = Object.keys(t);
                    for (let i = 0; i < e.length; i++) { const n = t[e[i]]; if (n.data.enabled && n.entity.enabled && "directional" === n.data.type) { s = n.data.light; break } }
                }
                const r = s ? s._node ? s._node : s.entity : null;
                s && r && r.enabled ? (this.meshInstance.setParameter("_LightColor0", s._color.data), this.sunPosition.set(0, 0, -1), r.transformDirection(this.sunPosition, this.sunPosition), this.meshInstance.setParameter("_WorldSpaceLightPos0", [this.sunPosition.x, this.sunPosition.y, this.sunPosition.z, 0])) : (this.meshInstance.setParameter("_LightColor0", [0, 0, 0, 0]), this.meshInstance.setParameter("_WorldSpaceLightPos0", [0, 0, 0, 0]))
            },
            getSkyDrawCall: function(t) { return this.meshInstance },
            bakeEnvironmentReflections: function() {
                const t = UnityEngine.RenderSettings._defaultReflectionResolution || 128;
                switch (UnityEngine.RenderSettings.defaultReflectionMode) {
                    case UnityEngine.Rendering.DefaultReflectionMode.Skybox:
                        this.environmentCubemap = this.bakeToCubemap(t, this._environmentCubemap);
                        break;
                    case UnityEngine.Rendering.DefaultReflectionMode.Custom:
                        { const t = UnityEngine.RenderSettings.customReflection;this.environmentCubemap = (t ? t.handle : null) || this.blackCube; break }
                }
                this.updateReflectionIntensity(), this.computeIndirectSpecular(), UnityEngine.RenderSettings._defaultReflectionMode === UnityEngine.Rendering.DefaultReflectionMode.Skybox && (UnityEngine.LightmapSettings.reflectionProbes.environmentProbe.cubemap = this.environmentCubemap)
            },
            updateReflectionIntensity: function() { this.environmentCubemap.intensity = UnityEngine.RenderSettings._reflectionIntensity },
            computeIndirectSpecular: function() {
                if (!this.environmentCubemap || this.environmentCubemap === this.blackCube) return;
                this.indirectSpecular.set(0, 0, 0, 1);
                const t = this.app.graphicsDevice,
                    e = Math.log(this.environmentCubemap.width) / Math.log(2) | 0,
                    i = t.activeFramebuffer;
                if (!n) {
                    const e = new pc.Texture(t, { mipmaps: !1, width: 1, height: 1, format: pc.PIXELFORMAT_R8_G8_B8_A8 });
                    n = new pc.RenderTarget(t, e, { depth: !1 })
                }
                s || (s = pc.shaderChunks.createShaderFromCode(t, pc.shaderChunks.convolveLastMipOfCubemapVS, pc.shaderChunks.convolveLastMipOfCubemapPS, "convolveLastMipOfCubemap")), t.scope.resolve("_Cubemap_").setValue(this.environmentCubemap), t.scope.resolve("_Level_").setValue(e), pc.drawQuadWithShader(t, n, s);
                const r = n._colorBuffer.toBuffer();
                this.indirectSpecular.set(r[0], r[1], r[2], 255).scale(1 / 255), t.setFramebuffer(i)
            },
            bakeEnvironmentLighting: function() { UnityEngine.RenderSettings.ambientMode === UnityEngine.Rendering.AmbientMode.Skybox && (this.update(), this.meshInstance.visible ? (this.lightingCubemap = this.bakeToCubemap(8, null), this.lightingCubemap.sync(0)) : this.lightingCubemap = null) },
            bakeToCubemap: function(t, e) {
                const i = this.app.graphicsDevice,
                    n = new pc.Entity,
                    s = n.addComponent("camera", { projection: pc.PROJECTION_ORTHOGRAPHIC, aspectRatio: 1, orthoHeight: 1 });
                if ((e = e || new pc.Texture(i, { cubemap: !0, rgbm: !1 }))._width = e._height = t, !this.meshInstance.visible) return e;
                const r = [
                    [0, 90, 0],
                    [0, -90, 0],
                    [-90, 0, 0],
                    [90, 0, 0],
                    [0, 0, 0],
                    [0, 180, 0]
                ];
                for (let t = 0; t < 6; t++) n.setLocalEulerAngles.apply(n, r[t]), n._sync(), this.updateSkyDrawCall(s.camera, !0), s.renderTarget = new pc.RenderTarget({ colorBuffer: e, face: t, depth: !1 }), this.app.renderer.setCamera(s.camera, s.renderTarget, !0), this.app.renderer.renderMeshInstance(new pc.KeywordSet, null, s.camera, this.meshInstance, [
                    [],
                    [],
                    []
                ]);
                return i.gl.generateMipmap(e._glTarget), e.markUploaded(), e
            }
        }), { Skybox: r }
    }()), pc.extend(pc, function() {
        const t = new pc.Vec3,
            e = new pc.Vec3,
            i = new pc.Vec4,
            n = function() {},
            s = "zDHiP9sPyT/bD8k/f6ziP9sPyT/bD8k/2w/JP3+s4j/MMeI/f6ziP7VT+z/MMeI/L/7jP9sPyT/bD8k/+FDkP9sPyT/bD8k/2w/JP/hQ5D8v/uM/+FDkP+zj/j8v/uM/L/7jP+zj/j/DYf4/f6ziP8Nh/j+1U/s/w2H+P3+s4j8v/uM/f6ziP9sPyT8v/uM/6esLQOTLFkDlOgpAw2H+P+U6CkC1U/s/5ToKQMNh/j/p6wtAw2H+P+zj/j/p6wtA+FDkP9sPyT/bD8k/L/7jP9sPyT/bD8k/2w/JPy/+4z/4UOQ/L/7jP+zj/j/4UOQ/ruzVP9sPyT/bD8k/2w/JP67s1T/bD8k/f6ziP67s1T/bD8k/8mHPP9sPyT/bD8k/2w/JP/Jhzz/bD8k/bLDVP/Jhzz/bD8k/2w/JP9sPyT/xYc8/2w/JP/Fhzz9ssNU/2w/JP9sPyT/xYc8/7PbbP2yw1T/xYc8/zDHiP/Fhzz/bD8k/zDHiP+z22z/xYc8/7PbbP8wx4j9IaeI/D5DiP+z22z9IaeI/bLDVP+z22z8PkOI/fqbiP3+s4j/jNNw/D5DiP+M03D9ssNU/D5DiP36m4j/jNNw/8mHPP2yw1T/jNNw/2w/JP+M03D9/rOI/2w/JP/Jhzz/jNNw/u/foP3+s4j9+puI/D5DiP7v36D9+puI/9C/vP7v36D8PkOI/SGniP8wx4j+Lu+g/D5DiP4u76D/0L+8/D5DiP0hp4j+Lu+g/P1D1P/Qv7z+Lu+g/tVP7P4u76D/MMeI/tVP7Pz9Q9T+Lu+g/P1D1P7VT+z8PUvw/rSn9Pz9Q9T8PUvw/9C/vPz9Q9T+tKf0/t9n9P8Nh/j/S3fY/rSn9P9Ld9j/0L+8/rSn9P7fZ/T/S3fY/u/foP/Qv7z/S3fY/f6ziP9Ld9j/DYf4/f6ziP7v36D/S3fY/E17xP8Nh/j/29f4/7OP+PxNe8T/29f4/L/7jPxNe8T/s4/4/E17xPy/+4z/nfeM/f6ziPxNe8T/nfeM/w2H+PxNe8T9/rOI/ruzVP3+s4j/nfeM/L/7jP67s1T/nfeM/2w/JP67s1T8v/uM//NQOQOnrC0BgsQtATFULQPzUDkBgsQtAB6ERQPzUDkBMVQtAHdgKQOU6CkBKAQ5ATFULQEoBDkAHoRFATFULQB3YCkBKAQ5AjEoUQAehEUBKAQ5A5MsWQEoBDkDlOgpA5MsWQIxKFEBKAQ5A1dIFQOzj/j/29f4/w2H+P9XSBUD29f4/6esLQNXSBUDDYf4/p5wHQOU6CkAd2ApATFULQKecB0Ad2ApA2eMEQKecB0BMVQtAYLELQOnrC0BGeghATFULQEZ6CEDZ4wRATFULQGCxC0BGeghAORQCQNnjBEBGeghAw2H+P0Z6CEDp6wtAw2H+PzkUAkBGeghAORQCQMNh/j+32f0/rSn9PzkUAkC32f0/2eMEQDkUAkCtKf0/D1L8P7VT+z+iUgFArSn9P6JSAUDZ4wRArSn9Pw9S/D+iUgFAp5wHQNnjBECiUgFA5ToKQKJSAUC1U/s/5ToKQKecB0CiUgFAjEoUQOTLFkBiHhlAjzobQIxKFEBiHhlAB6ERQIxKFECPOhtAfhgdQFevHkAOVRhAjzobQA5VGEAHoRFAjzobQH4YHUAOVRhA/NQOQAehEUAOVRhA6esLQA5VGEBXrx5A6esLQPzUDkAOVRhAngkYQFevHkBG5yBA1qshQJ4JGEBG5yBAG/IQQJ4JGEDWqyFAngkYQBvyEEDb2A5A6esLQJ4JGEDb2A5AV68eQJ4JGEDp6wtA1dIFQOnrC0Db2A5A7OP+P9vYDkAb8hBA7OP+P9XSBUDb2A5AG/IQQNarIUBXrx5A6esLQFevHkDkyxZAV68eQOnrC0Ab8hBA6esLQOzj/j8b8hBAG/IQQOzj/j9BuQBAG/IQQEG5AEDs4/4/QbkAQBvyEEAb8hBAG/IQQNarIUAb8hBA+FDkP9sPyT/4UOQ/QbkAQPhQ5D/s4/4/+FDkP0G5AED4UOQ/QbkAQOzj/j/4UOQ/IKM/QOJ+PEDBFj9ATsdCQMEWP0BYHkBATsdCQCCjP0DBFj9AOpdEQFgeQEDBFj9A4n48QDqXREDBFj9A2w9JQDqXREDifjxAOpdEQNsPSUCS60VATsdCQDqXRECS60VAWB5AQDqXREBOx0JAcDY2QO3tL0BE4TRA4n48QEThNECT0zZA4n48QHA2NkBE4TRAkfo7QOJ+PEDBFj9AV8E6QMEWP0BYHkBAV8E6QJH6O0DBFj9AIXk7QFgeQEDBFj9A4n48QCF5O0DBFj9Ak9M2QCF5O0DifjxAIXk7QJPTNkAc/DhAV8E6QCF5O0Ac/DhAWB5AQCF5O0BXwTpAHPw4QJPTNkA3UjZAV8E6QDdSNkBE4TRAV8E6QBz8OEA3UjZAmuM4QEThNEACrzJA7e0vQJrjOEACrzJA4n48QJrjOEDt7S9AmuM4QOJ+PECR+jtAV8E6QJrjOECR+jtAROE0QJrjOEBXwTpAQM4qQO3tL0DjXCNAV68eQONcI0DkyxZA41wjQFevHkBAzipAV68eQNarIUBAzipAc5ImQEDOKkDkCyxA1qshQOQLLEBAzipA1qshQHOSJkDkCyxA5i8vQO3tL0ACrzJA1w0uQAKvMkBE4TRA1w0uQOYvL0ACrzJA/eYvQEThNEA3UjZAk9M2QP3mL0A3UjZAQM4qQP3mL0CT0zZA/eYvQEDOKkCykyxA1w0uQP3mL0CykyxAROE0QP3mL0DXDS5ARBAxQEDOKkDkCyxAk9M2QOQLLEBAzipAk9M2QEQQMUDkCyxARBAxQJPTNkBE4TRAQM4qQEThNEDt7S9AQM4qQEQQMUBE4TRAvDEgQFevHkB+GB1AtH0hQH4YHUCPOhtAtH0hQLwxIEB+GB1A4mUfQI86G0BiHhlA5MsWQOJlH0BiHhlA41wjQOJlH0DkyxZA4mUfQONcI0DijSJAtH0hQOJlH0DijSJAjzobQOJlH0C0fSFAspMsQEDOKkCMkSlA1w0uQIyRKUAT3ydA1w0uQLKTLECMkSlA5wosQBPfJ0DhxyVA41wjQOcKLEDhxyVA7e0vQOcKLEDjXCNA5wosQO3tL0DmLy9A1w0uQOcKLEDmLy9AE98nQOcKLEDXDS5A4o0iQONcI0DhxyVAtH0hQOHHJUAT3ydAtH0hQOKNIkDhxyVAqFgjQBPfJ0CMkSlAQM4qQKhYI0CMkSlAV68eQKhYI0BAzipAqFgjQFevHkC8MSBAtH0hQKhYI0C8MSBAE98nQKhYI0C0fSFAc5ImQNarIUBG5yBAQM4qQEbnIEBXrx5AQM4qQHOSJkBG5yBA",
            r = "2w/JP9sPyT/MMeI/2DPjP8wx4j+1U/s/zDHiP9gz4z/bD8k/2DPjP9sPyT/bD8k/bKn/P7VT+z/lOgpAKfkMQOU6CkDkyxZA5ToKQCn5DEBsqf8/KfkMQFQ0AkBsqf8/bKn/P1Q0AkADjuY/2DPjPwOO5j/bD8k/A47mP9gz4z9sqf8/2DPjP7VT+z9sqf8/QpLqP9sPyT/bD8k/A47mP9sPyT/bD8k/2w/JPwOO5j9Ckuo/A47mP1Q0AkBCkuo/n54gQOTLFkDjXCNAEsMtQONcI0Dt7S9A41wjQBLDLUCfniBAEsMtQHRjK0CfniBATOY1QO3tL0BwNjZA4n48QEzmNUBwNjZA3P07QEzmNUDifjxAWJk/QOJ+PEAgoz9ATsdCQFiZP0Agoz9AprdCQFiZP0BOx0JAkutFQNsPSUDT5UVATsdCQNPlRUCmt0JATsdCQJLrRUDT5UVA5t1FQKa3QkDT5UVA2w9JQNPlRUDbD0lA2w9JQObdRUDT5UVA5t1FQNsPSUD2y0VAgIdCQObdRUD2y0VAprdCQObdRUCAh0JAs0I/QNz9O0B2YT9AgIdCQHZhP0Cmt0JAgIdCQLNCP0B2YT9AWJk/QKa3QkB2YT9A4n48QHZhP0Dc/TtA4n48QFiZP0B2YT9AhB8/QNz9O0CzQj9AgIdCQIQfP0CzQj9AVlVCQIQfP0CAh0JA9stFQNsPSUCkvUVAgIdCQKS9RUBWVUJAgIdCQPbLRUCkvUVA2KNFQFZVQkCkvUVA2w9JQKS9RUDbD0lA2w9JQNijRUCkvUVA2KNFQNsPSUDcZ0VAAbpBQNijRUDcZ0VAVlVCQNijRUABukFAVwc+QMZQOkDuaT5AAbpBQO5pPkBWVUJAAbpBQFcHPkDuaT5AhB8/QFZVQkDuaT5A3P07QO5pPkDGUDpA3P07QIQfP0DuaT5AAdQzQMZQOkDC2zJAdGMrQAHUM0DC2zJAEsMtQAHUM0B0YytAAdQzQBLDLUBu4jRA3P07QAHUM0Bu4jRAxlA6QAHUM0Dc/TtATOY1QNz9O0Bu4jRAEsMtQEzmNUBu4jRA7e0vQEzmNUASwy1A+A48QKdOOEAwjDxAwsJAQPgOPEAwjDxAaRRAQPgOPEDCwkBAnO9EQNsPSUBtxERAwsJAQG3EREBpFEBAwsJAQJzvREBtxERANmdEQGkUQEBtxERA2w9JQG3EREDbD0lA2w9JQDZnREBtxERAhHwxQHRjK0DC2zJAxlA6QIR8MUDC2zJAp044QIR8MUDGUDpA1BlFQNsPSUCc70RAwsJAQNQZRUCc70RAJFZBQNQZRUDCwkBAMIw8QKdOOEBP+jxAwsJAQE/6PEAkVkFAwsJAQDCMPEBP+jxApb89QCRWQUBP+jxAxlA6QE/6PECnTjhAxlA6QKW/PUBP+jxApb89QMZQOkBXBz5AAbpBQKW/PUBXBz5AJFZBQKW/PUABukFA3GdFQNsPSUDqTUVAAbpBQOpNRUAkVkFAAbpBQNxnRUDqTUVA1BlFQCRWQUDqTUVA2w9JQOpNRUDbD0lA2w9JQNQZRUDqTUVANmdEQNsPSUDGCURAUaA+QDZnREDGCURAaRRAQDZnREBRoD5AMtA4QCqbMkCGEDpAUaA+QIYQOkBpFEBAUaA+QDLQOECGEDpA+A48QGkUQECGEDpAp044QIYQOkAqmzJAp044QPgOPECGEDpAbysqQCqbMkAUJSVA5MsWQG8rKkAUJSVABW4jQG8rKkDkyxZAbysqQAVuI0CHLy5Ap044QG8rKkCHLy5AKpsyQG8rKkCnTjhAhHwxQKdOOECHLy5AdGMrQIcvLkAFbiNAdGMrQIR8MUCHLy5AwykKQOTLFkA7+fU/QpLqPzv59T/bD8k/O/n1P0KS6j/DKQpAQpLqP1Q0AkDDKQpAwykKQFQ0AkDkyxZABW4jQOTLFkB0YytA5MsWQAVuI0DDKQpABW4jQOTLFkDDKQpAKfkMQOTLFkCfniBA5MsWQJ+eIEB0YytAn54gQOTLFkAp+QxA5MsWQFQ0AkAp+QxA2w/JP9sPyT+9ffI/2w/JP7198j/kyxZA2w/JP9sPyT+9ffI/5MsWQOTLFkDqWDRA2w9JQOTLFkDqWDRAAAAAAOTLFkDbD0lA5MsWQAAAAADbD8k/2w/JP+TLFkDbD8k/5MsWQOTLFkDbD8k/2w/JP9sPyT86OfM/2w/JPzo58z/kyxZA2w/JP9sPyT86OfM/giI5QNsPSUDqWDRATiYrQOpYNEDkyxZATiYrQIIiOUDqWDRA5MsWQOTLFkC9ffI/2w/JP+TLFkC9ffI/5MsWQOTLFkDbD8k/5MsWQOTLFkBpwh9ATiYrQOTLFkBpwh9A5MsWQOTLFkBOJitAacIfQOTLFkBQHiZATiYrQFAeJkAr+zNATiYrQGnCH0BQHiZArRk8QCv7M0B6oj9A2w9JQK0ZPEB6oj9A2w9JQK0ZPEDbD0lArRk8QNsPSUCCIjlATiYrQK0ZPECCIjlAK/szQK0ZPEBOJitA0AYDQNsPyT/bD8k/O/n1P9sPyT/bD8k/2w/JPzv59T/QBgNAO/n1P+TLFkDQBgNABYEfQPiQKkDkyxZA5MsWQOTLFkDQBgNA5MsWQAWBH0DkyxZATntAQNsPSUB6oj9Abnc4QHqiP0Ar+zNAbnc4QE57QEB6oj9ANWEuQCv7M0BQHiZA5MsWQDVhLkBQHiZA+JAqQDVhLkDkyxZANWEuQPiQKkCTJTFAbnc4QDVhLkCTJTFAK/szQDVhLkBudzhAA44KQNAGA0DkyxZA5MsWQOTLFkD4kCpA5MsWQAOOCkDkyxZAA44KQOTLFkA6OfM/0AYDQDo58z/bD8k/0AYDQAOOCkA6OfM/icY3QCqbMkAy0DhAbUI9QDLQOEBRoD5AbUI9QInGN0Ay0DhAkmhDQFGgPkDGCURA2w9JQJJoQ0DGCURA2w9JQJJoQ0DbD0lAkmhDQNsPSUAXCUNAbUI9QJJoQ0AXCUNAUaA+QJJoQ0BtQj1AkyUxQPiQKkC6UTNAbnc4QLpRM0DKWjtAbnc4QJMlMUC6UTNAslJBQMpaO0C4mUJA2w9JQLJSQUC4mUJA2w9JQLJSQUDbD0lAslJBQNsPSUBOe0BAbnc4QLJSQUBOe0BAylo7QLJSQUBudzhAFwlDQNsPSUC4mUJAbUI9QLiZQkDKWjtAbUI9QBcJQ0C4mUJAmoI2QMpaO0C6UTNA+JAqQJqCNkC6UTNAKpsyQJqCNkD4kCpAmoI2QCqbMkCJxjdAbUI9QJqCNkCJxjdAylo7QJqCNkBtQj1ABYEfQOTLFkAUJSVA+JAqQBQlJUAqmzJA+JAqQAWBH0AUJSVA";

        function o(t, e, i) {
            i = i || new pc.Vec3;
            const n = Math.sin(t),
                s = Math.cos(t),
                r = Math.sin(e),
                o = Math.cos(e);
            return i.x = n * o, i.y = n * r, i.z = s, i
        }

        function a(t) {
            const e = window.atob(t),
                i = e.length / Float32Array.BYTES_PER_ELEMENT,
                n = new DataView(new ArrayBuffer(Float32Array.BYTES_PER_ELEMENT)),
                s = new Float32Array(i);
            let r = 0;
            for (let t = 0; t < i; t++) r = 4 * t, n.setUint8(0, e.charCodeAt(r)), n.setUint8(1, e.charCodeAt(r + 1)), n.setUint8(2, e.charCodeAt(r + 2)), n.setUint8(3, e.charCodeAt(r + 3)), s[t] = n.getFloat32(0, !0);
            return s
        }

        function c(t, i, n, s) { return s = s || new pc.Vec4, e.x = t, e.y = i, e.z = n, s.x = e.dot(pc.Vec3.RIGHT), s.y = e.dot(pc.Vec3.UP), s.z = e.dot(pc.Vec3.BACK), s.w = 1, s }
        return Object.assign(n.prototype, {
            loadSkyboxMesh: function() {
                const e = new pc.Mesh,
                    n = a(s),
                    h = a(r),
                    l = n.length,
                    u = 8 * l * 3,
                    d = 3 * l,
                    p = 4 * l,
                    _ = pc.Application.getApplication().graphicsDevice,
                    f = new Float32Array(u),
                    m = new Float32Array(4 * l * 8),
                    y = function(t, e) {
                        const i = new Uint16Array(t * e);
                        for (let n = 0; n < e; n++)
                            for (let e = 0; e < t; e++) {
                                const s = e + t * n;
                                n % 2 == 0 ? i[s] = s : (i[s] = s + 2, i[s + 2] = s, i[s + 1] = s + 1, e += 2)
                            }
                        return i
                    }(630, 8);
                for (let e = 0; e < l; e++) {
                    o(n[e], h[e], t), t.y = pc.math.clamp(t.y, 0, 1);
                    const s = 3 * e,
                        r = 4 * e;
                    f[s] = t.x, f[s + 1] = t.y, f[s + 2] = t.z, c(t.x, t.y, t.z, i), m[r] = i.x, m[r + 1] = i.y, m[r + 2] = i.z, m[r + 3] = i.w, f[s + d] = -t.x, f[s + d + 1] = t.y, f[s + d + 2] = t.z, c(-t.x, t.y, t.z, i), m[r + p] = i.x, m[r + p + 1] = i.y, m[r + p + 2] = i.z, m[r + p + 3] = i.w, f[s + 2 * d] = -t.x, f[s + 2 * d + 1] = t.y, f[s + 2 * d + 2] = -t.z, c(-t.x, t.y, -t.z, i), m[r + 2 * p] = i.x, m[r + 2 * p + 1] = i.y, m[r + 2 * p + 2] = i.z, m[r + 2 * p + 3] = i.w, f[s + 3 * d] = t.x, f[s + 3 * d + 1] = t.y, f[s + 3 * d + 2] = -t.z, c(t.x, t.y, -t.z, i), m[r + 3 * p] = i.x, m[r + 3 * p + 1] = i.y, m[r + 3 * p + 2] = i.z, m[r + 3 * p + 3] = i.w, f[s + 4 * d] = -t.x, f[s + 4 * d + 1] = -t.y, f[s + 4 * d + 2] = t.z, c(-t.x, -t.y, t.z, i), m[r + 4 * p] = i.x, m[r + 4 * p + 1] = i.y, m[r + 4 * p + 2] = i.z, m[r + 4 * p + 3] = i.w, f[s + 5 * d] = -t.x, f[s + 5 * d + 1] = -t.y, f[s + 5 * d + 2] = -t.z, c(-t.x, -t.y, -t.z, i), m[r + 5 * p] = i.x, m[r + 5 * p + 1] = i.y, m[r + 5 * p + 2] = i.z, m[r + 5 * p + 3] = i.w, f[s + 6 * d] = t.x, f[s + 6 * d + 1] = -t.y, f[s + 6 * d + 2] = -t.z, c(t.x, -t.y, -t.z, i), m[r + 6 * p] = i.x, m[r + 6 * p + 1] = i.y, m[r + 6 * p + 2] = i.z, m[r + 6 * p + 3] = i.w, f[s + 7 * d] = t.x, f[s + 7 * d + 1] = -t.y, f[s + 7 * d + 2] = t.z, c(t.x, -t.y, t.z, i), m[r + 7 * p] = i.x, m[r + 7 * p + 1] = i.y, m[r + 7 * p + 2] = i.z, m[r + 7 * p + 3] = i.w
                }
                const g = [{ semantic: pc.SEMANTIC_POSITION, components: 3, type: pc.TYPE_FLOAT32 }, { semantic: pc.SEMANTIC_TEXCOORD0, components: 4, type: pc.TYPE_FLOAT32 }],
                    E = f.length / 3,
                    A = new pc.VertexFormat(_, g),
                    b = new pc.VertexBuffer(_, A, E),
                    C = new pc.VertexIterator(b);
                for (let t = 0; t < E; t++) C.element[pc.SEMANTIC_POSITION].set(f[3 * t], f[3 * t + 1], f[3 * t + 2]), C.element[pc.SEMANTIC_TEXCOORD0].set(m[4 * t], m[4 * t + 1], m[4 * t + 2], m[4 * t + 3]), C.next();
                return C.end(), e.vertexBuffer = b, e.indexBuffer[0] = new pc.IndexBuffer(_, pc.INDEXFORMAT_UINT16, 5040, pc.BUFFER_STATIC, y.buffer), e.primitive[0].type = pc.PRIMITIVE_TRIANGLES, e.primitive[0].base = 0, e.primitive[0].count = y.length, e.primitive[0].indexed = !0, e.aabb.setToInfinity(), e
            }
        }), { SkyboxLoader: n }
    }()), pc.extend(pc, function() {
        const t = function(t, e, i, n, s, r) { this.mesh = t, this.matrix = e, this.material = i, this.submeshIndex = n, this.shaderPass = s, this.materialPropertyBlock = r },
            e = function() { this.device = pc.Application.getApplication().graphicsDevice, this._name = "", this.commands = [], this.renderTargetIdentifier = null, this.clearCommand = null, this.view = null, this.proj = null };
        return pc.extend(e.prototype, {
            clear: function() { this.commands.length = 0, this.renderTargetIdentifier = null, this.clearCommand = null },
            clearRenderTarget: function(t, e, i) {
                let n = 0;
                t && (n |= pc.CLEARFLAG_DEPTH), e && (n |= pc.CLEARFLAG_COLOR), this.clearCommand = { color: i.data, depth: 1, flags: n }
            },
            setRenderTarget: function(t) { this.renderTargetIdentifier = t },
            drawMesh: function(e, i, n, s, r, o) {
                const a = new t(e || null, i || pc.Mat4.IDENTITY.clone(), n || null, s || -1, r || -1, o || null);
                this.commands.push(a)
            },
            setViewMatrix: function(t) { this.view = t },
            setProjectionMatrix: function(t) { this.proj = t }
        }), Object.defineProperty(e.prototype, "name", { get: function() { return this._name }, set: function(t) { this._name = t } }), { CommandBuffer: e }
    }()), pc.extend(pc, function() { const t = function() { this._name = "" }; return pc.extend(t.prototype, { copyFromMeshInstance: function(t) { for (const e in t.parameters) this.setParameter(e, this.cloneParameterData(t.parameters[e].data)) } }), Object.defineProperty(t.prototype, "target", { get: function() { return this._target }, set: function(t) { this._target = t } }), { RenderTargetIdentifier: t } }()), Bridge.assembly("LunaUnity", ((t, e) => {
        Bridge.define("LunaUnity.Objects.Scene", {
            ctor: function() { this.$initialize(), this.isLoaded = !1, this.index = -1, this.name = null, this.template = null, this.root = null, this.lightmapsOffset = -1 },
            initializeAsTemplate: function(t) { return this.rootJsons = t.rootJsons, this.renderSettings = t.renderSettings, this.name = t.name, this.index = t.index, this.lightmaps = t.lightmaps, this },
            _createRoot: function() { this.root = new pc.Entity, this.root.scene = this, this.root.name = "SceneRoot: " + this.name, this.application.app.root.addChild(this.root) },
            initializeAsDontDestroyOnLoad: function() { this.name = "DontDestroyOnLoad", this.application = window.$application, this.isLoaded = !0, this._createRoot() },
            isValid: function() { return !0 },
            _load: function(t) { return this.application = t, this.isLoaded = !0, this._createRoot(), UnityEngine.LightmapSettings.reflectionProbes || (UnityEngine.LightmapSettings.reflectionProbes = new UnityEngine.ReflectionProbes), this._installLightProbes(), this._installLightmaps(), 1 === UnityEngine.SceneManagement.SceneManager.sceneCount && (window.$scene = this, this._applyRenderSettings(), this._updateEnvironmentLighting()), this.disableCallbacks(), this._loadObjects(), this.invokeCallbacks(this.root), this.root.syncHierarchy(), System.Threading.Tasks.Task.fromResult(!0) },
            loadAsync: function() { return this._load(window.$application) },
            unload: function() { this._unload() },
            _unload: function() {
                const t = this.root.children.slice();
                for (let e = 0; e < t.length; e++) new pc.DestroyEntityTask(t[e], 0).execute();
                this.root.destroy(), this.root = null, this.isLoaded = !1, this._uninstallLightProbes()
            },
            findChild: function(t, e) { if (e.id === t) return e; { let i = null; for (let n = 0; n < e.children.length && (i = this.findChild(t, e.children[n]), !i); n++); return i } },
            _instantiate: function(t, e, i, n, s, r) {
                const o = LunaUnity.Objects.Bundle.handlers.game_object.fork(),
                    a = new LunaUnity.Objects.Request;
                let c;
                a.root = s || this.root;
                let h = !0;
                if (t.handle && !t.handle.isPrefab) {
                    const i = t.gameObject.handle.$id;
                    e.handle.$id === i ? c = e.handle.objectJson : (e = e.handle.objectJson, c = this.findChild(i, e)), e = t.handle
                } else if (e.isPrefabProxy) c = e.prefab || o.registry.Get(e.prefabId).prefab;
                else if (c = (e = e.handle).objectJson, h = e.activeSelf, !c) throw new Error("Unable to instantiate a non-prefab object");
                this.disableCallbacks();
                const l = o.loadAsync(a, c).result;
                if (l.isPrefab = !1, l.name = (e.name || l.name) + "(Clone)", l.enabled = h, a.resolveReferences(o.registry), i && n) l.muteTransformModificationCallback(), l.setRotation(n), l.setPosition(i), l.unmuteTransformModificationCallback();
                else if (r) {
                    l.muteTransformModificationCallback();
                    const t = l.getLocalRotationAndScale();
                    l.setRotation(l.getLocalRotation().clone()), l.setPosition(l.getLocalPosition().clone()), l.setWorldRotationAndScale(t), l.unmuteTransformModificationCallback()
                }
                this.invokeCallbacks(l);
                const u = o.registry.Get(e.isPrefabProxy ? e.componentId || c.id : t.handle.$id);
                if (u.code) return u.code;
                if (e.isPrefabProxy) return UnityEngine.Object.FromHandle(t, u);
                if (Bridge.Reflection.isAssignableFrom(UnityEngine.Transform, Bridge.getType(t))) return UnityEngine.Object.FromHandle(UnityEngine.GameObject, u).gettransform();
                if ("GameObject" === Bridge.Reflection.getTypeName(Bridge.getType(t))) return UnityEngine.Object.FromHandle(UnityEngine.GameObject, u);
                throw new Error("Don't know what should be instantiated")
            },
            _locatePrefabAsync: function(t, e) {
                const i = LunaUnity.Objects.Bundle.loadByNameAsync(t),
                    n = new System.Threading.Tasks.TaskCompletionSource;
                return i.continueWith(Bridge.fn.bind(this, (t => {
                    const i = t.result.json.prefabs.find((t => t.data[0] === e)).id,
                        s = LunaUnity.Objects.Bundle.handlers.game_object.objectSpace.registry,
                        r = UnityEngine.Object.FromHandle(UnityEngine.GameObject, s.Get(i));
                    n.setResult(r)
                }))), n.task
            },
            _releaseBundleAsync: function(t) { LunaUnity.Objects.Bundle.releaseByNameAsync(t) },
            _applyRenderSettings: function() {
                const t = this.application.app,
                    e = this.application.objectSpace.getRegistry(),
                    i = UnityEngine.RenderSettings,
                    n = this.renderSettings;
                t.scene.ambientLight = (new pc.Color).copy(n.ambientLight), i._ambientMode = n.ambientMode, i._pixelLightCount = n.pixelLightCount, i._ambientLight = n.ambientLight.clone(), i._ambientSkyColor = n.ambientSkyColor.clone(), i._ambientEquatorColor = n.ambientEquatorColor.clone(), i._ambientGroundColor = n.ambientGroundColor.clone(), i._ambientIntensity = n.ambientIntensity, i._reflectionIntensity = n.reflectionIntensity, i._defaultReflectionMode = n.defaultReflectionMode, i._defaultReflectionResolution = n.defaultReflectionResolution, i._sun = UnityEngine.Object.FromHandle(UnityEngine.Light, e.TryGet(n.sunLightObjectId)), i._skybox = n.skybox, i.fogDensity = n.fogDensity, i.fogColor = n.fogColor.clone(), i.fogStart = n.fogStart, i.fogEnd = n.fogEnd, i.fogMode = n.fogMode, i.fog = n.fog, i.hasLightDataAsset = n.hasLightDataAsset, i.hasManualGenerate = n.hasManualGenerate, i.ambientProbe.clear(), this._installSkybox(), i._customReflection = n.customReflection
            },
            _updateEnvironmentLighting: function() {
                const t = UnityEngine.RenderSettings,
                    e = this.application.app;
                e.scene.skyboxHelper.update(), e.scene.skyboxHelper.environmentCubemap || t.defaultReflectionMode !== UnityEngine.Rendering.DefaultReflectionMode.Skybox && t.defaultReflectionMode !== UnityEngine.Rendering.DefaultReflectionMode.Custom ? (e.scene.skyboxHelper.computeIndirectSpecular(), e.scene.skyboxHelper.updateReflectionIntensity()) : UnityEngine.DynamicGI.BakeReflectionsCubemap();
                const i = 1 !== t._ambientIntensity || t._ambientMode !== UnityEngine.Rendering.AmbientMode.Skybox || !t.skybox;
                t._ambientMode === UnityEngine.Rendering.AmbientMode.Skybox && !t.hasLightDataAsset && t.hasManualGenerate || (i ? (UnityEngine.DynamicGI.BakeLightingCubemap(), UnityEngine.DynamicGI.UpdateEnvironmentLighting()) : (UnityEngine.DynamicGI.UpdateEnvironmentLighting(!1), t.ambientProbe.copy(this.renderSettings.ambientProbe)))
            },
            _installSkybox: function() {
                const t = this.application.app;
                t.scene.skyboxHelper || (t.scene.skyboxHelper = new pc.Skybox(t), t.scene.skyboxHelper.install(t.scene), t.scene.skyboxHelper.environmentCubemap = this.renderSettings.defaultReflection ? this.renderSettings.defaultReflection.handle : null)
            },
            _installLightmaps: function() { this.renderSettings.lightmaps && 0 !== this.renderSettings.lightmaps.length && (UnityEngine.LightmapSettings.lightmapsMode = this.renderSettings.lightmapsMode, UnityEngine.LightmapSettings.environmentLightingMode = this.renderSettings.environmentLightingMode, UnityEngine.LightmapSettings.manager.loadSceneLightmaps(this.index, this.renderSettings.lightmaps)) },
            _installLightProbes: function() {
                if (UnityEngine.LightmapSettings.lightProbes || (UnityEngine.LightmapSettings.lightProbes = this.renderSettings.lightProbes), !this.renderSettings.lightProbes || !this.renderSettings.lightProbes.HasProbes) return;
                const t = UnityEngine.SceneManagement.SceneManager.currentLightProbeProvider;
                t && t.index === this.index || (UnityEngine.LightmapSettings.lightProbes && UnityEngine.LightmapSettings.lightProbes.HasProbes && console.warn("Another scene with light probes was loaded. Previous light probes were unloaded."), UnityEngine.LightmapSettings.lightProbes = this.renderSettings.lightProbes), UnityEngine.SceneManagement.SceneManager.currentLightProbeProvider = this
            },
            _uninstallLightProbes: function() {
                if (UnityEngine.SceneManagement.SceneManager.currentLightProbeProvider !== this) return;
                const t = this.getClosestLoadedSceneMatch((t => t._containsLightProbes()));
                t && t._installLightProbes()
            },
            getClosestLoadedSceneMatch: function(t) {
                const e = UnityEngine.SceneManagement.SceneManager,
                    i = e.GetSceneIndex(this);
                if (i < 0) return null;
                const n = e.loadedScenes._items,
                    s = e.loadedScenes.Count;
                for (let e = i - 1; e >= 0; e--) { const i = n[e]; if (i && i.isLoaded && (!t || t(i))) return i }
                for (let e = i + 1; e < s; e++) { const i = n[e]; if (i && i.isLoaded && (!t || t(i))) return i }
                return null
            },
            _containsLightProbes: function() { return this.renderSettings.lightProbes && this.renderSettings.lightProbes.HasProbes },
            _loadObjects: function() {
                const t = LunaUnity.Objects.Bundle.handlers.game_object.fork(),
                    e = new LunaUnity.Objects.Request;
                e.root = this.root;
                for (let i = 0; i < this.rootJsons.length; i++) t.loadAsync(e, this.rootJsons[i]).result;
                e.resolveReferences(t.registry)
            },
            invokeCallbacks: function(t) { this.application.app.systems.unitymanager.invokeCallbacks(t) },
            disableCallbacks: function(t) { this.application.app.systems.unitymanager.disableCallbacks() },
            getRootGameObjects: function() {
                if (!this.root) return System.Array.init([], UnityEngine.GameObject);
                const t = this.root.children,
                    e = t.length,
                    i = new Array(e);
                for (let n = 0; n < e; ++n) i[n] = UnityEngine.Object.FromHandle(UnityEngine.GameObject, t[n]);
                return System.Array.init(i, UnityEngine.GameObject)
            },
            createInstance: function() { const t = new LunaUnity.Objects.Scene; return t.template = this, t.index = this.index, t.name = this.name, t.rootJsons = this.rootJsons, t.renderSettings = this.renderSettings, t.lightmaps = this.lightmaps, t },
            setActive: function(t) { t && (this._applyRenderSettings(), this._updateEnvironmentLighting(), window.$scene = this) },
            addGameObjectToRoot: function(t) {
                const e = t.handle;
                let i = null;
                if (null != e.parent && (i = e.parent.scene), i && i === this) return;
                const n = e.getWorldTransform().clone();
                e.reparent(this.root, -1), e.setLocalTransform(n)
            }
        })
    })), Bridge.assembly("LunaUnity", ((t, e) => {
        Bridge.define("LunaUnity.Objects.LightmapManager", {
            ctor: function(t) { this.$initialize(), this.lightmaps = [] },
            getLightmap: function(t, e) { const i = this.lightmaps[t]; return i ? i.lightmaps[e] : null },
            loadSceneLightmaps: function(t, e) { this.lightmaps[t] = this.lightmaps[t] || {}, this.lightmaps[t].lightmaps = e, this.lightmaps[t].custom = !1 },
            setManagedLightmaps: function(t) {
                const e = UnityEngine.SceneManagement.SceneManager.loadedScenes._items;
                let i = 0;
                const n = UnityEngine.SceneManagement.SceneManager.loadedScenes.Count;
                for (let s = 0; s < n; s++) {
                    const r = e[s],
                        o = this.lightmaps[r.index];
                    if (o) {
                        const r = [];
                        let a = o.lightmaps.length,
                            c = !0;
                        for (let t = s + 1; t < n; t++)
                            if (this.lightmaps[e[t]]) { c = !1; break }
                        c && (a = t.length - i);
                        for (let e = 0; e < a; e++) r.push(new UnityEngine.LightmapData.$ctor1(t[i])), i++;
                        o.custom = !0, o.lightmaps = r
                    }
                }
            },
            getManagedLightmaps: function() {
                if (0 === this.lightmaps.length) return System.Array.init([], UnityEngine.LightmapData);
                const t = [],
                    e = UnityEngine.SceneManagement.SceneManager.loadedScenes._items,
                    i = UnityEngine.SceneManagement.SceneManager.loadedScenes.Count;
                for (let n = 0; n < i; n++) {
                    const i = e[n],
                        s = this.lightmaps[i.index];
                    if (s) { const e = s.lightmaps; for (let i = 0; i < e.length; i++) t.push(new UnityEngine.LightmapData.$ctor1(e[i])) }
                }
                return System.Array.init(t, UnityEngine.LightmapData)
            }
        })
    })), pc.extend(pc, function() {
        const t = { size: "fontSize", color: "color", fontStyle: "fontStyle" },
            e = { aqua: "#00ffffff", black: "#000000ff", blue: "#0000ffff", brown: "#a52a2aff", cyan: "#00ffffff", fuchsia: "#ff00ffff", green: "#008000ff", grey: "#808080ff", lightblue: "#add8e6ff", lime: "#00ff00ff", magenta: "#ff00ffff", maroon: "#800000ff", navy: "#000080ff", olive: "#808000ff", orange: "#ffa500ff", purple: "#800080ff", red: "#ff0000ff", silver: "#c0c0c0ff", teal: "#008080ff", white: "#ffffffff", yellow: "#ffff00ff" },
            i = function(t, e) {
                this.startIndex = t, this.foundTag = e, this.isClosing = !1;
                const i = (e = e.substr(1, e.length - 2)).split("=");
                let n = i[0];
                n = n.toLowerCase(), n.startsWith("/") && (n = n.substr(1), this.isClosing = !0), this.tag = n;
                let s = i[1] ? i[1] : null;
                if (s && s.startsWith('"') && s.endsWith('"') && (s = s.substr(1, s.length - 2)), s && (s = s.toLowerCase()), this.value = s, this.isClosing) return this;
                if (this.colorValue = new pc.Color, this.intValue = 0, !this.isClosing) switch (this.tag) {
                    case "color":
                        this.colorValue = this.parseColor(this.value, this.colorValue);
                        break;
                    case "size":
                        this.intValue = Number.parseInt(this.value, 10)
                }
                return this
            };
        return pc.extend(i.prototype, {
            apply: function(e, i, n) {
                const s = t[this.tag];
                if (this.isClosing) switch (this.tag) {
                    case "color":
                        e.color.copy(i.color);
                        break;
                    case "size":
                        e.fontSize = i.fontSize, e.fontScale = i.fontScale;
                        break;
                    default:
                        e[s] = i[s]
                } else switch (this.tag) {
                    case "color":
                        e.color.copy(this.colorValue);
                        break;
                    case "size":
                        e.fontSize = this.intValue, e.fontScale = e.fontSize / n;
                        break;
                    default:
                        e[s] = this.intValue
                }
            },
            parseColor: function(t, i) { return i = i || new pc.Color, t.startsWith("#") || (t = e[t]), i.fromString(t), i }
        }), pc.extend(i, {
            tagRegex: /<.[^>]*>/gm,
            supportedSingleTags: { br: !0, quad: !0 },
            unityColorsMap: e,
            removeTags: function(t) { return t.replace(this.tagRegex, "") },
            extractTags: function(t, e) {
                const i = e._tags;
                i.length = 0;
                let n = 0,
                    s = null;
                for (; null != (s = this.tagRegex.exec(t));) {
                    const t = s[0],
                        e = new pc.TextTag(s.index - n, t);
                    n += t.length, i.push(e)
                }
                const r = this.removeTags(t),
                    o = this.validateTags(i, r);
                return e.areTagsValid = o, t = o ? r : t
            },
            validateTags: function(t, e) {
                if (0 === t.length) return !0;
                const i = [];
                for (let n = 0; n < t.length; n++) {
                    const s = t[n];
                    if (!pc.TextTag.supportedSingleTags[s.tag])
                        if (s.isClosing) {
                            const t = i.pop();
                            if (t.tag !== s.tag) return !1;
                            s.content = e.substr(t.startIndex, s.startIndex - t.startIndex), t.content = e.substr(t.startIndex, s.startIndex - t.startIndex)
                        } else i.push(s)
                }
                return 0 === i.length
            }
        }), { TextTag: i }
    }()), pc.extend(pc, function() {
        const t = function(t, e, i, n, s) { this.font = t, this.fontSize = e, this.fontScale = i, this.color = n.clone(), this.fontStyle = s };
        pc.extend(t.prototype, { init: function(t, e, i, n, s) { this.font = t, this.fontSize = e, this.fontScale = i, this.color.copy(n), this.fontStyle = s }, copy: function(t) { this.font = t.font, this.fontSize = t.fontSize, this.fontScale = t.fontScale, this.color.copy(t.color), this.fontStyle = t.fontStyle } });
        const e = function() { return this.breakable = {}, this.breakable[" "] = 10, this.breakable[","] = 20, this.breakable[";"] = 30, this.breakable["."] = 40, this.breakable["\n"] = 500, this };
        pc.extend(e.prototype, {
            cleanse: function(t) { return t.replace(/\r\n/gm, "\n").replace(/\n\r/gm, "\n") },
            performWrap: function(t, e, i) {
                let n = "";
                t = this.cleanse(t);
                const s = Math.round(Math.sqrt(e * t.length / i)),
                    r = Math.round(t.length / s);
                let o = r,
                    a = 0,
                    c = 0;
                for (let e = 0; e < s - 1; e++) c = a, a = this.bestBreak(t, o, 2 * r), n += t.substring(c, a).trim() + "\n", o = a + r;
                return n += t.substring(a), n
            },
            bestBreak: function(t, e, i) {
                let n = e,
                    s = 0,
                    r = 0;
                for (let o = e - (i = Math.min(Math.min(e + i, t.length - 1) - e, e - Math.max(e - i, 0))); o <= e + i; o++) {
                    const i = this.breakable[t[o]];
                    i && (r = i / Math.abs(1 * (e - o)), r > s && (n = o, s = r))
                }
                return Math.min(n + 1, t.length - 1)
            }
        });
        return { EditableSettings: t, StringWrap: e, MeasuredLine: function(t, e, i) { this.text = t, this.width = e, this.fontScale = i }, UICharInfo: function(t, e) { this.cursorPos = t || new pc.Vec3, this.charWidth = e || 0 }, UILineInfo: function(t, e, i, n) { this.startCharIdx = t || 0, this.height = e || 0, this.topY = i || 0, this.leading = n || 0 } }
    }()), pc.extend(pc, function() {
        const t = 11,
            e = [{ semantic: pc.SEMANTIC_POSITION, components: 3, type: pc.TYPE_FLOAT32 }, { semantic: pc.SEMANTIC_TEXCOORD0, components: 2, type: pc.TYPE_FLOAT32 }, { semantic: pc.SEMANTIC_TEXCOORD1, components: 2, type: pc.TYPE_FLOAT32 }, { semantic: pc.SEMANTIC_COLOR, components: 4, type: pc.TYPE_FLOAT32 }],
            i = new pc.Vec4,
            n = new pc.Vec4,
            s = new pc.Vec4,
            r = function(t) { return this._offset = new pc.Vec3, this._bakedOffset = new pc.Vec3, this._bounds = new pc.Vec2, this._metrics = new pc.Vec4, this.canvasRenderer = t, this._vertexCount = 0, this._bufferSize = 0, this._buffer = null, this._resizeBuffers(16), this._fontScale = 0, this._bestFit = !1, this._font = null, this._maxFontSize = 0, this._minFontSize = 0, this._minFontSizeOriginal = 0, this._maxFontSizeOriginal = 0, this._horizontalWrap = !1, this._verticalOverflow = !1, this._lineHeight = 0, this._lineSpacing = 0, this._fontSize = 0, this._textHeight = 0, this._align = pc.TEXT_ALIGN_CENTER, this._color = new pc.Color(1, 1, 1, 1), this._dirtyVertices = !1, this._dirtyOffset = !1, this._lineCount = 0, this._characters = [], this._lines = [], this._tags = [], this.areTagsValid = !0, this._defaultSettings = new pc.EditableSettings(null, 0, 0, new pc.Color, 0), this._currentSettings = new pc.EditableSettings(null, 0, 0, new pc.Color, 0), this._measureSettings = new pc.EditableSettings(null, 0, 0, new pc.Color, 0), this._recursiveCounter = 0, this._measures = null, this._originalMeasures = null, this._recursiveLimit = 10, this.graphicsDevice = pc.Application.getApplication().graphicsDevice, this };
        r.fontRatio = 3.75;
        let o = null;
        return r.createEmptyMesh = function() {
            const t = pc.Application.getApplication().graphicsDevice,
                i = new pc.VertexFormat(t, e),
                n = new pc.VertexBuffer(t, i, 0),
                s = new pc.Mesh(!0);
            return s.vertexBuffer = n, s.indexBuffer = [new pc.IndexBuffer(t, pc.INDEXFORMAT_UINT16, 0)], s.primitive[0].type = pc.gfx.PRIMITIVE_TRIANGLES, s.primitive[0].base = 0, s.primitive[0].count = 0, s.primitive[0].indexed = !0, s
        }, pc.extend(r.prototype, {
            _reset: function() { this._bufferSize = 0, this._buffer = new Float32Array(0) },
            _textIndexBuffer: function() {
                if (o) return o;
                o = new pc.IndexBuffer(this.graphicsDevice, pc.INDEXFORMAT_UINT16, 32768);
                const t = new Uint16Array(o.lock());
                let e = 0;
                for (let i = 0; i < 32762; i += 6) t[i + 0] = e + 3, t[i + 1] = e + 0, t[i + 2] = e + 1, t[i + 3] = e + 1, t[i + 4] = e + 3, t[i + 5] = e + 2, e += 4;
                return o.unlock(), o.destroy = function() {}, o
            },
            populate: function(t, e) { e._font ? (this._updateSettings(e), this._updateText(t), e._dirtyOffset = this._dirtyOffset, e._dirtyVertices = this._dirtyVertices, e._metrics = this._metrics, this._dirtyVertices && this._fillMesh(), this._dirtyOffset && this._updateAligns()) : this.vertexCount = 0 },
            updateMesh: function(t, e, i) {
                i = i || pc.Vec3.ZERO;
                const n = this._vertexCount,
                    s = t.vertexBuffer;
                for (let t = 0; t < n; t++) this._buffer[11 * t + 0] += i.x - this._bakedOffset.x, this._buffer[11 * t + 1] += i.y - this._bakedOffset.y, this._buffer[11 * t + 2] += i.z - this._bakedOffset.z;
                for (let t = 0; t < this._lines.length; t++) { this._lines[t].topY += i.y - this._bakedOffset.y }
                for (let t = 0; t < this._characters.length; t++) { this._characters[t].cursorPos.sub(this._bakedOffset).add(i) }
                s.numVertices = n, s.storage = this._buffer.buffer, s.unlock(), t.primitive[0].type = pc.gfx.PRIMITIVE_TRIANGLES, t.primitive[0].base = 0, t.primitive[0].count = n / 4 * 6, t.primitive[0].indexed = !0, t.indexBuffer[0] = this._textIndexBuffer(), this._bakedOffset.copy(i)
            },
            _updateAligns: function(t) {
                t = t || this._measureText(this._text, void 0, !1);
                const e = this._font.data,
                    i = this._lineHeight * this._fontScale,
                    n = i + i / this._font.lineHeight * .5,
                    s = Math.round(this._bounds.y / n),
                    r = (this._verticalOverflow ? t.length : Math.min(t.length, s > 0 ? s : 1)) * n;
                let o = this._fontSize / e.info.fontSize;
                this._bestFit && (o = this._minFontSize / e.info.fontSize);
                let a = -1;
                for (let e = 0; e < t.length; e++) a = Math.max(t[e].width, a);
                this._metrics.set(Math.ceil(a / this._fontScale * o), Math.ceil(r / this._fontScale * o), Math.ceil(this._metrics.z), Math.ceil(this._metrics.w)), 0 === this._fontScale && (this._metrics.x = 0, this._metrics.y = 0);
                const c = this._bounds.y;
                let h = 0;
                switch (this._verticalAlign) {
                    case pc.TEXT_VERTICAL_ALIGN_BOTTOM:
                        h = c - r;
                        break;
                    case pc.TEXT_VERTICAL_ALIGN_MIDDLE:
                        h = .5 * (c - r);
                        break;
                    case pc.TEXT_VERTICAL_ALIGN_TOP:
                        h = 0
                }
                const l = c - h - n;
                this._offset.set(0, l, 0), this._dirtyOffset = !1
            },
            applyTags: function(t, e, i, n) {
                if (this.areTagsValid)
                    for (let s = 0; s < this._tags.length; s++) {
                        const r = this._tags[s];
                        t === r.startIndex && r.apply(e, i, n)
                    }
            },
            _fillMesh: function() {
                this._characters.length = 0, this._lines.length = 0;
                const t = this._font.data;
                let e = this._text;
                e = e.replace(/\r\n/gm, "\n").replace(/\n\r/gm, "\n"), e = e.replace(/\t/gm, "    "), e = pc.TextTag.extractTags(e, this), this._bakedOffset.set(0, 0, 0);
                const i = this._font.fontSize,
                    n = this._fontSize,
                    s = this._font._originalFontSize;
                this._lineHeight = this._lineSpacing * this._font.lineHeight * (i / s), this._fontScale = n / i, 0 === this._recursiveCounter && (this._measures = this._measureText(e, 1e15, !1));
                let r = -1,
                    o = 0;
                for (let t = 0; t < this._measures.length; t++) r = Math.max(r, this._measures[t].width), o += this._lineHeight * this._measures[t].fontScale;
                let a = Math.min(this._bounds.x / r, this._bounds.y / o),
                    c = Math.min(this._maxFontSize, i * a);
                this._metrics.set(0, 0, r, o);
                const h = this._bestFit && !this._verticalOverflow;
                if (h && this._bounds.x > 0) {
                    this._metrics.set(0, 0, r / this._fontSize * this._maxFontSize, o / this._fontSize * this._maxFontSize);
                    const i = e.split("\n").length;
                    if (0 === this._recursiveCounter) {
                        a = this._bounds.y / (i * this._lineHeight), c = t.info.fontSize * a;
                        const e = Math.max(Math.min(this._maxFontSize, c), this._minFontSize);
                        this._fontScale = e / t.info.fontSize
                    }
                }
                if (this._horizontalWrap) { if (this._recursiveCounter >= this._recursiveLimit) return; if (this._measures = this._measureText(e, this._bounds.x, !0), this.measureAlignment(), this._recursiveCounter += 1, h) { this._maxFontSize - this._minFontSize > .051 && this._fontSize < this._maxFontSize && (this._recursiveCounter - 1 == 0 ? this._fontSize = this._minFontSize : this._minFontSize = this._fontSize, this._fontSize += Math.max((this._maxFontSize - this._fontSize) / 2, .05), this._fontSize = Math.floor(20 * Math.min(this._fontSize, this._maxFontSize) + .5) / 20, this._fillMesh()) } } else this._measureText(e, 1e15, !0), this.measureAlignment()
            },
            measureAlignment() {
                let t = 0,
                    e = 0;
                let r = 0;
                this._defaultSettings.init(this._font, this._fontSize, this._fontScale, this._color, 0), this._currentSettings.init(this._font, this._fontSize, this._fontScale, this._color, 0);
                const o = this._font.data;
                let a = 0,
                    c = 0,
                    h = 0;
                if (null !== this._measures) {
                    for (let l = 0; l < this._measures.length; l++) {
                        const u = this._measures[l];
                        switch (a = c, this._align) {
                            case pc.TEXT_ALIGN_LEFT:
                                t = 0;
                                break;
                            case pc.TEXT_ALIGN_CENTER:
                                t = .5 * (this._bounds.x - u.width);
                                break;
                            case pc.TEXT_ALIGN_RIGHT:
                                t = this._bounds.x - u.width
                        }
                        const d = this._lineHeight * this._currentSettings.fontScale,
                            p = d / this._font.lineHeight * .5;
                        let _ = -(e - d);
                        l > 0 && !this._bestFit && (_ -= p);
                        let f = 0 !== this._bounds.y ? this._bounds.y : 0;
                        if (_ === d && 0 !== f && 1 === this._measures.length && (f += 1), !this._verticalOverflow && 0 !== this._bounds.y && _ > f) {
                            if (this._bestFit && this._fontSize > this._minFontSizeOriginal && (this._recursiveCounter > 0 || this._fontSize === this._maxFontSize)) { if (this._maxFontSize = this._fontSize, this._fontSize -= Math.max((this._fontSize - this._minFontSize) / 2, .05), this._fontSize = Math.floor(20 * Math.max(this._fontSize, this._minFontSize) + .5) / 20, this._recursiveCounter >= this._recursiveLimit) return; return void this._fillMesh() }
                            0 === l && console.warn("[Rendering] Text will be hidden, as there are not enough space even for 1 line!\nSet BestFit or enable vertical overflow");
                            continue
                        }
                        const m = d + p;
                        e -= m - (this._lineHeight * this._measures[Math.max(l - 1, 0)].fontScale + p);
                        for (let a = 0; a < u.text.length; a++) {
                            this.applyTags(h, this._currentSettings, this._defaultSettings, o.info.fontSize);
                            const l = u.text.charCodeAt(a);
                            let d = 0,
                                p = 0,
                                _ = 0;
                            const f = o.chars[l];
                            if (!f) continue;
                            d = f.xoffset * this._currentSettings.fontScale, p = f.yoffset * this._currentSettings.fontScale, _ = f.xadvance * this._currentSettings.fontScale;
                            const y = f.width * this._currentSettings.fontScale,
                                g = f.height * this._currentSettings.fontScale,
                                E = e + m,
                                A = m;
                            i.set(t + d, E - p - g, 0), n.set(t + d + y, E - p, 0), s.set(0, 1 - (p + g) / A, 1, 1 - p / A), this.addCharToBuffer(r, i, n, f, s, this._currentSettings.color), this._characters.push(new pc.UICharInfo(new pc.Vec3(t + d, E - p - g, 0).add(this._bakedOffset), y)), t += _, r++, c++, h++
                        }
                        this._lines.push(new pc.UILineInfo(a, m, e + this._bakedOffset.y + m, 0)), e -= m, this.applyTags(h, this._currentSettings, this._defaultSettings, o.info.fontSize), h++
                    }
                    this._vertexCount = 4 * r, this._dirtyVertices = !1, this._updateAligns(this._measures), this._lineCount = this._measures.length, this.canvasRenderer && this.canvasRenderer.cacheColors(this.mesh)
                }
            },
            addCharToBuffer(e, i, n, s, r, o) {
                const a = 4 * e,
                    c = (a + 0) * t,
                    h = (a + 1) * t,
                    l = (a + 2) * t,
                    u = (a + 3) * t;
                this._buffer[c] = i.x, this._buffer[c + 1] = i.y, this._buffer[c + 2] = i.z, this._buffer[c + 3] = s.uvBottomLeft[0], this._buffer[c + 4] = s.uvBottomLeft[1], this._buffer[c + 5] = r.x, this._buffer[c + 6] = r.y, this._buffer[c + 7] = o.r, this._buffer[c + 8] = o.g, this._buffer[c + 9] = o.b, this._buffer[c + 10] = o.a, this._buffer[h] = i.x, this._buffer[h + 1] = n.y, this._buffer[h + 2] = i.z, this._buffer[h + 3] = s.uvTopLeft[0], this._buffer[h + 4] = s.uvTopLeft[1], this._buffer[h + 5] = r.x, this._buffer[h + 6] = r.w, this._buffer[h + 7] = o.r, this._buffer[h + 8] = o.g, this._buffer[h + 9] = o.b, this._buffer[h + 10] = o.a, this._buffer[l] = n.x, this._buffer[l + 1] = n.y, this._buffer[l + 2] = i.z, this._buffer[l + 3] = s.uvTopRight[0], this._buffer[l + 4] = s.uvTopRight[1], this._buffer[l + 5] = r.z, this._buffer[l + 6] = r.w, this._buffer[l + 7] = o.r, this._buffer[l + 8] = o.g, this._buffer[l + 9] = o.b, this._buffer[l + 10] = o.a, this._buffer[u] = n.x, this._buffer[u + 1] = i.y, this._buffer[u + 2] = i.z, this._buffer[u + 3] = s.uvBottomRight[0], this._buffer[u + 4] = s.uvBottomRight[1], this._buffer[u + 5] = r.z, this._buffer[u + 6] = r.y, this._buffer[u + 7] = o.r, this._buffer[u + 8] = o.g, this._buffer[u + 9] = o.b, this._buffer[u + 10] = o.a
            },
            measureText: function(t, e, i) {
                if (t = t || "", this._updateSettings(i), !this._font) return pc.Vec2.ZERO;
                const n = this._font.data;
                this._fontScale = this._fontSize / n.info.fontSize, t = pc.TextTag.removeTags(t);
                const s = this._measureText(t, e, !1);
                let r = -1;
                for (let t = 0; t < s.length; t++) r = Math.max(r, s[t].width);
                const o = s.length * this._lineHeight * this._fontScale;
                return new pc.Vec2(r, o)
            },
            _measureText: function(t, e, i) {
                const n = this._font.data,
                    s = [],
                    r = t.replace("\n\r", "\n").replace("\r\n", "\n").split(/\n/);
                let o = "";
                const a = n.chars[" ".charCodeAt(0)];
                let c = a ? a.xadvance * this._fontScale : 0;
                this._defaultSettings.init(this._font, this._fontSize, this._fontScale, this._color, 0), this._currentSettings.init(this._font, this._fontSize, this._fontScale, this._color, 0), this._measureSettings.init(this._font, this._fontSize, this._fontScale, this._color, 0);
                let h = 0,
                    l = 0;
                const u = { maxFontScale: 0 };
                this._measureSettings.copy(this._currentSettings);
                for (let t = 0; t < r.length; t++) {
                    let d = r[t].split(" ");
                    this._measureSettings.copy(this._currentSettings), d = this._checkBigWords(d, n, this._fontScale, e, h, this._measureSettings, this._defaultSettings, n.info.fontSize, i);
                    let p = 0;
                    for (let t = 0; t < d.length; t++) {
                        const i = d[t],
                            r = this._calculateWidth(i, n, this._fontScale, h, this._currentSettings, this._defaultSettings, n.info.fontSize, u);
                        p > 0 && p + r > e && (c = a ? a.xadvance * this._currentSettings.fontScale : 0, o = o.substring(0, o.length - 1), p -= c, s.push(new pc.MeasuredLine(o, p, l)), l = 0, o = "", p = 0, h++), l = Math.max(l, u.maxFontScale), h += i.length, o += i + " ", c = a ? a.xadvance * this._currentSettings.fontScale : 0, p += r + c, this.applyTags(h, this._currentSettings, this._defaultSettings, n.info.fontSize), h++
                    }
                    o = o.substring(0, o.length - 1), p -= c, s.push(new pc.MeasuredLine(o, p, l)), l = 0, o = "", p = 0
                }
                return s
            },
            getMeasuredText: function(t) { return t.map((t => t.text)).join("\n") },
            _calculateWidth: function(t, e, i, n, s, r, o, a) {
                let c = 0;
                for (let i = 0; i < t.length; i++) {
                    this.applyTags(n, s, r, o), a && (a.maxFontScale = Math.max(a.maxFontScale, s.fontScale));
                    const h = t.charCodeAt(i),
                        l = e.chars[h];
                    l && (c += l.xadvance * s.fontScale), n++
                }
                return 0 === t.length && a && (a.maxFontScale = i), c
            },
            _splitWord: function(t, e, i, n) {
                const s = [];
                let r = 0,
                    o = 0;
                for (; o < t.length;) {
                    const a = t.charCodeAt(o),
                        c = e.chars[a],
                        h = (c ? c.xadvance : 0) * i;
                    if (c) {
                        if (r > 0 && r + h >= n) {
                            const e = t.substring(0, o);
                            t = t.substring(o), r = h, o = 1, s.push(e);
                            continue
                        }
                        r += h
                    }
                    o++
                }
                return s.push(t), s
            },
            _checkBigWords: function(t, e, i, n, s, r, o, a, c) { const h = []; for (let l = 0; l < t.length; l++) { const u = t[l]; if (this._calculateWidth(u, e, i, s, r, o, a) > n) { const t = this._splitWord(u, e, i, n); for (let e = 0; e < t.length; e++) h.push(t[e]), s += t[e].length, c && e !== t.length - 1 && this.applyTagsOffsets(s, 1) } else h.push(u) } return h },
            applyTagsOffsets(t, e) {
                for (let i = 0; i < this._tags.length; i++) {
                    const n = this._tags[i];
                    n.startIndex < t || (n.startIndex += e)
                }
            },
            _updateText: function(t) { this._text !== t && (this._dirtyVertices = !0, this._dirtyOffset = !0), this._text = t, this._resizeBuffers(t.length) },
            _updateSettings: function(t) { this._verticalAlign !== t.verticalAlign && (this._dirtyOffset = !0), this._fontSize === t.fontSize && this._bestFit === t.bestFit && this._font === t.font && this._maxFontSize === t.maxFontSize && this._minFontSize === t.minFontSize && this._horizontalWrap === t.horizontalWrap && this._verticalOverflow === t.verticalOverflow && this._lineSpacing === t.lineSpacing && this._fontSize === t.fontSize && this._align === t.align && this._color.equals(t.color) || (this._dirtyVertices = !0, this._dirtyOffset = !0), this._bounds && this._bounds.x === t.bounds.x && this._bounds.y === t.bounds.y || (this._dirtyOffset = !0, (this._horizontalWrap || this._bestFit || this._align !== pc.TEXT_ALIGN_LEFT) && (this._dirtyVertices = !0)), this._verticalAlign = t.verticalAlign, this._fontSize = t.fontSize, this._bestFit = t.bestFit, this._font = t.font, this._align = t.align, this._maxFontSize = t.maxFontSize, this._minFontSize = t.minFontSize, this._minFontSizeOriginal = t.minFontSize, this._maxFontSizeOriginal = t.maxFontSize, this._horizontalWrap = t.horizontalWrap, this._verticalOverflow = t.verticalOverflow, this._recursiveCounter = 0, this._measures = null, this._originalMeasures = null, this._recursiveLimit = 10, this._bounds.copy(t.bounds), this._lineSpacing = t.lineSpacing, this._color.copy(t.color) },
            _resizeBuffers: function(t) { this._bufferSize = t, this._buffer = new Float32Array(44 * t) },
            populateWithErrors: function(t, e, i) { e.bestFit = e.resizeTextForBestFit, e.font = e.font.handle, e.maxFontSize = e.resizeTextMaxSize, e.minFontSize = e.resizeTextMinSize, e.lineHeight = e.lineSpacing, e.horizontalWrap = !(0 === e.horizontalOverflow), e.bounds = e.generationExtents, e.verticalAlign = "top", e.align = pc.TEXT_ALIGN_LEFT, e._bestFit = e.resizeTextForBestFit, e._fontSize = e.fontSize, e._font = e.font, e._maxFontSize = e.resizeTextMaxSize, e._minFontSize = e.resizeTextMinSize, e._lineHeight = e.lineSpacing, e._verticalOverflow = e.verticalOverflow, e._horizontalWrap = !(0 === e.horizontalOverflow), e._bounds = e.generationExtents, e._verticalAlign = "top", e._align = pc.TEXT_ALIGN_LEFT, this.populate(t, e) }
        }), Object.defineProperty(r.prototype, "offset", { get: function() { return this._offset } }), Object.defineProperty(r.prototype, "vertexCount", { get: function() { return this._vertexCount } }), Object.defineProperty(r.prototype, "lineCount", { get: function() { return this._lineCount } }), Object.defineProperty(r.prototype, "characterCount", { get: function() { return this._characters.length } }), Object.defineProperty(r.prototype, "lines", { get: function() { return this._lines } }), Object.defineProperty(r.prototype, "characters", { get: function() { return this._characters } }), { TextGenerator: r }
    }()), window.Bridge.property = function(t, e, i, n, s, r) {
        const o = { enumerable: !r, configurable: !0 };
        if (i && i.get && (o.get = i.get), i && i.set && (o.set = i.set), !i || !i.get && !i.set) {
            const t = Bridge.getTypeAlias(s) + "$" + e;
            s.$init = s.$init || {}, n && (s.$init[t] = i),
                function(t, e, i, n) { t.get = function() { const t = this.$init[i]; return void 0 === t ? n : t }, t.set = function(t) { this.$init[i] = t } }(o, 0, t, i)
        }
        const a = [e],
            c = s.$descriptors || [];
        for (let t = 0; t < c.length; t++) {
            const i = c[t];
            if (i.name === e)
                for (let t = 0; t < c.length; t++) {
                    const e = c[t];
                    e.get === i.get && e.set === i.set && (-1 === a.indexOf(e.name) && a.push(e.name))
                }
        }
        for (const e of a) Object.defineProperty(t, e, o), t["get" + e] = t["get" + e] || o.get, t["set" + e] = t["set" + e] || o.set;
        return o
    },
    function() {
        const t = new RegExp(/[A-Za-z\u0061-\u007A\u00B5\u00DF-\u00F6\u00F8-\u00FF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02AF\u0371\u0373\u0377\u037B-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0561-\u0587\u1D00-\u1D2B\u1D6B-\u1D77\u1D79-\u1D9A\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2184\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7B\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F\uA771-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7FA\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A\u0041-\u005A\u00C0-\u00D6\u00D8-\u00DE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u0386\u0388-\u038A\u038C\u038E\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E\u213F\u2145\u2183\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA\uFF21-\uFF3A\u01C5\u01C8\u01CB\u01F2\u1F88-\u1F8F\u1F98-\u1F9F\u1FA8-\u1FAF\u1FBC\u1FCC\u1FFC\u02B0-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0374\u037A\u0559\u0640\u06E5\u06E6\u07F4\u07F5\u07FA\u081A\u0824\u0828\u0971\u0E46\u0EC6\u10FC\u17D7\u1843\u1AA7\u1C78-\u1C7D\u1D2C-\u1D6A\u1D78\u1D9B-\u1DBF\u2071\u207F\u2090-\u209C\u2C7C\u2C7D\u2D6F\u2E2F\u3005\u3031-\u3035\u303B\u309D\u309E\u30FC-\u30FE\uA015\uA4F8-\uA4FD\uA60C\uA67F\uA717-\uA71F\uA770\uA788\uA7F8\uA7F9\uA9CF\uAA70\uAADD\uAAF3\uAAF4\uFF70\uFF9E\uFF9F\u00AA\u00BA\u01BB\u01C0-\u01C3\u0294\u05D0-\u05EA\u05F0-\u05F2\u0620-\u063F\u0641-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u0800-\u0815\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0972-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E45\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10D0-\u10FA\u10FD-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17DC\u1820-\u1842\u1844-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C77\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u2135-\u2138\u2D30-\u2D67\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3006\u303C\u3041-\u3096\u309F\u30A1-\u30FA\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA014\uA016-\uA48C\uA4D0-\uA4F7\uA500-\uA60B\uA610-\uA61F\uA62A\uA62B\uA66E\uA6A0-\uA6E5\uA7FB-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA6F\uAA71-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB\uAADC\uAAE0-\uAAEA\uAAF2\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF66-\uFF6F\uFF71-\uFF9D\uFFA0-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/),
            e = new RegExp(/[0-9\u0030-\u0039\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0BE6-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF\u0D66-\u0D6F\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F29\u1040-\u1049\u1090-\u1099\u17E0-\u17E9\u1810-\u1819\u1946-\u194F\u19D0-\u19D9\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\uA620-\uA629\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19]/),
            i = new RegExp(/[\u0021-\u0023\u0025-\u002A\u002C-\u002F\u003A\u003B\u003F\u0040\u005B-\u005D\u005F\u007B\u007D\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E3B\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65\u002D\u058A\u05BE\u1400\u1806\u2010-\u2015\u2E17\u2E1A\u2E3A\u2E3B\u301C\u3030\u30A0\uFE31\uFE32\uFE58\uFE63\uFF0D\u0028\u005B\u007B\u0F3A\u0F3C\u169B\u201A\u201E\u2045\u207D\u208D\u2329\u2768\u276A\u276C\u276E\u2770\u2772\u2774\u27C5\u27E6\u27E8\u27EA\u27EC\u27EE\u2983\u2985\u2987\u2989\u298B\u298D\u298F\u2991\u2993\u2995\u2997\u29D8\u29DA\u29FC\u2E22\u2E24\u2E26\u2E28\u3008\u300A\u300C\u300E\u3010\u3014\u3016\u3018\u301A\u301D\uFD3E\uFE17\uFE35\uFE37\uFE39\uFE3B\uFE3D\uFE3F\uFE41\uFE43\uFE47\uFE59\uFE5B\uFE5D\uFF08\uFF3B\uFF5B\uFF5F\uFF62\u0029\u005D\u007D\u0F3B\u0F3D\u169C\u2046\u207E\u208E\u232A\u2769\u276B\u276D\u276F\u2771\u2773\u2775\u27C6\u27E7\u27E9\u27EB\u27ED\u27EF\u2984\u2986\u2988\u298A\u298C\u298E\u2990\u2992\u2994\u2996\u2998\u29D9\u29DB\u29FD\u2E23\u2E25\u2E27\u2E29\u3009\u300B\u300D\u300F\u3011\u3015\u3017\u3019\u301B\u301E\u301F\uFD3F\uFE18\uFE36\uFE38\uFE3A\uFE3C\uFE3E\uFE40\uFE42\uFE44\uFE48\uFE5A\uFE5C\uFE5E\uFF09\uFF3D\uFF5D\uFF60\uFF63\u00AB\u2018\u201B\u201C\u201F\u2039\u2E02\u2E04\u2E09\u2E0C\u2E1C\u2E20\u00BB\u2019\u201D\u203A\u2E03\u2E05\u2E0A\u2E0D\u2E1D\u2E21\u005F\u203F\u2040\u2054\uFE33\uFE34\uFE4D-\uFE4F\uFF3F\u0021-\u0023\u0025-\u0027\u002A\u002C\u002E\u002F\u003A\u003B\u003F\u0040\u005C\u00A1\u00A7\u00B6\u00B7\u00BF\u037E\u0387\u055A-\u055F\u0589\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u166D\u166E\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u1805\u1807-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2016\u2017\u2020-\u2027\u2030-\u2038\u203B-\u203E\u2041-\u2043\u2047-\u2051\u2053\u2055-\u205E\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00\u2E01\u2E06-\u2E08\u2E0B\u2E0E-\u2E16\u2E18\u2E19\u2E1B\u2E1E\u2E1F\u2E2A-\u2E2E\u2E30-\u2E39\u3001-\u3003\u303D\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFE10-\uFE16\uFE19\uFE30\uFE45\uFE46\uFE49-\uFE4C\uFE50-\uFE52\uFE54-\uFE57\uFE5F-\uFE61\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF07\uFF0A\uFF0C\uFF0E\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3C\uFF61\uFF64\uFF65]/),
            n = new RegExp(/[\u2028\u2029\u0020\u00A0\u1680\u180E\u2000-\u200A\u202F\u205F\u3000]/),
            s = [33, 34, 35, 37, 38, 39, 40, 41, 42, 44, 45, 46, 47, 58, 59, 63, 64, 91, 92, 93, 95, 123, 125, 161, 171, 173, 183, 187, 191];
        System.Array.resize = function(t, e, i) {
            if (e < 0) throw new System.ArgumentOutOfRangeException.$ctor3("newSize", e, "newSize cannot be less than 0.");
            let n = 0;
            const s = Bridge.isFunction(i);
            let r = !1,
                o = t.v;
            if (o) {
                const t = o;
                n = t.length, o = new Array(e);
                const i = Math.min(n, e);
                if (i > 0) {
                    const e = t[0];
                    r = e && "struct" === e.__proto__.$kind, o[0] = r ? e.$clone() : e
                }
                for (let e = 1; e < i; e++) o[e] = r ? t[e].$clone() : t[e]
            } else o = new Array(e);
            if (e > n) {
                const t = s ? i() : i;
                r = t && "struct" === t.__proto__.$kind, o[n] = r ? t.$clone() : t
            }
            for (let t = n + 1; t < e; t++) {
                let e = s ? i() : i;
                r && (e = e.$clone()), o[t] = e
            }
            t.v = o
        };
        const r = function(t, e) { this.o = t, this.n = e };
        Object.defineProperty(r.prototype, "v", { get: function() { return null == this.n ? this.o : this.o[this.n] }, set: function(t) { null == this.n && (t && t.$clone ? t.$clone(this.o) : this.o = t), this.o[this.n] = t } }), Bridge.ref = function(t, e) { return Bridge.isArray(e) && (e = System.Array.toIndex(t, e)), new r(t, e) }, System.Char.isWhiteSpace = function(t) { return " " === t || "\t" === t || "\n" === t || "\v" === t || "\f" === t || "\r" === t || "" === t || "" === t }, System.Char.isLetter = function(e) { return e < 256 ? e >= 65 && e <= 90 || e >= 97 && e <= 122 : t.test(String.fromCharCode(e)) }, System.Char.isDigit = function(t) { return t < 256 ? t >= 48 && t <= 57 : e.test(String.fromCharCode(t)) }, System.Char.isPunctuation = function(t) { return t < 256 ? -1 !== s.indexOf(t) : i.test(String.fromCharCode(t)) }, System.Char.isHighSurrogate = function(t) { return t >= 55296 && t <= 56319 }, System.Char.isLowSurrogate = function(t) { return t >= 56320 && t <= 57343 }, System.Char.isSurrogate = function(t) { return t >= 55296 && t <= 57343 }, System.Char.isSeparator = function(t) { return t < 256 ? 32 === t || 160 === t : n.test(String.fromCharCode(t)) }
    }(), Object.assign(pc, function() { const t = function(t, e) { this._videoWidth = 0, this._videoHeight = 0, this._frameCount = 0, this._frameRate = 24, void 0 !== e && (this._videoWidth = void 0 !== e.width ? e.width : this._videoWidth, this._videoHeight = void 0 !== e.height ? e.height : this._videoHeight, this._frameRate = void 0 !== e.frameRate ? e.frameRate : this._frameRate, this._frameCount = void 0 !== e.frameCount ? e.frameCount : this._frameCount), pc.Texture.prototype.constructor.call(this, t, e) }; return (t.prototype = Object.create(pc.Texture.prototype)).constructor = t, Object.defineProperty(t.prototype, "frameRate", { get: function() { return this._frameRate } }), Object.defineProperty(t.prototype, "frameCount", { get: function() { return this._frameCount } }), Object.defineProperty(t.prototype, "videoWidth", { get: function() { return this._videoWidth } }), Object.defineProperty(t.prototype, "videoHeight", { get: function() { return this._videoHeight } }), { VideoTexture: t } }()), pc.extend(pc, function() {
        const t = [new pc.Vec2(0, 1), new pc.Vec2(1, 1), new pc.Vec2(0, 0), new pc.Vec2(1, 0)],
            e = [0, 1, 2, 2, 1, 3];
        let i;
        const n = [!0, !1, !1, !1, !1, !1, !0, !1, !1, !1],
            s = function() { return this };
        return Object.defineProperty(s, "device", { get: function() { return i || (i = pc.Application.getApplication().graphicsDevice), i } }), s.createSpriteMesh = function(t) {
            const e = new pc.Mesh,
                i = new Float32Array(t.attributes.vertices),
                s = t.attributes.vertices.length / 5;
            return e.vertexBuffer = e.defaultVertexBuffer(n, s, i.buffer), e.setIndicies(t.attributes.triangles, UnityEngine.MeshTopology.Triangles, 0, !0, 0), e
        }, s.createQuadMesh = function(i) {
            const n = new pc.Mesh,
                s = i.pixelsPerUnit,
                r = i.pixelSize,
                o = i.getPivotNormalized(),
                a = new pc.Vec3(-o.x * r.x / s, -o.y * r.y / s, 0),
                c = new pc.Vec3((1 - o.x) * r.x / s, (1 - o.y) * r.y / s, 0),
                h = [new pc.Vec3(a.x, c.y, 0), new pc.Vec3(c.x, c.y, 0), new pc.Vec3(a.x, a.y, 0), new pc.Vec3(c.x, a.y, 0)];
            return n.setVectorStream({ _items: h, _size: h.length }, pc.SEMANTIC_POSITION, 3), n.setVectorStream({ _items: t, _size: t.length }, pc.SEMANTIC_TEXCOORD0, 2), n.setIndicies(e, UnityEngine.MeshTopology.Triangles, 0, !0, 0), n
        }, { SpriteUtils: s }
    }()), pc.extend(pc, function() {
        const t = function(t) { return this.attributes = t, this.$sprite = !0, this.mesh = null, this };
        return t.create = function(t, e, i, n, s, r, o) {
            const a = (e.z - e.x) / 2 / n,
                c = (e.w - e.y) / 2 / n;
            return new pc.Sprite({ aabb: { center: [0, 0, 0], halfExtents: [a, c, 0] }, border: o, bounds: [-a, -c, a, c], pixelsPerUnit: n, texture: t, textureRect: (new pc.Vec4).copy(e), transparency: new pc.Vec4(0, 0, 0, 0), triangles: [0, 1, 2, 2, 1, 3], vertices: [-a, c, 0, 0, 1, a, c, 0, 1, 1, -a, -c, 0, 0, 0, a, -c, 0, 1, 0], pivot: i.clone() })
        }, t.prototype = {
            getUvRect: function() {
                const t = this.textureRect,
                    e = this.texture;
                return new pc.Vec4(t.x / e.width, t.y / e.height, (t.z - t.x) / e.width, (t.w - t.y) / e.height)
            },
            getInnerUvRect: function() {
                const t = this.uvRect,
                    e = this.borderUv;
                return new pc.Vec4(t.x + e.x, t.y + e.y, t.x + t.z - e.z, t.y + t.w - e.w)
            },
            getOuterUvRect: function() { const t = this.uvRect; return new pc.Vec4(t.x, t.y, t.x + t.z, t.y + t.w) },
            getPivot: function() { return this.attributes.pivot },
            getPivotNormalized: function() { const t = this.attributes.textureRect; return new pc.Vec2((this.attributes.pivot.x - t.x) / t.z, (this.attributes.pivot.y - t.y) / t.w) },
            getAABB: function() { return this.attributes.aabb },
            getVertices: function() { const t = new Array(this.attributes.vertices.length / 5); for (let e = 0; e < t.length; e++) t[e] = new pc.Vec2(this.attributes.vertices[5 * e], this.attributes.vertices[5 * e + 1]); return t },
            getTriangles: function() { return this.attributes.triangles },
            getTextureRect: function() { return this.attributes.textureRect },
            getBorder: function() { return this.attributes.border },
            getBorderUnits: function() {
                const t = this.border,
                    e = this.pixelsPerUnit;
                return (new pc.Vec4).copy(t).scale(1 / e)
            },
            getBorderUv: function() {
                const t = this.uvRect,
                    e = this.border,
                    i = this.pixelSize;
                return new pc.Vec4(t.z * (e.x / i.x), t.w * (e.y / i.y), t.z * (e.z / i.x), t.w * (e.w / i.y))
            },
            getTexture: function() { return this.attributes.texture },
            getTransparency: function() { return this.attributes.transparency },
            getBounds: function() { return this.attributes.bounds },
            getPixelsPerUnit: function() { return this.attributes.pixelsPerUnit },
            getTextureRectOffset: function() { return this.attributes.textureRectOffset },
            getMesh: function() { return this.mesh || (this.mesh = this.attributes.vertices ? pc.SpriteUtils.createSpriteMesh(this) : pc.SpriteUtils.createQuadMesh(this)), this.mesh }
        }, Object.defineProperty(t.prototype, "pivotNormalized", { get: t.prototype.getPivotNormalized }), Object.defineProperty(t.prototype, "pivot", { get: t.prototype.getPivot }), Object.defineProperty(t.prototype, "aabb", { get: t.prototype.getAABB }), Object.defineProperty(t.prototype, "transparency", { get: t.prototype.getTransparency }), Object.defineProperty(t.prototype, "textureRect", { get: t.prototype.getTextureRect }), Object.defineProperty(t.prototype, "pixelsPerUnit", { get: t.prototype.getPixelsPerUnit }), Object.defineProperty(t.prototype, "texture", { get: t.prototype.getTexture }), Object.defineProperty(t.prototype, "border", { get: t.prototype.getBorder }), Object.defineProperty(t.prototype, "borderUv", { get: t.prototype.getBorderUv }), Object.defineProperty(t.prototype, "uvRect", { get: t.prototype.getUvRect }), Object.defineProperty(t.prototype, "vertices", { get: t.prototype.getVertices }), Object.defineProperty(t.prototype, "pixelSize", { get: function() { return new pc.Vec2(this.textureRect.z, this.textureRect.w) } }), { Sprite: t }
    }()),
    function() {
        function t() { this._seed = 1 }
        Object.assign(t.prototype, { setSeed: function(t) { this._seed = t }, nextInteger: function() { return this._seed = 16807 * this._seed % 2147483647 }, nextFloat: function() { return this.nextInteger() / 2147483647 }, nextGFloat: function() { return (this.nextFloat() + this.nextFloat() + this.nextFloat() + this.nextFloat() + this.nextFloat() + this.nextFloat()) / 6 } }), pc.Random = t
    }(),
    function() {
        function t() { this.value = 0 }
        t.prototype.update = function(t) { this.value += t }, t.prototype.take = function(t) { this.value >= t && (this.value -= t) }, Object.defineProperty(t.prototype, "accumulated", { get: function() { return Math.floor(this.value) } }), pc.IntAccumulator = t
    }(),
    function() {
        const t = 0,
            e = 1,
            i = function(e, i, n) { e = e || [], i = i || [], this.colorKeys = "object" != typeof e[0] ? this.formatColorKeys(e) : e, this.alphaKeys = "object" != typeof i[0] ? this.formatAlphaKeys(i) : i, this.mode = n || t },
            n = { lower: null, upper: null },
            s = { lower: null, upper: null };
        let r, o;
        i.prototype.sampleInplace = function(i, r) {
            if (this.findExtremeColors(i, n), this.findExtremeAlphaValues(i, s), n.lower === n.upper && s.lower === s.upper) return r.copy(n.lower.color), void(r.a = s.lower.alpha);
            switch (this.mode) {
                case e:
                    return void(n.lower.position === i ? (r.copy(n.lower.color), r.a = s.lower.alpha) : (r.copy(n.upper.color), r.a = s.upper.alpha));
                case t:
                    {
                        const t = (i - n.lower.time) / (n.upper.time - n.lower.time),
                            e = (i - s.lower.time) / (s.upper.time - s.lower.time);
                        return void this.lerpColorInPlace(n.lower.color, n.upper.color, s.lower.alpha, s.upper.alpha, t, e, r)
                    }
                default:
                    throw new System.NotSupportedException
            }
        }, i.prototype.evaluate = function(t) { const e = new pc.Color; return this.sampleInplace(t, e), e }, i.prototype.evaluateRef = function(t, e) { return this.sampleInplace(t, e), e }, i.prototype.findExtremeColors = function(t, e) {
            r = o = this.colorKeys[0];
            for (let e = 0; e < this.colorKeys.length; e++) {
                if (!(this.colorKeys[e].time < t)) { o = this.colorKeys[e]; break }
                r = o = this.colorKeys[e]
            }
            e.lower = r, e.upper = o
        }, i.prototype.findExtremeAlphaValues = function(t, e) {
            r = o = this.alphaKeys[0];
            for (let e = 0; e < this.alphaKeys.length; e++) {
                if (!(this.alphaKeys[e].time < t)) { o = this.alphaKeys[e]; break }
                r = o = this.alphaKeys[e]
            }
            e.lower = r, e.upper = o
        }, i.prototype.lerpColorInPlace = function(t, e, i, n, s, r, o) { o.r = pc.math.lerp(t.r, e.r, s), o.g = pc.math.lerp(t.g, e.g, s), o.b = pc.math.lerp(t.b, e.b, s), o.a = pc.math.lerp(i, n, r) }, i.prototype.formatColorKeys = function(t) {
            const e = [];
            for (let i = 0; i < t.length; i += 5) {
                const n = {};
                n.time = t[i], n.color = new pc.Color(t[i + 1], t[i + 2], t[i + 3], t[i + 4]), e.push(n)
            }
            return e
        }, i.prototype.formatAlphaKeys = function(t) {
            const e = [];
            for (let i = 0; i < t.length; i += 2) {
                const n = {};
                n.time = t[i], n.alpha = t[i + 1], e.push(n)
            }
            return e
        }, i.prototype.setKeys = function(t, e) { this.colorKeys = ("object" != typeof t[0] ? this.formatColorKeys(t) : t) || [], this.alphaKeys = ("object" != typeof e[0] ? this.formatAlphaKeys(e) : e) || [] }, i.prototype.setKey = function(t, e) {
            for (let e = 0; e < this.colorKeys.length; e++)
                if (this.colorKeys[e].time === t.time) { this.colorKeys[e] = t, t = null; break }
            null != t && this.colorKeys.push(t);
            for (let t = 0; t < this.alphaKeys.length; t++)
                if (this.alphaKeys[t].time === e.time) { this.alphaKeys[t] = e, e = null; break }
            null != e && this.alphaKeys.push(e)
        }, pc.ColorGradient = i
    }(),
    function() {
        const t = { Constant: 0, Curve: 1, TwoCurves: 2, TwoConstants: 3 },
            e = function(e, i, n) { "number" == typeof e && i instanceof pc.AnimationCurve && n instanceof pc.AnimationCurve ? this.init(0, 0, i, n, t.TwoCurves, e) : "number" == typeof e && "number" == typeof i ? this.init(e, i, new pc.AnimationCurve({}), new pc.AnimationCurve({}), t.TwoConstants, 1) : "number" == typeof e && i instanceof pc.AnimationCurve ? this.init(0, 0, new pc.AnimationCurve({}), i, t.Constant, e) : "number" == typeof e ? this.init(0, e, new pc.AnimationCurve({}), new pc.AnimationCurve({}), t.Constant, 1) : this.init(0, 0, new pc.AnimationCurve({}), new pc.AnimationCurve({}), t.Constant, 1) };
        e.prototype.init = function(t, e, i, n, s, r) { this.m_ConstantMax = e, this.m_ConstantMin = t, this.m_CurveMax = n, this.m_CurveMin = i, this.m_CurveMultiplier = r, this.m_Mode = s, this._random = new pc.Random }, Object.defineProperty(e.prototype, "mode", { get: function() { return this.m_Mode }, set: function(t) { this.m_Mode = t } }), Object.defineProperty(e.prototype, "constant", { get: function() { return this.m_ConstantMax }, set: function(t) { this.m_ConstantMax = t } }), Object.defineProperty(e.prototype, "constantMax", { get: function() { return this.m_ConstantMax }, set: function(t) { this.m_ConstantMax = t } }), Object.defineProperty(e.prototype, "constantMin", { get: function() { return this.m_ConstantMin }, set: function(t) { this.m_ConstantMin = t } }), Object.defineProperty(e.prototype, "curve", { get: function() { return this.m_CurveMax }, set: function(t) { this.m_CurveMax = t } }), Object.defineProperty(e.prototype, "curveMax", { get: function() { return this.m_CurveMax }, set: function(t) { this.m_CurveMax = t } }), Object.defineProperty(e.prototype, "curveMin", { get: function() { return this.m_CurveMin }, set: function(t) { this.m_CurveMin = t } }), Object.defineProperty(e.prototype, "curveMultiplier", { get: function() { return this.m_CurveMultiplier }, set: function(t) { this.m_CurveMultiplier = t } }), e.prototype.evaluate = function(e) {
            switch (this.mode) {
                case t.Constant:
                    return this._evaluateConstant();
                case t.Curve:
                    return this._evaluateCurve(e);
                case t.TwoConstants:
                    return this._evaluateTwoConstants(e, this._random.nextFloat());
                case t.TwoCurves:
                    return this._evaluateTwoCurves(e, this._random.nextFloat());
                default:
                    return null
            }
        }, e.prototype._evaluateConstant = function() { return this.m_ConstantMax }, e.prototype._evaluateCurve = function(t) { return this.m_CurveMax.value(t) * this.m_CurveMultiplier }, e.prototype._evaluateTwoCurves = function(t, e) {
            const i = this.m_CurveMin.value(t) * this.m_CurveMultiplier,
                n = this.m_CurveMax.value(t) * this.m_CurveMultiplier;
            return pc.math.lerp(i, n, e)
        }, e.prototype._evaluateTwoConstants = function(t, e) { return pc.math.lerp(this.m_ConstantMin, this.constantMax, e) }, pc.MinMaxCurveMode = t, pc.MinMaxCurve = e
    }(),
    function() {
        const t = new pc.Color,
            e = new pc.Color,
            i = { Color: 0, Gradient: 1, TwoColors: 2, TwoGradients: 3, RandomColor: 4 },
            n = function(t, e) { t instanceof pc.Color && e instanceof pc.Color ? this.init(t, e, new pc.ColorGradient, new pc.ColorGradient, i.TwoColors) : t instanceof pc.ColorGradient && e instanceof pc.ColorGradient ? this.init(0, 0, t, e, i.TwoGradients) : t instanceof pc.Color ? this.init(0, t, new pc.ColorGradient, new pc.ColorGradient, i.Color) : t instanceof pc.ColorGradient ? this.init(0, 0, new pc.ColorGradient, t, i.Gradient) : this.init(0, 0, new pc.ColorGradient, new pc.ColorGradient, i.Color) };
        n.prototype.init = function(t, e, i, n, s) { return this.m_ColorMax = e, this.m_ColorMin = t, this.m_GradientMax = n, this.m_GradientMin = i, this.m_Mode = s, this._random = new pc.Random, this }, Object.defineProperty(n.prototype, "mode", { get: function() { return this.m_Mode }, set: function(t) { this.m_Mode = t } }), Object.defineProperty(n.prototype, "color", { get: function() { return this.m_ColorMax }, set: function(t) { this.m_ColorMax = t } }), Object.defineProperty(n.prototype, "colorMin", { get: function() { return this.m_ColorMin }, set: function(t) { this.m_ColorMin = t } }), Object.defineProperty(n.prototype, "colorMax", { get: function() { return this.m_ColorMax }, set: function(t) { this.m_ColorMax = t } }), Object.defineProperty(n.prototype, "gradient", { get: function() { return this.m_GradientMax }, set: function(t) { this.m_GradientMax = t } }), Object.defineProperty(n.prototype, "gradientMax", { get: function() { return this.m_GradientMax }, set: function(t) { this.m_GradientMax = t } }), Object.defineProperty(n.prototype, "gradientMin", { get: function() { return this.m_GradientMin }, set: function(t) { this.m_GradientMin = t } }), n.prototype.evaluate = function(t) {
            const e = new pc.Color(1, 1, 1, 1);
            switch (this.mode) {
                case i.Color:
                    this._evaluateColorInplace(e);
                    break;
                case i.Gradient:
                    this._evaluateGradientInplace(t, e);
                    break;
                case i.TwoColors:
                    this._evaluateTwoColorsInplace(t, e);
                    break;
                case i.TwoGradients:
                    this._evaluateTwoGradientsInplace(t, e);
                    break;
                case i.RandomColor:
                    this._evaluateGradientInplace(this._random.nextFloat(), e)
            }
            return e
        }, n.prototype.evaluateInplace = function(t, e) {
            switch (this.mode) {
                case i.Color:
                    this._evaluateColorInplace(e);
                    break;
                case i.Gradient:
                    this._evaluateGradientInplace(t, e);
                    break;
                case i.TwoColors:
                    this._evaluateTwoColorsInplace(t, e);
                    break;
                case i.TwoGradients:
                    this._evaluateTwoGradientsInplace(t, e);
                    break;
                case i.RandomColor:
                    this._evaluateGradientInplace(this._random.nextFloat(), e)
            }
        }, n.prototype._evaluateColorInplace = function(t) { t.copy(this.m_ColorMax) }, n.prototype._evaluateGradientInplace = function(t, e) { this.gradient.sampleInplace(t, e) }, n.prototype._evaluateTwoGradientsInplace = function(i, n) {
            this.gradientMin.sampleInplace(i, t), this.gradientMax.sampleInplace(i, e);
            const s = this._random.nextFloat();
            n.copy(t).lerpTo(e, s)
        }, n.prototype._evaluateTwoColorsInplace = function(t, e) {
            const i = this._random.nextFloat();
            e.copy(this.colorMin).lerpTo(this.m_ColorMax, i)
        }, pc.MinMaxGradientMode = i, pc.MinMaxGradient = n
    }(),
    function() {
        const t = new pc.Vec3;

        function e() { this.t = new pc.Vec3, this.r = new pc.Quat, this.s = new pc.Vec3, this.ownSpeed = new pc.Vec3, this.totalSpeed = new pc.Vec3, this.initialScale = new pc.Vec3, this.tmpScale = new pc.Vec3(1, 1, 1), this.angularVelocity = new pc.Vec3, this.startRotationAxis = new pc.Vec3(0, 0, 1), this.color = new pc.Color(1, 1, 1, 1), this.startColor = new pc.Color(1, 1, 1, 1), this.texSheetAnimationInitialized = !1, this.lifetime = 0, this.elapsedTime = 0, this.birthTimeOffset = 0, this.velocityOverLifetimeValue = t, this.rotationOverLifetimeValue = t, this.colorOverLifetimeValue = t, this.colorBySpeedValue = t, this.sizeOverLifetimeValue = t, this.inheritVelocityValue = t, this.forceOverLifetimeValue = t }
        Object.defineProperty(e.prototype, "lifePart", { get: function() { return this.elapsedTime / this.lifetime } }), Object.defineProperty(e.prototype, "isAlive", { get: function() { return this.elapsedTime < this.lifetime } }), e.prototype.initialize = function(t) { this.t.copy(t.translation), this.r.copy(t.rotation), this.s.copy(t.scale), this.initialScale.copy(t.scale), t.startRotationAxis && this.startRotationAxis.copy(t.startRotationAxis), this.ownSpeed.copy(t.speed), this.color.copy(t.color), this.startColor.copy(t.color), this.lifetime = t.lifetime, this.elapsedTime = 0, this.startFrame = null, this.tmpScale.set(1, 1, 1), this.velocityOverLifetimeValue = null, this.rotationOverLifetimeValue = null, this.colorOverLifetimeValue = null, this.colorBySpeedValue = null, this.sizeOverLifetimeValue = null, this.inheritVelocityValue = null, this.forceOverLifetimeValue = null, this.birthTimeOffset = t.birthTimeOffset, this.texSheetAnimationInitialized = !1, this.angularVelocity.set(0, 0, 0), this.totalSpeed.set(0, 0, 0) }, e.prototype.copy = function(t) { this.t.copy(t.t), this.r.copy(t.r), this.s.copy(t.s), this.ownSpeed.copy(t.ownSpeed), this.totalSpeed.copy(t.totalSpeed), this.initialScale.copy(t.initialScale), this.tmpScale.copy(t.tmpScale), this.angularVelocity.copy(t.angularVelocity), this.color.copy(t.color), this.startColor.copy(t.startColor), this.texSheetAnimationInitialized = t.texSheetAnimationInitialized, this.lifetime = t.lifetime, this.elapsedTime = t.elapsedTime, this.startRotationAxis.copy(t.startRotationAxis), t.velocityOverLifetimeValue ? this.velocityOverLifetimeValue = (new pc.Vec3).copy(t.velocityOverLifetimeValue) : this.velocityOverLifetimeValue = null, t.rotationOverLifetimeValue ? this.rotationOverLifetimeValue = (new pc.Vec3).copy(t.rotationOverLifetimeValue) : this.rotationOverLifetimeValue = null, t.colorOverLifetimeValue ? this.colorOverLifetimeValue = (new pc.Vec3).copy(t.colorOverLifetimeValue) : this.colorOverLifetimeValue = null, t.colorBySpeedValue ? this.colorBySpeedValue = (new pc.Vec3).copy(t.colorBySpeedValue) : this.colorBySpeedValue = null, t.sizeOverLifetimeValue ? this.sizeOverLifetimeValue = (new pc.Vec3).copy(t.sizeOverLifetimeValue) : this.sizeOverLifetimeValue = null, t.inheritVelocityValue ? this.inheritVelocityValue = (new pc.Vec3).copy(t.inheritVelocityValue) : this.inheritVelocityValue = null, t.forceOverLifetimeValue ? this.forceOverLifetimeValue = (new pc.Vec3).copy(t.forceOverLifetimeValue) : this.forceOverLifetimeValue = null }, e.prototype.GetCurrentSize3D = function(t) { return this.tmpScale.copy(this.initialScale), null != t.sizeOverLifetime && t.sizeOverLifetime.enabled && t.sizeOverLifetime.processInplace(this), null != t.sizeBySpeed && t.sizeBySpeed.enabled && t.sizeBySpeed.processInplace(this), this.tmpScale }, e.prototype.GetCurrentColor = function(t) { return this.color.copy(this.startColor), null != t.colorOverLifetime && t.colorOverLifetime.enabled && t.colorOverLifetime.processInplace(this), null != t.colorBySpeed && t.colorBySpeed.enabled && t.colorBySpeed.processInplace(this), this.color }, pc.Particle = e
    }(),
    function() {
        function t(t) { this._particles = [], this.aliveCount = 0, this._maxParticles = t || 0 }
        Object.defineProperty(t.prototype, "maxParticles", { get: function() { return this._maxParticles }, set: function(t) { this._maxParticles = t } }), Object.defineProperty(t.prototype, "aliveCount", { get: function() { return this._aliveCount }, set: function(t) { this._aliveCount = t } }), t.prototype.resize = function(t) {
            if (t = Math.min(Math.max(t, 1), this.maxParticles), this._particles.length < t) {
                const e = new Array(t);
                let i = 0;
                for (i = 0; i < this._particles.length; ++i) e[i] = this._particles[i];
                for (; i < t; ++i) e[i] = new pc.Particle;
                this._particles = e
            }
        }, t.prototype.get = function(t) { return this._particles.length <= t && this._particles.length < this.maxParticles && this.resize(2 * this._particles.length), this._particles[t] }, t.prototype.acquire = function() { if (this.aliveCount < this.maxParticles) { this.aliveCount >= this._particles.length && this.resize(2 * this._particles.length); const t = this._particles[this.aliveCount]; return t._cacheIndex = this.aliveCount, this.aliveCount++, t } return null }, t.prototype.release = function(t) {
            const e = t._cacheIndex,
                i = this.aliveCount - 1,
                n = this._particles[e];
            this._particles[e] = this._particles[i], this._particles[e]._cacheIndex = e, this._particles[i] = n, --this.aliveCount
        }, t.prototype.clear = function() { this.aliveCount = 0 }, t.prototype.dispose = function() { this._particles = null, this.aliveCount = 0, this.maxParticles = 0 }, pc.ParticleCache = t
    }(),
    function() {
        const t = { translation: new pc.Vec3, rotation: new pc.Quat, startRotationAxis: new pc.Vec3, scale: new pc.Vec3, direction: new pc.Vec3, speed: new pc.Vec3, lifetime: 0, color: new pc.Color },
            e = new pc.Quat,
            i = new pc.Vec3,
            n = new pc.Vec3,
            s = new pc.Mat4,
            r = new pc.Vec3,
            o = new pc.Vec3,
            a = new pc.Quat;

        function c() { this._entity = null, this._random = new pc.Random, this._cache = new pc.ParticleCache, this._shouldEmit = !1, this._paused = !1, this._lifetime = 0, this._playTime = 0, this.delayTimer = 0, this._emittedCount = 0, this._previousPosition = new pc.Vec3, this._currentVelocity = new pc.Vec3, this._scaleFactor = new pc.Vec3, this.events = new pc.Events(this), this.colorBySpeed = new pc.ParticleSystemColorBySpeed(this), this.colorOverLifetime = new pc.ParticleSystemColorOverLifetime(this), this.emission = new pc.ParticleSystemEmitter(this), this.main = new pc.ParticleSystemMain(this), this.rotationBySpeed = new pc.ParticleSystemRotationBySpeed(this), this.rotationOverLifetime = new pc.ParticleSystemRotationOverLifetime(this), this.shape = new pc.ParticleSystemShape(this), this.sizeBySpeed = new pc.ParticleSystemSizeBySpeed(this), this.sizeOverLifetime = new pc.ParticleSystemSizeOverLifetime(this), this.textureSheetAnimation = new pc.ParticleSystemTextureSheetAnimation(this), this.velocityOverLifetime = new pc.ParticleSystemVelocityOverLifetime(this), this.noise = new pc.ParticleSystemNoise(this), this.inheritVelocity = new pc.ParticleSystemInheritVelocity(this), this.forceOverLifetime = new pc.ParticleSystemForceOverLifetime(this), this.limitVelocityOverLifetime = new pc.ParticleSystemLimitVelocityOverLifetime(this) }
        Object.defineProperty(c.prototype, "isActive", { get: function() { return this._shouldEmit || this._cache.aliveCount > 0 } }), Object.defineProperty(c.prototype, "entity", { get: function() { return this._entity } }), Object.defineProperty(c.prototype, "lifePart", { get: function() { return this._lifetime / this.main.duration } }), Object.defineProperty(c.prototype, "lifetime", { get: function() { return this._lifetime }, set: function(t) { return this._lifetime = t, t } }), Object.defineProperty(c.prototype, "particleCount", { get: function() { return this._cache.aliveCount } }), Object.defineProperty(c.prototype, "emittedParticlesCount", { get: function() { return this._emittedCount } }), Object.defineProperty(c.prototype, "main", { get: function() { return this._mainModule }, set: function(t) { return this._mainModule = t, t } }), Object.defineProperty(c.prototype, "emission", { get: function() { return this._emission }, set: function(t) { return this._emission = t, t } }), Object.defineProperty(c.prototype, "shape", { get: function() { return this._shapeModule }, set: function(t) { return this._shapeModule = t, t } }), Object.defineProperty(c.prototype, "velocityOverLifetime", { get: function() { return this._velocityOverLifetimeModule }, set: function(t) { return this._velocityOverLifetimeModule = t, t } }), Object.defineProperty(c.prototype, "colorOverLifetime", { get: function() { return this._colorOverLifetimeModule }, set: function(t) { return this._colorOverLifetimeModule = t, t } }), Object.defineProperty(c.prototype, "colorBySpeed", { get: function() { return this._colorBySpeedModule }, set: function(t) { return this._colorBySpeedModule = t, t } }), Object.defineProperty(c.prototype, "sizeOverLifetime", { get: function() { return this._sizeOverLifetimeModule }, set: function(t) { return this._sizeOverLifetimeModule = t, t } }), Object.defineProperty(c.prototype, "sizeBySpeed", { get: function() { return this._sizeBySpeedModule }, set: function(t) { return this._sizeBySpeedModule = t, t } }), Object.defineProperty(c.prototype, "rotationOverLifetime", { get: function() { return this._rotationOverLifetimeModule }, set: function(t) { return this._rotationOverLifetimeModule = t, t } }), Object.defineProperty(c.prototype, "rotationBySpeed", { get: function() { return this._rotationBySpeedModule }, set: function(t) { return this._rotationBySpeedModule = t, t } }), Object.defineProperty(c.prototype, "textureSheetAnimation", { get: function() { return this._textureSheetAnimationModule }, set: function(t) { return this._textureSheetAnimationModule = t, t } }), Object.defineProperty(c.prototype, "time", { get: function() { return this._playTime } }), Object.defineProperty(c.prototype, "currentVelocity", { get: function() { return this._currentVelocity } }), Object.defineProperty(c.prototype, "isPaused", { get: function() { return this._paused } }), Object.defineProperty(c.prototype, "isPlaying", { get: function() { return this.isActive && !this._paused } }), Object.defineProperty(c.prototype, "isStopped", { get: function() { return !this._shouldEmit } }), Object.defineProperty(c.prototype, "isEmitting", { get: function() { return this._shouldEmit } }), c.prototype.isAlive = function(t) { const e = { res: this.isActive }; return this.doOnChildren(t, (function(t, e) { e.res = e.res && t.isAlive }), e), e.res }, c.prototype.clear = function() { this._cache.clear() }, c.prototype.stop = function(t, e) {
            switch (t = void 0 === t || t, e = void 0 === e ? UnityEngine.ParticleSystemStopBehavior.StopEmitting : e) {
                case UnityEngine.ParticleSystemStopBehavior.StopEmittingAndClear:
                    this._shouldEmit = !1, this.clear();
                    break;
                case UnityEngine.ParticleSystemStopBehavior.StopEmitting:
                default:
                    this._shouldEmit = !1
            }
            this.doOnChildren(t, (function(t) { t.stop(!1) }))
        }, c.prototype.pause = function(t) { this._paused = !0 }, c.prototype.play = function(t) {
            if (this._paused) return void(this._paused = !1);
            this._shouldEmit = !0, this._paused = !1, this._lifetime = 0, this.delayTimer = 0, this._playTime = 0, this.emission.lastSpawnTime_rate = 0, this.emission.reinitBurstData(), t = void 0 === t || t;
            this.doOnChildren(t, (function(t) { t.play(!1) })), this._mainModule.prewarm && this.prewarm()
        }, c.prototype.prewarm = function() {
            const t = this._mainModule.startLifetime.evaluate(this.lifePart);
            this.runSimulation(t, !0)
        }, c.prototype.simulate = function(t, e, i, n) {
            i && this.stop(e, UnityEngine.ParticleSystemStopBehavior.StopEmittingAndClear), this._paused = !1, this.isActive || this.play(!1), this.runSimulation(t, n), this.pause();
            const s = { time: t, withChildren: e, restart: i, fixedTimeStep: n };
            this.doOnChildren(e, (function(t, e) { t.simulate(e.time, e.withChildren, e.restart, e.fixedTimeStep) }), s)
        }, c.prototype.runSimulation = function(t, e) {
            const i = e ? UnityEngine.Time.fixedDeltaTime : .0333,
                n = this._entity.getWorldTransform();
            let s = 0,
                r = 0;
            for (; s < t;) r = Math.min(t - s, i), this.update(r, n), s += r
        }, c.prototype.updateCurrentVelocity = function(t) {
            const e = this._entity._unityComponents.rigidbody[0];
            this.main.emitterVelocityMode === UnityEngine.ParticleSystemEmitterVelocityMode.Rigidbody && e ? this._currentVelocity.copy(e.velocity) : (r.copy(this._entity.getPosition()), this._currentVelocity.copy(r).sub(this._previousPosition).scale(1 / t), this._previousPosition.copy(r))
        }, c.prototype.createParticle = function(i, n) {
            t.translation.copy(pc.Vec3.ZERO), t.rotation.copy(pc.Quat.IDENTITY), t.scale.x = t.scale.y = t.scale.z = 1, t.direction.copy(pc.Vec3.BACK);
            const s = this._cache.acquire();
            ++this._emittedCount;
            const r = this.lifePart;
            null != this.shape && this.shape.enabled && this.shape.applyNextTransform(t.translation, t.rotation, t.direction), this._mainModule.simulationSpace === UnityEngine.ParticleSystemSimulationSpace.World && (i.transformPoint(t.translation, t.translation), i.transformVector(t.direction, t.direction), t.direction.normalize());
            const o = this._entity._unityComponents.particleSystemRenderer[0]._particleSystemRenderer._renderMode;
            o !== UnityEngine.ParticleSystemRenderMode.Stretch && (this.main.startRotation3D ? e.setFromEulerAngles(this.main.startRotationX.evaluate(r) * pc.math.RAD_TO_DEG, this.main.startRotationY.evaluate(r) * pc.math.RAD_TO_DEG, this.main.startRotationZ.evaluate(r) * pc.math.RAD_TO_DEG) : (o === UnityEngine.ParticleSystemRenderMode.Billboard ? t.startRotationAxis.copy(t.rotation.transformVector(pc.Vec3.FORWARD)).normalize() : (t.startRotationAxis.x = this._random.nextFloat() - .5, t.startRotationAxis.y = this._random.nextFloat() - .5, t.startRotationAxis.z = this._random.nextFloat() - .5, t.startRotationAxis.normalize()), e.setFromAxisAngle(t.startRotationAxis, this.main.startRotation.evaluate(r) * pc.math.RAD_TO_DEG))), t.rotation.mul(e), this.main.startSize3D ? (t.scale.x = this.main.startSizeX.evaluate(r), t.scale.y = this.main.startSizeY.evaluate(r), t.scale.z = this.main.startSizeZ.evaluate(r)) : t.scale.copy(pc.Vec3.ONE).scale(this.main.startSize.evaluate(r));
            const a = Math.abs(this.main.startSpeed.evaluate(r));
            return t.speed.copy(t.direction).scale(a), this.main.startColor.evaluateInplace(r, t.color), t.lifetime = this.main.startLifetime.evaluate(r), t.birthTimeOffset = n, s.initialize(t), s
        }, c.prototype._updateParticles = function(t, e) {
            this.main.simulationSpace === UnityEngine.ParticleSystemSimulationSpace.Local && (s.copy(e).invert(), s.transformVector(n, n)), this._updateScaleFactor();
            for (let e = 0; e < this._cache.aliveCount; ++e) {
                const i = this._cache.get(e);
                this._processParticle(i, t, this._scaleFactor, this._cache, s)
            }
        }, c.prototype._processParticle = function(t, e, s, r, c) {
            t.tmpScale.copy(t.initialScale), t.color.copy(t.startColor), (this.rotationOverLifetime.enabled || this.rotationBySpeed.enabled) && t.angularVelocity.set(0, 0, 0), 0 !== t.birthTimeOffset && (e = t.birthTimeOffset, t.birthTimeOffset = 0);
            const h = this.main.gravityModifier.evaluate(this.lifePart);
            n.copy(UnityEngine.Physics.gravity), n.scale(h).scale(e), c.transformVector(n, n), t.ownSpeed.add(n), t.totalSpeed.copy(t.ownSpeed), this.inheritVelocity.enabled && this.inheritVelocity.processInplace(t, e), this.forceOverLifetime.enabled && this.forceOverLifetime.processInplace(t, e), this.velocityOverLifetime.enabled && this.velocityOverLifetime.processInplace(t, e), this.colorOverLifetime.enabled && this.colorOverLifetime.processInplace(t, e), this.colorBySpeed.enabled && this.colorBySpeed.processInplace(t, e), this.rotationOverLifetime.enabled && this.rotationOverLifetime.processInplace(t, e), this.rotationBySpeed.enabled && this.rotationBySpeed.processInplace(t, e), this.sizeOverLifetime.enabled && this.sizeOverLifetime.processInplace(t, e), this.sizeBySpeed.enabled && this.sizeBySpeed.processInplace(t, e), this.textureSheetAnimation.enabled && this.textureSheetAnimation.processInplace(t, e), this.noise.enabled && this.noise.processInplace(t, e), this.limitVelocityOverLifetime.enabled && this.limitVelocityOverLifetime.processInplace(t, e), o.copy(t.angularVelocity), o.scale(e), a.setFromEulerAngles(o.x, o.y, o.z), t.totalSpeed.mul2(t.totalSpeed, s), t.t.add(i.copy(t.totalSpeed).scale(e)), t.r.mul(a), t.s.copy(t.tmpScale), t.elapsedTime += e
        }, c.prototype._updateScaleFactor = function() { this._scaleFactor.copy(pc.Vec3.ONE), this.main.scalingMode === UnityEngine.ParticleSystemScalingMode.Hierarchy ? this._scaleFactor.copy(this._entity.getLossyScale()) : this.main.scalingMode === UnityEngine.ParticleSystemScalingMode.Local && this._scaleFactor.copy(this._entity.getLocalScale()) }, c.prototype.emit = function(t) { const e = pc.math.clamp(t, 0, this._mainModule.maxParticles - this._cache.aliveCount); if (e > 0) { const t = this._entity.getWorldTransform(); for (let i = 0; i < e; ++i) this.createParticle(t, 0) } }, c.prototype.update = function(t, e) {
            if (!this.isActive || this._paused) return;
            let i = t;
            i *= this.main.simulationSpeed, this.main.useUnscaledTime || (i *= UnityEngine.Time.timeScale), this.delayTimer < this.main.startDelay.evaluate(0) ? this.delayTimer += i : (this._lifetime += i, this._playTime += i, this._lifetime > this.main.duration && this.main.loop && (this._lifetime -= this.main.duration, this.events.fire("ParticleSystemNewLoop")), this.lifetime > this.main.duration && !this.main.loop && (this._shouldEmit = !1), this.updateCurrentVelocity(t), this.cleanupOldParticles(), this._shouldEmit && null != this.emission && this.emission.enabled && this.emission.update(i, e), this._updateParticles(i, e))
        }, c.prototype.cleanupOldParticles = function() {
            for (let t = this._cache.aliveCount - 1; t >= 0; --t) {
                const e = this._cache.get(t);
                e.elapsedTime > e.lifetime && this._cache.release(e)
            }
        }, c.prototype.doOnChildren = function(t, e, i) {
            if (t && this._entity) {
                const t = this._entity.allChildren();
                for (let n = 0; n < t.length; n++) {
                    const s = t[n]._unityComponents.particlesystem[0];
                    s && e(s._particleSystem, i)
                }
            }
        }, c.prototype.getParticles = function(t) { if (!t) return null; const e = Math.min(this._cache.aliveCount, t.length); for (let i = 0; i < e; i++) t[i].Handle.copy(this._cache.get(i)); return e }, c.prototype.setParticles = function(t, e) {
            if (!t) return;
            const i = Math.min(this.main.maxParticles, e, t.length);
            for (let e = 0; e < i; e++) { this._cache.get(e).copy(t[e].Handle) }
            this.main.simulationSpace === UnityEngine.ParticleSystemSimulationSpace.Local && this._entity.transformVectorInverse(n, n);
            for (let t = 0; t < this._cache.aliveCount; ++t) {
                const e = this._cache.get(t);
                this._processParticle(e, 0, this._scaleFactor, this._cache, s)
            }
        }, pc.ParticleSystem = c
    }(),
    function() {
        let t = null,
            e = null;
        const i = new pc.Vec3;
        let n = new pc.Vec3;
        const s = new pc.Vec3,
            r = new pc.Vec3,
            o = new Float32Array([-.5, -.5, 0, 1, 1, 1, 1, 0, 0, -.5, .5, 0, 1, 1, 1, 1, 0, 1, .5, .5, 0, 1, 1, 1, 1, 1, 1, .5, -.5, 0, 1, 1, 1, 1, 1, 0]),
            a = new Float32Array([-.5, -1, 0, 1, 1, 1, 1, 0, 0, -.5, 0, 0, 1, 1, 1, 1, 0, 1, .5, 0, 0, 1, 1, 1, 1, 1, 1, .5, -1, 0, 1, 1, 1, 1, 1, 0]),
            c = new Uint16Array([0, 1, 2, 2, 3, 0]),
            h = [{ semantic: pc.SEMANTIC_POSITION, components: 3, type: pc.TYPE_FLOAT32 }, { semantic: pc.SEMANTIC_COLOR, components: 4, type: pc.TYPE_FLOAT32 }, { semantic: pc.SEMANTIC_TEXCOORD0, components: 2, type: pc.TYPE_FLOAT32 }],
            l = [{ semantic: pc.SEMANTIC_TEXCOORD5, components: 3, type: pc.TYPE_FLOAT32 }, { semantic: pc.SEMANTIC_TEXCOORD6, components: 4, type: pc.TYPE_FLOAT32 }, { semantic: pc.SEMANTIC_TEXCOORD7, components: 3, type: pc.TYPE_FLOAT32 }, { semantic: pc.SEMANTIC_ATTR0, components: 4, type: pc.TYPE_FLOAT32 }, { semantic: pc.SEMANTIC_ATTR1, components: 4, type: pc.TYPE_FLOAT32 }];

        function u() { this.model = new pc.Model, this.configuration = new pc.Vec4, this._modelVersion = 0, this._lastModelVersion = 1, this.worldRotationTransform = new pc.Mat4, this.worldTranslationTransform = new pc.Mat4 }
        Object.defineProperty(u.prototype, "sharedMaterials", { get: function() { return this._materials }, set: function(t) { this._materials = t, this._lastModelVersion++ } }), Object.defineProperty(u.prototype, "mesh", { get: function() { return this._mesh }, set: function(t) { this._mesh = t, this._lastModelVersion++ } }), Object.defineProperty(u.prototype, "alignment", { get: function() { return this._alignment }, set: function(t) { this._alignment = t } }), Object.defineProperty(u.prototype, "renderMode", { get: function() { return this._renderMode }, set: function(t) { this._renderMode = t, this._lastModelVersion++ } }), Object.defineProperty(u.prototype, "lengthScale", { get: function() { return this._lengthScale }, set: function(t) { this._lengthScale = t } }), Object.defineProperty(u.prototype, "velocityScale", { get: function() { return this._velocityScale }, set: function(t) { this._velocityScale = t } }), Object.defineProperty(u.prototype, "cameraVelocityScale", { get: function() { return this._cameraVelocityScale }, set: function(t) { this._cameraVelocityScale = t } }), Object.defineProperty(u.prototype, "normalDirection", { get: function() { return this._normalDirection }, set: function(t) { this._normalDirection = t } }), Object.defineProperty(u.prototype, "sortingOrder", { get: function() { return this.model.sortingOrder }, set: function(t) { this.model.sortingOrder = t } }), Object.defineProperty(u.prototype, "sortingLayerIndex", { get: function() { return this.model.sortingLayerIndex }, set: function(t) { this.model.sortingLayerIndex = t } }), Object.defineProperty(u.prototype, "sortingLayerName", { get: function() { return UnityEngine.SortingLayer.GetLayerNameFromValue(this.model.sortingLayerIndex) }, set: function(t) { this.model.sortingLayerIndex = UnityEngine.SortingLayer.GetLayerValueFromName(t) } }), Object.defineProperty(u.prototype, "sortingFudge", { get: function() { return this._sortingFudge }, set: function(t) { this._sortingFudge = t } }), Object.defineProperty(u.prototype, "minParticleSize", { get: function() { return this._minParticleSize }, set: function(t) { this._minParticleSize = t } }), Object.defineProperty(u.prototype, "maxParticleSize", { get: function() { return this._maxParticleSize }, set: function(t) { this._maxParticleSize = t } }), Object.defineProperty(u.prototype, "pivot", { get: function() { return this._pivot }, set: function(t) { this._pivot = t } }), Object.defineProperty(u.prototype, "trailMaterial", { get: function() { return this._trailMaterial }, set: function(t) { this._trailMaterial = t } }), Object.defineProperty(u.prototype, "sortMode", { get: function() { return this._sortMode }, set: function(t) { this._sortMode = t } }), Object.defineProperty(u.prototype, "activeVertexStreamsCount", { get: function() { return this._activeVertexStreamsCount }, set: function(t) { this._activeVertexStreamsCount = t } }), Object.assign(u.prototype, {
            _configureModel: function() {
                switch (this._modelVersion = this._lastModelVersion, this.renderMode) {
                    case UnityEngine.ParticleSystemRenderMode.Billboard:
                    case UnityEngine.ParticleSystemRenderMode.Stretch:
                    case UnityEngine.ParticleSystemRenderMode.HorizontalBillboard:
                    case UnityEngine.ParticleSystemRenderMode.VerticalBillboard:
                        this.model.mesh = this._prepareBillboardMesh();
                        break;
                    case UnityEngine.ParticleSystemRenderMode.Mesh:
                        this.model.mesh = this._mesh ? this._mesh.handle : null;
                        break;
                    case UnityEngine.ParticleSystemRenderMode.None:
                        this.model.mesh = null
                }
                if (this._materials && this._materials.length > 0) {
                    const t = [];
                    for (let e = 0; e < this._materials.length; e++) {
                        if (1 === e) continue;
                        const i = this._materials[e];
                        i ? t.push(i.handle) : console.error(`Particle system "${this.model.entity.name}" has NULL materials and won't be rendered`)
                    }
                    this.model.materials = t
                } else this.model.materials = [];
                this.model.update();
                const t = this.model.meshInstances;
                for (let e = 0; e < t.length; e++) {
                    const i = t[e];
                    i.instancingData = this._prepareInstancingData(), i.constAttributes.COLOR = [1, 1, 1, 1], i._shaderDefs |= pc.SHADERDEF_PARTICLES_INSTANCING
                }
            },
            _prepareInstancingData: function() {
                if (!this._instancingData) {
                    const t = pc.Application.getApplication();
                    this._instancingVertexFormat = new pc.VertexFormat(t.graphicsDevice, l), this._instancingData = { _buffer: new pc.VertexBuffer(t.graphicsDevice, this._instancingVertexFormat, 0, pc.BUFFER_DYNAMIC, new Float32Array(0)), count: 0, offset: 0 }
                }
                return this._instancingData
            },
            _prepareQuad: function(t) {
                const e = pc.Application.getApplication(),
                    i = new pc.Mesh,
                    n = new pc.VertexFormat(e.graphicsDevice, h),
                    s = t;
                return i.vertexBuffer = new pc.VertexBuffer(e.graphicsDevice, n, 4, pc.BUFFER_STATIC, s), i.indexBuffer[0] = new pc.IndexBuffer(e.graphicsDevice, pc.INDEXFORMAT_UINT16, 6, pc.BUFFER_STATIC, c), i.primitive[0].type = pc.PRIMITIVE_TRIANGLES, i.primitive[0].base = 0, i.primitive[0].count = 6, i.primitive[0].indexed = !0, i.subMeshes = [i], i
            },
            _prepareBillboardMesh: function() { return null === t && (t = this._prepareQuad(o)), null === e && (e = this._prepareQuad(a)), this.renderMode === UnityEngine.ParticleSystemRenderMode.Stretch ? e : t },
            _resizeInstancingBuffer: function(t) { this._instancingData && (t > this._instancingData._buffer.numVertices && this._instancingData._buffer.resize(t), this._instancingData.count = t) },
            _updateInstancingData: function(t, e) {
                const i = this.model.meshInstances;
                if (0 === i.length) return;
                const n = this._instancingData._buffer,
                    o = new Float32Array(n.lock());
                s.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), r.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
                for (let i = 0; i < e.aliveCount; i++) {
                    const n = this._instancingVertexFormat.size / 4 * i,
                        a = e.get(i),
                        c = a.t;
                    s.x = Math.min(s.x, c.x), s.y = Math.min(s.y, c.y), s.z = Math.min(s.z, c.z), r.x = Math.max(r.x, c.x), r.y = Math.max(r.y, c.y), r.z = Math.max(r.z, c.z), o[n + 0] = a.t.x, o[n + 1] = a.t.y, o[n + 2] = a.t.z, o[n + 3] = a.r.x, o[n + 4] = a.r.y, o[n + 5] = a.r.z, o[n + 6] = a.r.w, this.renderMode === UnityEngine.ParticleSystemRenderMode.Stretch ? (o[n + 7] = a.s.x, o[n + 8] = a.totalSpeed.length() * this.velocityScale + this.lengthScale * a.s.y, o[n + 9] = a.s.z) : (o[n + 7] = a.s.x, o[n + 8] = a.s.y, o[n + 9] = a.s.z), o[n + 10] = a.color.r, o[n + 11] = a.color.g, o[n + 12] = a.color.b, o[n + 13] = a.color.a, null != t.textureSheetAnimation && t.textureSheetAnimation.enabled ? (o[n + 14] = 1 / t.textureSheetAnimation.numTilesX, o[n + 15] = 1 / t.textureSheetAnimation.numTilesY, o[n + 16] = a.texSheetColumn, o[n + 17] = t.textureSheetAnimation.numTilesY - a.texSheetRow - 1) : (o[n + 14] = 1, o[n + 15] = 1, o[n + 16] = 0, o[n + 17] = 0)
                }
                for (let e = 0; e < i.length; e++) {
                    const n = i[e];
                    let o = null;
                    switch (t.main.scalingMode) {
                        case UnityEngine.ParticleSystemScalingMode.Hierarchy:
                            o = n.node.getLossyScale();
                            break;
                        case UnityEngine.ParticleSystemScalingMode.Local:
                            o = n.node.getLocalScale();
                            break;
                        case UnityEngine.ParticleSystemScalingMode.Shape:
                            o = pc.Vec3.ONE
                    }
                    this.worldRotationTransform.setTRS(pc.Vec3.ZERO, n.node.getRotation(), pc.Vec3.ONE), this.worldTranslationTransform.setTRS(n.node.getPosition(), pc.Quat.IDENTITY, pc.Vec3.ONE), n.setParameter("matrix_modelRotation", this.worldRotationTransform.data), n.setParameter("matrix_modelTranslation", this.worldTranslationTransform.data), n.setParameter("system_scale", [o.x, o.y, o.z]), n.setParameter("localToWorldMatrix", pc.Mat4.IDENTITY.data), this.renderMode === UnityEngine.ParticleSystemRenderMode.Stretch ? n.setParameter("renderer_alignment", UnityEngine.ParticleSystemRenderSpace.View) : t._shapeModule.alignToDirection ? n.setParameter("renderer_alignment", UnityEngine.ParticleSystemRenderSpace.Local) : n.setParameter("renderer_alignment", this.alignment), n.setParameter("worldSimulationSpace", t.main.simulationSpace === UnityEngine.ParticleSystemSimulationSpace.World ? 1 : 0), n.parameters._TintColor || !n.material || n.material.parameters._TintColor || n.setParameter("_TintColor", [1, 1, 1, 1]), n.worldAabbOverride || (n.worldAabbOverride = new pc.BoundingBox);
                    const a = n.worldAabbOverride;
                    a.setMinMax(s, r), t.main.simulationSpace !== UnityEngine.ParticleSystemSimulationSpace.World && (this.worldTranslationTransform.setTRS(n.node.getPosition(), n.node.getRotation(), pc.Vec3.ONE), a.setFromTransformedAabb(a, this.worldTranslationTransform))
                }
                n.unlock()
            },
            _sortParticles: function(t, e) {
                const i = this.sortMode;
                switch (n = this.model.entity.getPosition(), i) {
                    case UnityEngine.ParticleSystemSortMode.Distance:
                        t.sort(this.sortByDistance);
                        break;
                    case UnityEngine.ParticleSystemSortMode.OldestInFront:
                        t.sort(this.sortOldestInFront);
                        break;
                    case UnityEngine.ParticleSystemSortMode.YoungestInFront:
                        t.sort(this.sortYoungestInFront);
                        break;
                    case UnityEngine.ParticleSystemSortMode.None:
                }
                for (let i = 0; i < e; i++) t[i]._cacheIndex = i
            },
            sortByDistance: function(t, e) {
                if (!t.isAlive) return 1;
                if (!e.isAlive) return -1;
                const s = pc.Application.getApplication().getMainCamera().node.position;
                i.copy(t.t).sub(s).add(n);
                const r = i.lengthSq();
                i.copy(e.t).sub(s).add(n);
                return r - i.lengthSq()
            },
            sortOldestInFront: function(t, e) { return t.isAlive ? e.isAlive ? t.elapsedTime - e.elapsedTime : -1 : 1 },
            sortYoungestInFront: function(t, e) { return t.isAlive ? e.isAlive ? e.elapsedTime - t.elapsedTime : -1 : 1 },
            update: function(t, e) { return this._modelVersion !== this._lastModelVersion && (this._configureModel(), !0) },
            render: function(t, e) {
                const i = t._cache;
                i.aliveCount > 0 && this._sortParticles(i._particles, i.aliveCount), this._resizeInstancingBuffer(i.aliveCount), this._updateInstancingData(t, i)
            }
        }), pc.ParticleSystemRenderer = u
    }(),
    function() {
        function t(t) { this.m_ParticleSystem = t, this.duration = 5, this.loop = !0, this.prewarm = !0, this.startDelay = new pc.MinMaxCurve, this.startDelay._random = t._random, this.startDelayMultiplier = 1, this.startLifetime = new pc.MinMaxCurve(5), this.startLifetime._random = t._random, this.startLifetimeMultiplier = 1, this.startSpeed = new pc.MinMaxCurve(5), this.startSpeed._random = t._random, this.startSpeedMultiplier = 1, this.startSize = new pc.MinMaxCurve, this.startSize._random = t._random, this.startSizeMultiplier = 1, this.startSizeX = new pc.MinMaxCurve, this.startSizeX._random = t._random, this.startSizeXMultiplier = 1, this.startSizeY = new pc.MinMaxCurve, this.startSizeY._random = t._random, this.startSizeYMultiplier = 1, this.startSizeZ = new pc.MinMaxCurve, this.startSizeZ._random = t._random, this.startSizeYMultiplier = 1, this.startRotation = new pc.MinMaxCurve, this.startRotation._random = t._random, this.startRotationMultiplier = 1, this.startRotationX = new pc.MinMaxCurve, this.startRotationX._random = t._random, this.startRotationXMultiplier = 1, this.startRotationY = new pc.MinMaxCurve, this.startRotationY._random = t._random, this.startRotationYMultiplier = 1, this.startRotationZ = new pc.MinMaxCurve, this.startRotationZ._random = t._random, this.startRotationZMultiplier = 1, this.flipRotation = !1, this.startColor = new pc.MinMaxGradient, this.startColor._random = t._random, this.gravityModifier = new pc.MinMaxCurve, this.gravityModifier._random = t._random, this.gravityModifierMultiplier = 1, this.simulationSpace = UnityEngine.ParticleSystemSimulationSpace.Local, this.customSimulationSpace = null, this.simulationSpeed = 1, this.useUnscaledTime = !0, this.scalingMode = UnityEngine.ParticleSystemScalingMode.Local, this.playOnAwake = !0, this.maxParticles = 10, this.emitterVelocityMode = UnityEngine.ParticleSystemEmitterVelocityMode.Transform }
        Object.defineProperty(t.prototype, "duration", { get: function() { return this._duration }, set: function(t) { this._duration = t } }), Object.defineProperty(t.prototype, "loop", { get: function() { return this._loop }, set: function(t) { this._loop = t } }), Object.defineProperty(t.prototype, "prewarm", { get: function() { return this._prewarm }, set: function(t) { this._prewarm = t } }), Object.defineProperty(t.prototype, "startDelay", { get: function() { return this._startDelay }, set: function(t) { this._startDelay = t } }), Object.defineProperty(t.prototype, "startDelayMultiplier", { get: function() { return this._startDelayMultiplier }, set: function(t) { this._startDelayMultiplier = t } }), Object.defineProperty(t.prototype, "startLifetime", { get: function() { return this._startLifetime }, set: function(t) { this._startLifetime = t } }), Object.defineProperty(t.prototype, "startLifetimeMultiplier", { get: function() { return this._startLifetimeMultiplier }, set: function(t) { this._startLifetimeMultiplier = t } }), Object.defineProperty(t.prototype, "startSpeed", { get: function() { return this._startSpeed }, set: function(t) { this._startSpeed = t } }), Object.defineProperty(t.prototype, "startSpeedMultiplier", { get: function() { return this._startSpeedMultiplier }, set: function(t) { this._startSpeedMultiplier = t } }), Object.defineProperty(t.prototype, "startSize3D", { get: function() { return this._startSize3D }, set: function(t) { this._startSize3D = t } }), Object.defineProperty(t.prototype, "startSize", { get: function() { return this._startSize }, set: function(t) { this._startSize = t } }), Object.defineProperty(t.prototype, "startSizeX", { get: function() { return this._startSizeX }, set: function(t) { this._startSizeX = t } }), Object.defineProperty(t.prototype, "startSizeY", { get: function() { return this._startSizeY }, set: function(t) { this._startSizeY = t } }), Object.defineProperty(t.prototype, "startSizeZ", { get: function() { return this._startSizeZ }, set: function(t) { this._startSizeZ = t } }), Object.defineProperty(t.prototype, "startSizeMultiplier", { get: function() { return this._startSizeMultiplier }, set: function(t) { this._startSizeMultiplier = t } }), Object.defineProperty(t.prototype, "startSizeXMultiplier", { get: function() { return this._startSizeXMultiplier }, set: function(t) { this._startSizeXMultiplier = t } }), Object.defineProperty(t.prototype, "startSizeYMultiplier", { get: function() { return this._startSizeYMultiplier }, set: function(t) { this._startSizeYMultiplier = t } }), Object.defineProperty(t.prototype, "startSizeZMultiplier", { get: function() { return this._startSizeZMultiplier }, set: function(t) { this._startSizeZMultiplier = t } }), Object.defineProperty(t.prototype, "startRotation3D", { get: function() { return this._startRotation3D }, set: function(t) { this._startRotation3D = t } }), Object.defineProperty(t.prototype, "startRotation", { get: function() { return this._startRotation }, set: function(t) { this._startRotation = t } }), Object.defineProperty(t.prototype, "startRotationX", { get: function() { return this._startRotationX }, set: function(t) { this._startRotationX = t } }), Object.defineProperty(t.prototype, "startRotationY", { get: function() { return this._startRotationY }, set: function(t) { this._startRotationY = t } }), Object.defineProperty(t.prototype, "startRotationZ", { get: function() { return this._startRotationZ }, set: function(t) { this._startRotationZ = t } }), Object.defineProperty(t.prototype, "startRotationMultiplier", { get: function() { return this._startRotationMultiplier }, set: function(t) { this._startRotationMultiplier = t } }), Object.defineProperty(t.prototype, "startRotationXMultiplier", { get: function() { return this._startRotationXMultiplier }, set: function(t) { this._startRotationXMultiplier = t } }), Object.defineProperty(t.prototype, "startRotationYMultiplier", { get: function() { return this._startRotationYMultiplier }, set: function(t) { this._startRotationYMultiplier = t } }), Object.defineProperty(t.prototype, "startRotationZMultiplier", { get: function() { return this._startRotationZMultiplier }, set: function(t) { this._startRotationZMultiplier = t } }), Object.defineProperty(t.prototype, "flipRotation", { get: function() { return this._flipRotation }, set: function(t) { this._flipRotation = t } }), Object.defineProperty(t.prototype, "startColor", { get: function() { return this._startColor }, set: function(t) { this._startColor = t } }), Object.defineProperty(t.prototype, "gravityModifier", { get: function() { return this._gravityModifier }, set: function(t) { this._gravityModifier = t } }), Object.defineProperty(t.prototype, "gravityModifierMultiplier", { get: function() { return this._gravityModifierMultiplier }, set: function(t) { this._gravityModifierMultiplier = t } }), Object.defineProperty(t.prototype, "simulationSpace", { get: function() { return this._simulationSpace }, set: function(t) { this._simulationSpace = t } }), Object.defineProperty(t.prototype, "customSimulationSpace", { get: function() { return this._customSimulationSpace }, set: function(t) { this._customSimulationSpace = t } }), Object.defineProperty(t.prototype, "simulationSpeed", { get: function() { return this._simulationSpeed }, set: function(t) { this._simulationSpeed = t } }), Object.defineProperty(t.prototype, "useUnscaledTime", { get: function() { return this._useUnscaledTime }, set: function(t) { this._useUnscaledTime = t } }), Object.defineProperty(t.prototype, "scalingMode", { get: function() { return this._scalingMode }, set: function(t) { this._scalingMode = t } }), Object.defineProperty(t.prototype, "playOnAwake", { get: function() { return this._playOnAwake }, set: function(t) { this._playOnAwake = t } }), Object.defineProperty(t.prototype, "maxParticles", { get: function() { return this._maxParticles }, set: function(t) { this._maxParticles = t, this.m_ParticleSystem._cache.maxParticles = this._maxParticles } }), Object.defineProperty(t.prototype, "emitterVelocityMode", { get: function() { return this._emitterVelocityMode }, set: function(t) { this._emitterVelocityMode = t } }), pc.ParticleSystemMain = t
    }(),
    function() {
        function t() {}

        function e(t) { this.m_ParticleSystem = t, this._accumulator = new pc.IntAccumulator, this.enabled = !0, this.rateOverTime = new pc.MinMaxCurve(10), this.rateOverTime._random = t._random, this.rateOverTimeMultiplier = 1, this.rateOverDistance = new pc.MinMaxCurve, this.rateOverDistance._random = t._random, this.rateOverTimeMultiplier = 1, this.bursts = [], this.burstCount = 0, this.burstsTimeline = [], this.lastSpawnTime_rate = 0, this.m_ParticleSystem.events.on("ParticleSystemNewLoop", this.handleParticleSystemLoop) }
        Object.defineProperty(t.prototype, "time", { get: function() { return this._time }, set: function(t) { this._time = t } }), Object.defineProperty(t.prototype, "count", { get: function() { return this._count }, set: function(t) { this._count = t } }), Object.defineProperty(t.prototype, "maxCount", { get: function() { return this._count.constantMax }, set: function(t) { this._count.constantMax = t } }), Object.defineProperty(t.prototype, "minCount", { get: function() { return this._count.constantMin }, set: function(t) { this._count.constantMin = t } }), Object.defineProperty(t.prototype, "cycleCount", { get: function() { return this._cycleCount }, set: function(t) { this._cycleCount = t } }), Object.defineProperty(t.prototype, "repeatInterval", { get: function() { return this.m_RepeatInterval }, set: function(t) { this.m_RepeatInterval = t } }), Object.defineProperty(t.prototype, "shouldFire", { get: function() { return this.repeatCount > 0 } }), t.prototype.recalculateRepeatCount = function() { this.repeatCount = this.cycleCount > 0 ? this.cycleCount : 1 / 0 }, Object.defineProperty(e.prototype, "enabled", { get: function() { return this._enabled }, set: function(t) { this._enabled = t } }), Object.defineProperty(e.prototype, "rateOverTime", { get: function() { return this._rateOverTime }, set: function(t) { this._rateOverTime = t } }), Object.defineProperty(e.prototype, "rateOverTimeMultiplier", { get: function() { return this._rateOverTimeMultiplier }, set: function(t) { this._rateOverTimeMultiplier = t } }), Object.defineProperty(e.prototype, "rateOverDistance", { get: function() { return this._rateOverDistance }, set: function(t) { this._rateOverDistance = t } }), Object.defineProperty(e.prototype, "rateOverDistanceMultiplier", { get: function() { return this._rateOverDistanceMultiplier }, set: function(t) { this._rateOverDistanceMultiplier = t } }), Object.defineProperty(e.prototype, "burstCount", { get: function() { return this._burstCount }, set: function(t) { this._burstCount = t } }), e.prototype.setBursts = function(t) { this.bursts = t }, e.prototype.getBursts = function(t) { for (let e = 0; e < this._burstCount; ++e) t[e] = this.bursts[e]; return this._burstCount }, e.prototype.getBurst = function(t) { return this.bursts[t] }, e.prototype.handleParticleSystemLoop = function() { const t = this.emission; for (let e = 0; e < t.bursts.length; ++e) t.bursts[e].recalculateRepeatCount() }, e.prototype.recalculateBurstData = function() {
            for (let t = 0; t < this.bursts.length; ++t) {
                const e = this.bursts[t];
                null == e.timeToFire && (e.recalculateRepeatCount(), e.timeToFire = e.time)
            }
        }, e.prototype.reinitBurstData = function() {
            for (let t = 0; t < this.bursts.length; ++t) {
                const e = this.bursts[t];
                e.recalculateRepeatCount(), e.timeToFire = e.time
            }
        }, e.prototype.getParticlesFromBursts = function(t) {
            let e = 0;
            for (let i = 0; i < this.bursts.length; ++i) {
                const n = this.bursts[i];
                n.timeToFire -= t, n.shouldFire && n.timeToFire < 0 && (e += n.count.evaluate(this.m_ParticleSystem.lifePart), n.timeToFire = n.repeatInterval, n.repeatCount -= 1)
            }
            return e
        }, e.prototype.update = function(t, e) {
            this.recalculateBurstData();
            const i = this.getParticlesFromBursts(t),
                n = this.m_ParticleSystem._entity.worldTransform.getTranslation();
            this.previousPosition || (this.previousPosition = n.clone());
            const s = n.clone().sub(this.previousPosition).length();
            this.previousPosition = n;
            const r = i + this.rateOverDistance.evaluate(t) * s;
            if (this._accumulator.update(r), this.m_ParticleSystem.main.maxParticles <= this.m_ParticleSystem.particleCount) return 0;
            const o = Math.min(this._accumulator.accumulated, this.m_ParticleSystem.main.maxParticles - this.m_ParticleSystem.particleCount);
            this._accumulator.take(o);
            for (let t = 0; t < o; ++t) this.m_ParticleSystem.createParticle(e, 0);
            const a = 1 / this.rateOverTime.evaluate(this.m_ParticleSystem.lifePart);
            for (; this.lastSpawnTime_rate + a < this.m_ParticleSystem._playTime;) {
                if (this.m_ParticleSystem.main.maxParticles <= this.m_ParticleSystem.particleCount) return 0;
                const t = this.m_ParticleSystem._playTime - this.lastSpawnTime_rate - a;
                this.m_ParticleSystem.createParticle(e, t), this.lastSpawnTime_rate += a
            }
            return 0
        }, pc.ParticleSystemBurst = t, pc.ParticleSystemEmitter = e
    }(),
    function() {
        function t(t) { this.m_ParticleSystem = t, this._TRS = pc.Mat4.IDENTITY, this._TR = pc.Mat4.IDENTITY, this.enabled = !1, this.radiusSpeed = new pc.MinMaxCurve, this.radiusSpeed._random = t._random, this.radiusSpeedMultiplier = 1, this.arcSpeed = new pc.MinMaxCurve, this.arcSpeed._random = t._random, this.arcSpeedMultiplier = 1, this.circularSpawner = new pc.CircularSpawner(this) }
        Object.defineProperty(t.prototype, "enabled", { get: function() { return this._enabled }, set: function(t) { this._enabled = t } }), Object.defineProperty(t.prototype, "shapeType", {
            get: function() { return this._shapeType },
            set: function(t) {
                switch (this._shapeType = t, t) {
                    case UnityEngine.ParticleSystemShapeType.Cone:
                        this.impl = new pc.ConeShape(this, !1);
                        break;
                    case UnityEngine.ParticleSystemShapeType.ConeVolume:
                        this.impl = new pc.ConeShape(this, !0);
                        break;
                    case UnityEngine.ParticleSystemShapeType.Sphere:
                        this.impl = new pc.SphereShape(this);
                        break;
                    case UnityEngine.ParticleSystemShapeType.Hemisphere:
                        this.impl = new pc.SphereShape(this, !0);
                        break;
                    case UnityEngine.ParticleSystemShapeType.Circle:
                        this.impl = new pc.SphereShape(this, !1, !0);
                        break;
                    case UnityEngine.ParticleSystemShapeType.Donut:
                        this.impl = new pc.DonutShape(this);
                        break;
                    case UnityEngine.ParticleSystemShapeType.Box:
                    case UnityEngine.ParticleSystemShapeType.BoxShell:
                    case UnityEngine.ParticleSystemShapeType.BoxEdge:
                    case UnityEngine.ParticleSystemShapeType.Rectangle:
                    case UnityEngine.ParticleSystemShapeType.SingleSidedEdge:
                    default:
                        this.impl = new pc.BoxShape(this)
                }
            }
        }), Object.defineProperty(t.prototype, "randomDirectionAmount", { get: function() { return this._randomDirectionAmount }, set: function(t) { this._randomDirectionAmount = t } }), Object.defineProperty(t.prototype, "sphericalDirectionAmount", { get: function() { return this._sphericalDirectionAmount }, set: function(t) { this._sphericalDirectionAmount = t } }), Object.defineProperty(t.prototype, "randomPositionAmount", { get: function() { return this._randomPositionAmount }, set: function(t) { this._randomPositionAmount = t } }), Object.defineProperty(t.prototype, "alignToDirection", { get: function() { return this._alignToDirection }, set: function(t) { this._alignToDirection = t } }), Object.defineProperty(t.prototype, "radius", { get: function() { return this._radius }, set: function(t) { this._radius = t } }), Object.defineProperty(t.prototype, "radiusMode", { get: function() { return this._radiusMode }, set: function(t) { this._radiusMode = t } }), Object.defineProperty(t.prototype, "radiusSpread", { get: function() { return this._radiusSpread }, set: function(t) { this._radiusSpread = t } }), Object.defineProperty(t.prototype, "radiusSpeed", { get: function() { return this._radiusSpeed }, set: function(t) { this._radiusSpeed = t } }), Object.defineProperty(t.prototype, "radiusSpeedMultiplier", { get: function() { return this._radiusSpeedMultiplier }, set: function(t) { this._radiusSpeedMultiplier = t } }), Object.defineProperty(t.prototype, "radiusThickness", { get: function() { return this._radiusThickness }, set: function(t) { this._radiusThickness = t } }), Object.defineProperty(t.prototype, "angle", { get: function() { return this._angle }, set: function(t) { this._angle = t } }), Object.defineProperty(t.prototype, "length", { get: function() { return this._length }, set: function(t) { this._length = t } }), Object.defineProperty(t.prototype, "boxThickness", { get: function() { return this._boxThickness }, set: function(t) { this._boxThickness = t } }), Object.defineProperty(t.prototype, "arc", { get: function() { return this._arc }, set: function(t) { this._arc = t } }), Object.defineProperty(t.prototype, "arcMode", { get: function() { return this._arcMode }, set: function(t) { this._arcMode = t } }), Object.defineProperty(t.prototype, "arcSpread", { get: function() { return this._arcSpread }, set: function(t) { this._arcSpread = t } }), Object.defineProperty(t.prototype, "arcSpeed", { get: function() { return this._arcSpeed }, set: function(t) { this._arcSpeed = t } }), Object.defineProperty(t.prototype, "arcSpeedMultiplier", { get: function() { return this._arcSpeedMultiplier }, set: function(t) { this._arcSpeedMultiplier = t } }), Object.defineProperty(t.prototype, "donutRadius", { get: function() { return this._donutRadius }, set: function(t) { this._donutRadius = t } }), Object.defineProperty(t.prototype, "position", { get: function() { return this._position }, set: function(t) { this.trsDirty = !0, this.trDirty = !0, this._position = t } }), Object.defineProperty(t.prototype, "rotation", { get: function() { return this._rotation }, set: function(t) { this.trsDirty = !0, this.trDirty = !0, this._rotation = t } }), Object.defineProperty(t.prototype, "scale", { get: function() { return this._scale }, set: function(t) { this.trsDirty = !0, this._scale = t } }), Object.defineProperty(t.prototype, "TRS", {
            get: function() {
                if (this.trsDirty) {
                    const t = new pc.Quat;
                    t.setFromEulerAngles_Unity(this.rotation.x, this.rotation.y, this.rotation.z), this._TRS = (new pc.Mat4).setTRS(this.position, t, this.scale), this.trsDirty = !1
                }
                return this._TRS
            }
        }), Object.defineProperty(t.prototype, "TR", {
            get: function() {
                if (this.trDirty) {
                    const t = new pc.Quat;
                    t.setFromEulerAngles_Unity(this.rotation.x, this.rotation.y, this.rotation.z), this._TR = (new pc.Mat4).setTRS(this.position, t, new pc.Vec3(1, 1, 1)), this.trDirty = !1
                }
                return this._TR
            }
        }), Object.defineProperty(t.prototype, "trsDirty", { get: function() { return this._trsDirty }, set: function(t) { this._trsDirty = t } }), Object.defineProperty(t.prototype, "trDirty", { get: function() { return this._trDirty }, set: function(t) { this._trDirty = t } }), Object.defineProperty(t.prototype, "impl", { get: function() { return this._impl }, set: function(t) { this._impl = t } });
        const e = new pc.Vec3,
            i = new pc.Vec3,
            n = new pc.Quat,
            s = new pc.Quat,
            r = new pc.Vec3,
            o = new pc.Vec3;
        t.prototype.applyNextTransform = function(t, a, c) {
            this.impl.applyTransformations(e, i), this.randomizePosition(e), this._shapeType === UnityEngine.ParticleSystemShapeType.Cone ? (this.impl.applyTransformations(r, o, 0), this.randomizeDirection(i, o)) : this.randomizeDirection(i), this.TRS.transformPoint(e, t), this.TRS.transformVector(i, c), c.normalize(), 0 === c.x && 0 === c.y && 0 === c.z && (c.z = 1);
            const h = Math.sign(this.m_ParticleSystem.main.startSpeed.evaluate(this.m_ParticleSystem.lifePart));
            this.spherizeDirection(t, c, this.position), c.scale(h), n.copy(this.rotationBetweenVectors(pc.Vec3.FORWARD, c)), s.copy(this.rotationBetweenVectors(pc.Vec3.UP, c)), this.m_ParticleSystem._entity._unityComponents.particleSystemRenderer[0]._particleSystemRenderer._renderMode === UnityEngine.ParticleSystemRenderMode.Stretch ? a.copy(s) : this.alignToDirection ? (a.setFromMat4(this.TR), a.mul(n)) : a.copy(pc.Quat.IDENTITY)
        };
        const a = new pc.Vec3;
        t.prototype.randomizePosition = function(t) {
            const e = this.m_ParticleSystem._random;
            this.randomPositionAmount > 0 && (a.x = e.nextFloat() - .5, a.y = e.nextFloat() - .5, a.z = e.nextFloat() - .5, a.scale(this.randomPositionAmount), t.add(a))
        };
        const c = new pc.Vec3;
        t.prototype.randomizeDirection = function(t, e) {
            const i = this.m_ParticleSystem._random;
            this.randomDirectionAmount > 0 && (e ? c.copy(e) : (c.x = i.nextFloat() - .5, c.y = i.nextFloat() - .5, c.z = i.nextFloat() - .5), c.normalize(), t.lerp(t, c, this.randomDirectionAmount)), t.normalize()
        };
        const h = new pc.Vec3;
        t.prototype.spherizeDirection = function(t, e, i) { this.sphericalDirectionAmount > 0 && (h.copy(t).sub(i).normalize(), e.lerp(e, h, this.sphericalDirectionAmount)), e.normalize() };
        const l = new pc.Quat,
            u = new pc.Vec3;
        t.prototype.rotationBetweenVectors = function(t, e) { return u.cross(t, e), l.x = u.x, l.y = u.y, l.z = u.z, l.w = Math.sqrt(t.lengthSq() * e.lengthSq()) + t.dot(e), l.normalize() }, t.prototype.getPointInRadius = function(t) {
            const e = this.m_ParticleSystem._random,
                i = 1 - this.radiusThickness;
            return (i + (1 - i) * e.nextFloat()) * t
        }, pc.ParticleSystemShape = t
    }(),
    function() {
        const t = new pc.Vec3;
        let e = new pc.Vec3;
        const i = new pc.Vec3,
            n = new pc.Vec3;

        function s(t) { this.m_ParticleSystem = t, this.enabled = !1, this.x = new pc.MinMaxCurve, this.x._random = t._random, this.y = new pc.MinMaxCurve, this.y._random = t._random, this.z = new pc.MinMaxCurve, this.z._random = t._random, this.xMultiplier = 1, this.yMultiplier = 1, this.zMultiplier = 1, this.orbitalX = new pc.MinMaxCurve, this.orbitalX._random = t._random, this.orbitalY = new pc.MinMaxCurve, this.orbitalY._random = t._random, this.orbitalZ = new pc.MinMaxCurve, this.orbitalZ._random = t._random, this.orbitalXMultiplier = 1, this.orbitalYMultiplier = 1, this.orbitalZMultiplier = 1, this.orbitalOffsetX = new pc.MinMaxCurve, this.orbitalOffsetX._random = t._random, this.orbitalOffsetY = new pc.MinMaxCurve, this.orbitalOffsetY._random = t._random, this.orbitalOffsetZ = new pc.MinMaxCurve, this.orbitalOffsetZ._random = t._random, this.orbitalOffsetXMultiplier = 1, this.orbitalOffsetYMultiplier = 1, this.orbitalOffsetZMultiplier = 1, this.radial = new pc.MinMaxCurve, this.radial._random = t._random, this.radialMultiplier = 1, this.speedModifier = new pc.MinMaxCurve, this.speedModifier._random = t._random, this.speedModifierMultiplier = 1 }
        Object.defineProperty(s.prototype, "enabled", { get: function() { return this._enabled }, set: function(t) { this._enabled = t } }), Object.defineProperty(s.prototype, "x", { get: function() { return this._x }, set: function(t) { this._x = t } }), Object.defineProperty(s.prototype, "y", { get: function() { return this._y }, set: function(t) { this._y = t } }), Object.defineProperty(s.prototype, "z", { get: function() { return this._z }, set: function(t) { this._z = t } }), Object.defineProperty(s.prototype, "xMultiplier", { get: function() { return this._xMultiplier }, set: function(t) { this._xMultiplier = t } }), Object.defineProperty(s.prototype, "yMultiplier", { get: function() { return this._yMultiplier }, set: function(t) { this._yMultiplier = t } }), Object.defineProperty(s.prototype, "zMultiplier", { get: function() { return this._zMultiplier }, set: function(t) { this._zMultiplier = t } }), Object.defineProperty(s.prototype, "orbitalX", { get: function() { return this._orbitalX }, set: function(t) { this._orbitalX = t } }), Object.defineProperty(s.prototype, "orbitalY", { get: function() { return this._orbitalY }, set: function(t) { this._orbitalY = t } }), Object.defineProperty(s.prototype, "orbitalZ", { get: function() { return this._orbitalZ }, set: function(t) { this._orbitalZ = t } }), Object.defineProperty(s.prototype, "orbitalXMultiplier", { get: function() { return this._orbitalXMultiplier }, set: function(t) { this._orbitalXMultiplier = t } }), Object.defineProperty(s.prototype, "orbitalYMultiplier", { get: function() { return this._orbitalYMultiplier }, set: function(t) { this._orbitalYMultiplier = t } }), Object.defineProperty(s.prototype, "orbitalZMultiplier", { get: function() { return this._orbitalZMultiplier }, set: function(t) { this._orbitalZMultiplier = t } }), Object.defineProperty(s.prototype, "orbitalOffsetX", { get: function() { return this._orbitalOffsetX }, set: function(t) { this._orbitalOffsetX = t } }), Object.defineProperty(s.prototype, "orbitalOffsetY", { get: function() { return this._orbitalOffsetY }, set: function(t) { this._orbitalOffsetY = t } }), Object.defineProperty(s.prototype, "orbitalOffsetZ", { get: function() { return this._orbitalOffsetZ }, set: function(t) { this._orbitalOffsetZ = t } }), Object.defineProperty(s.prototype, "orbitalOffsetXMultiplier", { get: function() { return this._orbitalOffsetXMultiplier }, set: function(t) { this._orbitalOffsetXMultiplier = t } }), Object.defineProperty(s.prototype, "orbitalOffsetYMultiplier", { get: function() { return this._orbitalOffsetYMultiplier }, set: function(t) { this._orbitalOffsetYMultiplier = t } }), Object.defineProperty(s.prototype, "orbitalOffsetZMultiplier", { get: function() { return this._orbitalOffsetZMultiplier }, set: function(t) { this._orbitalOffsetZMultiplier = t } }), Object.defineProperty(s.prototype, "radial", { get: function() { return this._radial }, set: function(t) { this._radial = t } }), Object.defineProperty(s.prototype, "radialMultiplier", { get: function() { return this._radialMultiplier }, set: function(t) { this._radialMultiplier = t } }), Object.defineProperty(s.prototype, "speedModifier", { get: function() { return this._speedModifier }, set: function(t) { this._speedModifier = t } }), Object.defineProperty(s.prototype, "speedModifierMultiplier", { get: function() { return this._speedModifierMultiplier }, set: function(t) { this._speedModifierMultiplier = t } }), Object.defineProperty(s.prototype, "space", { get: function() { return this._space }, set: function(t) { this._space = t } }), s.prototype.processInplace = function(s, r) {
            this.x.mode === pc.MinMaxCurveMode.Curve ? e = this.getLinearValue(s, r) : s.velocityOverLifetimeValue ? e.copy(s.velocityOverLifetimeValue) : (e = this.getLinearValue(s, r), s.velocityOverLifetimeValue = new pc.Vec3, s.velocityOverLifetimeValue.copy(e));
            const o = this.radial.evaluate(s.lifePart);
            o > 0 && (t.x = t.y = t.z = 0, null != this.m_ParticleSystem.shape && this.m_ParticleSystem.shape.enabled && t.copy(this.m_ParticleSystem.shape.position), i.copy(s.t), i.sub(t).normalize().scale(o)), n.copy(e), n.add(i), this._space === UnityEngine.ParticleSystemSimulationSpace.World && this.m_ParticleSystem.entity.worldTransformInverse.transformVector(n, n), s.totalSpeed.add(n).scale(this.speedModifierMultiplier)
        }, s.prototype.getLinearValue = function(t, i) { return e.x = this.x.evaluate(t.lifePart), e.y = this.y.evaluate(t.lifePart), e.z = this.z.evaluate(t.lifePart), e }, pc.ParticleSystemVelocityOverLifetime = s
    }(),
    function() {
        let t = 1;

        function e(t) { this.m_ParticleSystem = t, this.enabled = !1, this.separateAxes = !1, this.strengthX = new pc.MinMaxCurve, this.strengthX._random = t._random, this.strengthY = new pc.MinMaxCurve, this.strengthY._random = t._random, this.strengthZ = new pc.MinMaxCurve, this.strengthZ._random = t._random, this.strengthXMultiplier = 1, this.strengthYMultiplier = 1, this.strengthZMultiplier = 1, this.frequency = 1, this.damping = !1, this.octaveCount = 1, this.octaveMultiplier = 1, this.octaveScale = 1, this.quality = UnityEngine.ParticleSystemNoiseQuality.Low, this.scrollSpeed = new pc.MinMaxCurve, this.scrollSpeed._random = t._random, this.scrollSpeedMultiplier = 1, this.remapEnabled = !1, this.remapX = new pc.MinMaxCurve, this.remapX._random = t._random, this.remapY = new pc.MinMaxCurve, this.remapY._random = t._random, this.remapZ = new pc.MinMaxCurve, this.remapZ._random = t._random, this.remapXMultiplier = 1, this.remapYMultiplier = 1, this.remapZMultiplier = 1, this.positionAmount = new pc.MinMaxCurve, this.positionAmount._random = t._random, this.rotationAmount = new pc.MinMaxCurve, this.rotationAmount._random = t._random, this.sizeAmount = new pc.MinMaxCurve, this.sizeAmount._random = t._random, this.seed = null, this.scrollValue = 0 }
        Object.defineProperty(e.prototype, "enabled", { get: function() { return this._enabled }, set: function(t) { this._enabled = t } }), Object.defineProperty(e.prototype, "separateAxes", { get: function() { return this._separateAxes }, set: function(t) { this._separateAxes = t } }), Object.defineProperty(e.prototype, "strength", { get: function() { return this._strengthX }, set: function(t) { this._strengthX = t } }), Object.defineProperty(e.prototype, "strengthX", { get: function() { return this._strengthX }, set: function(t) { this._strengthX = t } }), Object.defineProperty(e.prototype, "strengthY", { get: function() { return this._strengthY }, set: function(t) { this._strengthY = t } }), Object.defineProperty(e.prototype, "strengthZ", { get: function() { return this._strengthZ }, set: function(t) { this._strengthZ = t } }), Object.defineProperty(e.prototype, "strengthMultiplier", { get: function() { return this._strengthXMultiplier }, set: function(t) { this._strengthXMultiplier = t } }), Object.defineProperty(e.prototype, "strengthXMultiplier", { get: function() { return this._strengthXMultiplier }, set: function(t) { this._strengthXMultiplier = t } }), Object.defineProperty(e.prototype, "strengthYMultiplier", { get: function() { return this._strengthYMultiplier }, set: function(t) { this._strengthYMultiplier = t } }), Object.defineProperty(e.prototype, "strengthZMultiplier", { get: function() { return this._strengthZMultiplier }, set: function(t) { this._strengthZMultiplier = t } }), Object.defineProperty(e.prototype, "frequency", { get: function() { return this._frequency }, set: function(t) { this._frequency = t } }), Object.defineProperty(e.prototype, "damping", { get: function() { return this._damping }, set: function(t) { this._damping = t } }), Object.defineProperty(e.prototype, "octaveCount", { get: function() { return this._octaveCount }, set: function(t) { this._octaveCount = t } }), Object.defineProperty(e.prototype, "octaveMultiplier", { get: function() { return this._octaveMultiplier }, set: function(t) { this._octaveMultiplier = t } }), Object.defineProperty(e.prototype, "octaveScale", { get: function() { return this._octaveScale }, set: function(t) { this._octaveScale = t } }), Object.defineProperty(e.prototype, "quality", { get: function() { return this._quality }, set: function(t) { this._quality = t } }), Object.defineProperty(e.prototype, "scrollSpeed", { get: function() { return this._scrollSpeed }, set: function(t) { this._scrollSpeed = t } }), Object.defineProperty(e.prototype, "scrollSpeedMultiplier", { get: function() { return this._scrollSpeedMultiplier }, set: function(t) { this._scrollSpeedMultiplier = t } }), Object.defineProperty(e.prototype, "remapEnabled", { get: function() { return this._remapEnabled }, set: function(t) { this._remapEnabled = t } }), Object.defineProperty(e.prototype, "remap", { get: function() { return this._remapX }, set: function(t) { this._remapX = t } }), Object.defineProperty(e.prototype, "remapX", { get: function() { return this._remapX }, set: function(t) { this._remapX = t } }), Object.defineProperty(e.prototype, "remapY", { get: function() { return this._remapY }, set: function(t) { this._remapY = t } }), Object.defineProperty(e.prototype, "remapZ", { get: function() { return this._remapZ }, set: function(t) { this._remapZ = t } }), Object.defineProperty(e.prototype, "remapMultiplier", { get: function() { return this._remapXMultiplier }, set: function(t) { this._remapXMultiplier = t } }), Object.defineProperty(e.prototype, "remapXMultiplier", { get: function() { return this._remapXMultiplier }, set: function(t) { this._remapXMultiplier = t } }), Object.defineProperty(e.prototype, "remapYMultiplier", { get: function() { return this._remapYMultiplier }, set: function(t) { this._remapYMultiplier = t } }), Object.defineProperty(e.prototype, "remapZMultiplier", { get: function() { return this._remapZMultiplier }, set: function(t) { this._remapZMultiplier = t } }), Object.defineProperty(e.prototype, "positionAmount", { get: function() { return this._positionAmount }, set: function(t) { this._positionAmount = t } }), Object.defineProperty(e.prototype, "rotationAmount", { get: function() { return this._rotationAmount }, set: function(t) { this._rotationAmount = t } }), Object.defineProperty(e.prototype, "sizeAmount", { get: function() { return this._sizeAmount }, set: function(t) { this._sizeAmount = t } }), e.prototype.processInplace = function(e, i) {
            const n = this.m_ParticleSystem._random;
            null === this.seed && (this.seed = 255 * n.nextFloat()), this.scrollValue += i * this.scrollSpeed.evaluate(this.m_ParticleSystem.lifePart);
            let s = this.seed + this.m_ParticleSystem._playTime;
            s = s * this.frequency + e._cacheIndex;
            const r = pc.noise.perlin2(s + 0, this.scrollValue / 255),
                o = pc.noise.perlin2(s + .33, this.scrollValue / 255),
                a = pc.noise.perlin2(s + .66, this.scrollValue / 255),
                c = new pc.Vec3(0, 0, 0);
            t = this.positionAmount.evaluate(e.lifePart);
            if (this.separateAxes) c.x = r * this.strengthXMultiplier * this.strengthX.evaluate(e.lifePart) * t * 1, c.y = o * this.strengthYMultiplier * this.strengthY.evaluate(e.lifePart) * t * 1, c.z = a * this.strengthZMultiplier * this.strengthZ.evaluate(e.lifePart) * t * 1;
            else {
                const i = this.strength.evaluate(e.lifePart);
                c.x = r * i * t * 1, c.y = o * i * t * 1, c.z = a * i * t * 1
            }
            this.damping && c.scale(1 / this.frequency), e.totalSpeed.add(c);
            const h = this.damping ? r * this.sizeAmount.evaluate(e.lifePart) / this.frequency : r * this.sizeAmount.evaluate(e.lifePart);
            e.tmpScale.scale(1 + .5 * h)
        }, pc.ParticleSystemNoise = e
    }(),
    function() {
        const t = new pc.Color;

        function e(t) { this.m_ParticleSystem = t, this.enabled = !1, this.color = new pc.MinMaxGradient, this.color._random = t._random }
        Object.defineProperty(e.prototype, "enabled", { get: function() { return this._enabled }, set: function(t) { this._enabled = t } }), Object.defineProperty(e.prototype, "color", { get: function() { return this._color }, set: function(t) { this._color = t } }), e.prototype.processInplace = function(e, i) { this.color.mode === pc.MinMaxGradientMode.Gradient ? this.color.evaluateInplace(e.lifePart, t, e.colorGradientState) : e.colorOverLifetimeValue ? t.copy(e.colorOverLifetimeValue) : (this.color.evaluateInplace(e.lifePart, t, e.colorGradientState), e.colorOverLifetimeValue = new pc.Color, e.colorOverLifetimeValue.copy(t)), e.color.mul(t) }, pc.ParticleSystemColorOverLifetime = e
    }(),
    function() {
        let t = 0,
            e = 0;
        const i = new pc.Color;

        function n(t) { this.m_ParticleSystem = t, this.enabled = !1, this.color = new pc.MinMaxGradient, this.color._random = t._random }
        Object.defineProperty(n.prototype, "enabled", { get: function() { return this._enabled }, set: function(t) { this._enabled = t } }), Object.defineProperty(n.prototype, "color", { get: function() { return this._color }, set: function(t) { this._color = t } }), Object.defineProperty(n.prototype, "range", { get: function() { return this._range }, set: function(t) { this._range = t } }), n.prototype.processInplace = function(n, s) {
            if (this.color.mode === pc.MinMaxGradientMode.Gradient) {
                if (this.range.x > this.range.y) {
                    const t = this.range.x;
                    this.range.x = this.range.y, this.range.y = t
                }
                t = n.totalSpeed.length(), e = 0, e = t > this.range.y ? 1 : t < this.range.x ? 0 : (t - this.range.x) / (this.range.y - this.range.x), this.color.evaluateInplace(e, i)
            } else n.colorBySpeedValue ? i.copy(n.colorBySpeedValue) : (this.color.evaluateInplace(e, i), n.colorBySpeedValue = new pc.Color, n.colorBySpeedValue.copy(i));
            n.color.mul(i)
        }, pc.ParticleSystemColorBySpeed = n
    }(),
    function() {
        function t(t) { this.m_ParticleSystem = t, this.enabled = !1, this.x = new pc.MinMaxCurve, this.x._random = t._random, this.y = new pc.MinMaxCurve, this.y._random = t._random, this.z = new pc.MinMaxCurve, this.z._random = t._random, this.size = new pc.MinMaxCurve, this.size._random = t._random, this.xMultiplier = 1, this.yMultiplier = 1, this.zMultiplier = 1, this.sizeMultiplier = 1, this.separateAxes = !1 }
        Object.defineProperty(t.prototype, "enabled", { get: function() { return this._enabled }, set: function(t) { this._enabled = t } }), Object.defineProperty(t.prototype, "size", { get: function() { return this._size }, set: function(t) { this._size = t } }), Object.defineProperty(t.prototype, "sizeMultiplier", { get: function() { return this._sizeMultiplier }, set: function(t) { this._sizeMultiplier = t } }), Object.defineProperty(t.prototype, "separateAxes", { get: function() { return this._separateAxes }, set: function(t) { this._separateAxes = t } }), Object.defineProperty(t.prototype, "x", { get: function() { return this._x }, set: function(t) { this._x = t } }), Object.defineProperty(t.prototype, "y", { get: function() { return this._y }, set: function(t) { this._y = t } }), Object.defineProperty(t.prototype, "z", { get: function() { return this._z }, set: function(t) { this._z = t } }), Object.defineProperty(t.prototype, "xMultiplier", { get: function() { return this._xMultiplier }, set: function(t) { this._xMultiplier = t } }), Object.defineProperty(t.prototype, "yMultiplier", { get: function() { return this._yMultiplier }, set: function(t) { this._yMultiplier = t } }), Object.defineProperty(t.prototype, "zMultiplier", { get: function() { return this._zMultiplier }, set: function(t) { this._zMultiplier = t } });
        let e = new pc.Vec3;
        t.prototype.processInplace = function(t, i) { this.x.mode === pc.MinMaxCurveMode.Curve ? e = this.getValue(t, i) : t.sizeOverLifetimeValue ? e.copy(t.sizeOverLifetimeValue) : (e = this.getValue(t, i), t.sizeOverLifetimeValue = new pc.Vec3, t.sizeOverLifetimeValue.copy(e)), t.tmpScale.mul(e) }, t.prototype.getValue = function(t, i) {
            if (e.copy(pc.Vec3.ONE), this.separateAxes) e.x *= this.x.evaluate(t.lifePart), e.y *= this.y.evaluate(t.lifePart), e.z *= this.z.evaluate(t.lifePart);
            else {
                const i = this.size.evaluate(t.lifePart);
                e.scale(i)
            }
            return e
        }, pc.ParticleSystemSizeOverLifetime = t
    }(),
    function() {
        function t(t) { this.m_ParticleSystem = t, this.enabled = !1, this._x = new pc.MinMaxCurve, this._x._random = t._random, this._y = new pc.MinMaxCurve, this._y._random = t._random, this._z = new pc.MinMaxCurve, this._z._random = t._random, this._size = new pc.MinMaxCurve, this._size._random = t._random, this.xMultiplier = 1, this.yMultiplier = 1, this.zMultiplier = 1, this.separateAxes = !1 }
        Object.defineProperty(t.prototype, "enabled", { get: function() { return this._enabled }, set: function(t) { this._enabled = t } }), Object.defineProperty(t.prototype, "size", { get: function() { return this._size }, set: function(t) { this._size = t } }), Object.defineProperty(t.prototype, "sizeMultiplier", { get: function() { return this._sizeMultiplier }, set: function(t) { this._sizeMultiplier = t } }), Object.defineProperty(t.prototype, "x", { get: function() { return this._x }, set: function(t) { this._x = t } }), Object.defineProperty(t.prototype, "y", { get: function() { return this._y }, set: function(t) { this._y = t } }), Object.defineProperty(t.prototype, "z", { get: function() { return this._z }, set: function(t) { this._z = t } }), Object.defineProperty(t.prototype, "xMultiplier", { get: function() { return this._xMultiplier }, set: function(t) { this._xMultiplier = t } }), Object.defineProperty(t.prototype, "yMultiplier", { get: function() { return this._yMultiplier }, set: function(t) { this._yMultiplier = t } }), Object.defineProperty(t.prototype, "zMultiplier", { get: function() { return this._zMultiplier }, set: function(t) { this._zMultiplier = t } }), Object.defineProperty(t.prototype, "range", { get: function() { return this._range }, set: function(t) { this._range = t } }), t.prototype.processInplace = function(t, e) {
            if (this.range.x > this.range.y) {
                const t = this.range.x;
                this.range.x = this.range.y, this.range.y = t
            }
            let i = 0;
            const n = t.totalSpeed.length();
            if (i = n > this.range.y ? 1 : n < this.range.x ? 0 : (n - this.range.x) / (this.range.y - this.range.x), this.separateAxes) t.tmpScale.x *= this.x.evaluate(i), t.tmpScale.y *= this.y.evaluate(i), t.tmpScale.z *= this.z.evaluate(i);
            else {
                const e = this.size.evaluate(i);
                t.tmpScale.x *= e, t.tmpScale.y *= e, t.tmpScale.z *= e
            }
        }, pc.ParticleSystemSizeBySpeed = t
    }(),
    function() {
        let t = new pc.Vec3;
        const e = new pc.Quat;

        function i(t) { this.m_ParticleSystem = t, this.enabled = !1, this.x = new pc.MinMaxCurve, this.x._random = t._random, this.y = new pc.MinMaxCurve, this.y._random = t._random, this.z = new pc.MinMaxCurve, this.z._random = t._random, this.xMultiplier = 1, this.yMultiplier = 1, this.zMultiplier = 1, this.separateAxes = !1 }
        Object.defineProperty(i.prototype, "enabled", { get: function() { return this._enabled }, set: function(t) { this._enabled = t } }), Object.defineProperty(i.prototype, "x", { get: function() { return this._x }, set: function(t) { this._x = t } }), Object.defineProperty(i.prototype, "y", { get: function() { return this._y }, set: function(t) { this._y = t } }), Object.defineProperty(i.prototype, "z", { get: function() { return this._z }, set: function(t) { this._z = t } }), Object.defineProperty(i.prototype, "xMultiplier", { get: function() { return this._xMultiplier }, set: function(t) { this._xMultiplier = t } }), Object.defineProperty(i.prototype, "yMultiplier", { get: function() { return this._yMultiplier }, set: function(t) { this._yMultiplier = t } }), Object.defineProperty(i.prototype, "zMultiplier", { get: function() { return this._zMultiplier }, set: function(t) { this._zMultiplier = t } }), i.prototype.processInplace = function(e, i) { this.x.mode === pc.MinMaxCurveMode.Curve ? t = this.getValue(e) : e.rotationOverLifetimeValue ? t.copy(e.rotationOverLifetimeValue) : (t = this.getValue(e), e.rotationOverLifetimeValue = new pc.Vec3, e.rotationOverLifetimeValue.copy(t)), e.angularVelocity.add(t) }, i.prototype.getValue = function(i) { return this.separateAxes ? t.set(this.x.evaluate(i.lifePart) * pc.math.RAD_TO_DEG, this.y.evaluate(i.lifePart) * pc.math.RAD_TO_DEG, this.z.evaluate(i.lifePart) * pc.math.RAD_TO_DEG) : (e.setFromAxisAngle(i.startRotationAxis, this.z.evaluate(i.lifePart) * pc.math.RAD_TO_DEG), e.getEulerAngles(t)), t }, pc.ParticleSystemRotationOverLifetime = i
    }(),
    function() {
        let t, e, i;
        const n = new pc.Quat,
            s = new pc.Vec3;

        function r(t) { this.m_ParticleSystem = t, this.enabled = !1, this.x = new pc.MinMaxCurve, this.x._random = t._random, this.y = new pc.MinMaxCurve, this.y._random = t._random, this.z = new pc.MinMaxCurve, this.z._random = t._random, this.xMultiplier = 1, this.yMultiplier = 1, this.zMultiplier = 1, this.separateAxes = !1 }
        Object.defineProperty(r.prototype, "enabled", { get: function() { return this._enabled }, set: function(t) { this._enabled = t } }), Object.defineProperty(r.prototype, "x", { get: function() { return this._x }, set: function(t) { this._x = t } }), Object.defineProperty(r.prototype, "y", { get: function() { return this._y }, set: function(t) { this._y = t } }), Object.defineProperty(r.prototype, "z", { get: function() { return this._z }, set: function(t) { this._z = t } }), Object.defineProperty(r.prototype, "xMultiplier", { get: function() { return this._xMultiplier }, set: function(t) { this._xMultiplier = t } }), Object.defineProperty(r.prototype, "yMultiplier", { get: function() { return this._yMultiplier }, set: function(t) { this._yMultiplier = t } }), Object.defineProperty(r.prototype, "zMultiplier", { get: function() { return this._zMultiplier }, set: function(t) { this._zMultiplier = t } }), Object.defineProperty(r.prototype, "separateAxes", { get: function() { return this._separateAxes }, set: function(t) { this._separateAxes = t } }), Object.defineProperty(r.prototype, "range", { get: function() { return this._range }, set: function(t) { this._range = t } }), r.prototype._getRotationAmount = function(t, e) { if (e.mode === pc.MinMaxCurveMode.Constant || e.mode === pc.MinMaxCurveMode.TwoConstants) return e.evaluate(0); const i = t.ownSpeed.length(); let n = 0; return i > this.range.y ? n = 1 : i < this.range.x ? n = 0 : i >= this.range.x && i <= this.range.y && (n = (i - this.range.x) / (this.range.y - this.range.x)), e.evaluate(n) * pc.math.DEG_TO_RAD }, r.prototype.processInplace = function(r, o) { t = e = 0, i = this._getRotationAmount(r, this.z), this._separateAxes ? (t = this._getRotationAmount(r, this.x), e = this._getRotationAmount(r, this.y), n.setFromEulerAngles(t, e, i)) : n.setFromAxisAngle(r.startRotationAxis, i), n.getEulerAngles(s), r.angularVelocity.add(s) }, pc.ParticleSystemRotationBySpeed = r
    }(),
    function() {
        function t(t, e, i) { this._shapeModule = t, this._hemisphereMode = e, this._circleMode = i }
        t.prototype.applyTransformations = function(t, e) {
            const i = this._shapeModule.m_ParticleSystem._random,
                n = this._shapeModule.circularSpawner.getNextPosition() * this._shapeModule.arc * pc.math.DEG_TO_RAD,
                s = 180 * i.nextFloat() * pc.math.DEG_TO_RAD;
            t.x = Math.sin(s) * Math.cos(n), t.y = Math.sin(s) * Math.sin(n), t.z = Math.cos(s), this._hemisphereMode && (t.z = Math.abs(t.z)), this._circleMode && (t.z = 0), t.normalize(), e.copy(t);
            const r = this._shapeModule.getPointInRadius(this._shapeModule.radius);
            t.scale(r)
        }, pc.SphereShape = t
    }(),
    function() {
        function t(t) { this._shapeModule = t }
        const e = new Array(3);
        t.prototype.applyTransformations = function(t, i) {
            const n = this._shapeModule.m_ParticleSystem._random;
            switch (this._shapeModule.shapeType) {
                case UnityEngine.ParticleSystemShapeType.Box:
                    t.x = n.nextFloat() - .5, t.y = n.nextFloat() - .5, t.z = n.nextFloat() - .5;
                    break;
                case UnityEngine.ParticleSystemShapeType.BoxShell:
                    { e[0] = n.nextFloat() - .5, e[1] = n.nextFloat() - .5, e[2] = n.nextFloat() - .5; const i = n.nextInteger() % 3;e[i] = Math.round(n.nextFloat()) - .5, t.x = e[0], t.y = e[1], t.z = e[2]; break }
                case UnityEngine.ParticleSystemShapeType.Rectangle:
                    t.x = n.nextFloat() - .5, t.y = n.nextFloat() - .5, t.z = 0;
                    break;
                case UnityEngine.ParticleSystemShapeType.BoxEdge:
                    { e[0] = n.nextFloat() - .5, e[1] = n.nextFloat() - .5, e[2] = n.nextFloat() - .5; const i = Math.floor(3 * n.nextFloat()); for (let t = 0; t < 3; t++) t !== i && (e[t] = Math.round(n.nextFloat()) - .5);t.x = e[0], t.y = e[1], t.z = e[2]; break }
                case UnityEngine.ParticleSystemShapeType.SingleSidedEdge:
                    { const e = this._shapeModule.circularSpawner.getNextPosition() - .5; return t.x = e * this._shapeModule.radius, t.y = 0, t.z = 0, void i.copy(pc.Vec3.UP) }
            }
            i.copy(pc.Vec3.BACK)
        }, pc.BoxShape = t
    }(),
    function() {
        function t(t) { this._shapeModule = t, this._curValue = 0, this._prevTime = 0 }
        Object.defineProperty(t.prototype, "radius", { get: function() { return this._shapeModule._radius } }), Object.defineProperty(t.prototype, "arcMode", { get: function() { return this._shapeModule._arcMode } }), Object.defineProperty(t.prototype, "arcSpread", { get: function() { return this._shapeModule._arcSpread } }), Object.defineProperty(t.prototype, "arcSpeed", { get: function() { return this._shapeModule._arcSpeed } }), Object.defineProperty(t.prototype, "arcSpeedMultiplier", { get: function() { return this._shapeModule._arcSpeedMultiplier } }), Object.defineProperty(t.prototype, "radiusMode", { get: function() { return this._shapeModule._radiusMode } }), Object.defineProperty(t.prototype, "radiusSpread", { get: function() { return this._shapeModule._radiusSpread } }), Object.defineProperty(t.prototype, "radiusSpeed", { get: function() { return this._shapeModule._radiusSpeed } }), t.prototype.roundToSpread = function(t, e) { return 0 === e ? t % 1 : Math.floor(t / e) * e % 1 }, t.prototype.pingPong = function(t, e) {
            const i = Math.floor(t / e),
                n = t - e * i;
            return i % 2 == 0 ? n : 1 - n
        }, t.prototype.getNextPosition = function() {
            const t = this._shapeModule.m_ParticleSystem._random,
                e = 1 / this._shapeModule.m_ParticleSystem.emission.rateOverTime.evaluate(this._shapeModule.m_ParticleSystem.lifePart);
            let i = this._shapeModule.m_ParticleSystem.lifetime;
            this._prevTime > i && (i += this._shapeModule.m_ParticleSystem.main.duration);
            let n = i - this._prevTime,
                s = 0;
            n > e && (s = n - e, n = e), this._prevTime = this._shapeModule.m_ParticleSystem.lifetime - s;
            const r = this._shapeModule._shapeType === UnityEngine.ParticleSystemShapeType.SingleSidedEdge;
            let o = 0;
            const a = this._shapeModule.m_ParticleSystem.lifePart,
                c = r ? this.radiusMode : this.arcMode,
                h = r ? 1 : this.arcSpeed.evaluate(a) * (360 / this._shapeModule.arc),
                l = r ? this.radiusSpread : this.arcSpread;
            switch (c) {
                case UnityEngine.ParticleSystemShapeMultiModeValue.Loop:
                    this._curValue += n * h, o = this.roundToSpread(this._curValue, l);
                    break;
                case UnityEngine.ParticleSystemShapeMultiModeValue.PingPong:
                    this._curValue += n * h, o = this.pingPong(this._curValue, 1), o = this.roundToSpread(o, l);
                    break;
                case UnityEngine.ParticleSystemShapeMultiModeValue.BurstSpread:
                case UnityEngine.ParticleSystemShapeMultiModeValue.Random:
                default:
                    o = t.nextFloat(), o = this.roundToSpread(o, l)
            }
            return o
        }, t.prototype.reset = function() { this._curValue = 0, this._prevTime = 0 }, pc.CircularSpawner = t
    }(),
    function() {
        function t(t, e) { this._shapeModule = t, this._useVolume = e || !1 }
        t.prototype.applyTransformations = function(t, e) {
            const i = this._shapeModule.m_ParticleSystem._random,
                n = this._shapeModule.circularSpawner.getNextPosition() * this._shapeModule.arc * pc.math.DEG_TO_RAD;
            t.x = Math.cos(n), t.y = Math.sin(n), t.z = 0;
            const s = 1 - this._shapeModule.radiusThickness,
                r = s + (1 - s) * i.nextFloat(),
                o = r * this._shapeModule.radius,
                a = this._shapeModule.angle * r * pc.math.DEG_TO_RAD;
            if (0 === a ? (e.x = 0, e.y = 0, e.z = 1) : (e.x = t.x, e.y = t.y, e.z = Math.sqrt(t.x * t.x + t.y * t.y) / Math.tan(a), e.normalize()), t.scale(o), this._useVolume) {
                const n = this._shapeModule.length * i.nextFloat();
                t.add(e.clone().scale(n))
            }
        }, pc.ConeShape = t
    }(),
    function() {
        const t = new pc.Vec3,
            e = new pc.Vec3;

        function i(t) { this._shapeModule = t }
        i.prototype.applyTransformations = function(i, n) {
            const s = this._shapeModule.m_ParticleSystem._random,
                r = this._shapeModule.circularSpawner.getNextPosition() * this._shapeModule.arc * pc.math.DEG_TO_RAD,
                o = 360 * s.nextFloat() * pc.math.DEG_TO_RAD,
                a = this._shapeModule.radius,
                c = this._shapeModule.getPointInRadius(this._shapeModule.donutRadius);
            t.x = a * Math.cos(r), t.y = a * Math.sin(r), t.z = 0, e.x = (a + c * Math.cos(o)) * Math.cos(r), e.y = (a + c * Math.cos(o)) * Math.sin(r), e.z = c * Math.sin(o), n.copy(e).sub(t), i.copy(e)
        }, pc.DonutShape = i
    }(),
    function() {
        function t(t) { this.m_ParticleSystem = t, this._TRS = pc.Mat4.IDENTITY, this._TR = pc.Mat4.IDENTITY, this.enabled = !1, this.radiusSpeed = new pc.MinMaxCurve, this.radiusSpeed._random = t._random, this.radiusSpeedMultiplier = 1, this.arcSpeed = new pc.MinMaxCurve, this.arcSpeed._random = t._random, this.arcSpeedMultiplier = 1, this.circularSpawner = new pc.CircularSpawner(this) }
        Object.defineProperty(t.prototype, "enabled", { get: function() { return this._enabled }, set: function(t) { this._enabled = t } }), Object.defineProperty(t.prototype, "shapeType", {
            get: function() { return this._shapeType },
            set: function(t) {
                switch (this._shapeType = t, t) {
                    case UnityEngine.ParticleSystemShapeType.Cone:
                        this.impl = new pc.ConeShape(this, !1);
                        break;
                    case UnityEngine.ParticleSystemShapeType.ConeVolume:
                        this.impl = new pc.ConeShape(this, !0);
                        break;
                    case UnityEngine.ParticleSystemShapeType.Sphere:
                        this.impl = new pc.SphereShape(this);
                        break;
                    case UnityEngine.ParticleSystemShapeType.Hemisphere:
                        this.impl = new pc.SphereShape(this, !0);
                        break;
                    case UnityEngine.ParticleSystemShapeType.Circle:
                        this.impl = new pc.SphereShape(this, !1, !0);
                        break;
                    case UnityEngine.ParticleSystemShapeType.Donut:
                        this.impl = new pc.DonutShape(this);
                        break;
                    case UnityEngine.ParticleSystemShapeType.Box:
                    case UnityEngine.ParticleSystemShapeType.BoxShell:
                    case UnityEngine.ParticleSystemShapeType.BoxEdge:
                    case UnityEngine.ParticleSystemShapeType.Rectangle:
                    case UnityEngine.ParticleSystemShapeType.SingleSidedEdge:
                    default:
                        this.impl = new pc.BoxShape(this)
                }
            }
        }), Object.defineProperty(t.prototype, "randomDirectionAmount", { get: function() { return this._randomDirectionAmount }, set: function(t) { this._randomDirectionAmount = t } }), Object.defineProperty(t.prototype, "sphericalDirectionAmount", { get: function() { return this._sphericalDirectionAmount }, set: function(t) { this._sphericalDirectionAmount = t } }), Object.defineProperty(t.prototype, "randomPositionAmount", { get: function() { return this._randomPositionAmount }, set: function(t) { this._randomPositionAmount = t } }), Object.defineProperty(t.prototype, "alignToDirection", { get: function() { return this._alignToDirection }, set: function(t) { this._alignToDirection = t } }), Object.defineProperty(t.prototype, "radius", { get: function() { return this._radius }, set: function(t) { this._radius = t } }), Object.defineProperty(t.prototype, "radiusMode", { get: function() { return this._radiusMode }, set: function(t) { this._radiusMode = t } }), Object.defineProperty(t.prototype, "radiusSpread", { get: function() { return this._radiusSpread }, set: function(t) { this._radiusSpread = t } }), Object.defineProperty(t.prototype, "radiusSpeed", { get: function() { return this._radiusSpeed }, set: function(t) { this._radiusSpeed = t } }), Object.defineProperty(t.prototype, "radiusSpeedMultiplier", { get: function() { return this._radiusSpeedMultiplier }, set: function(t) { this._radiusSpeedMultiplier = t } }), Object.defineProperty(t.prototype, "radiusThickness", { get: function() { return this._radiusThickness }, set: function(t) { this._radiusThickness = t } }), Object.defineProperty(t.prototype, "angle", { get: function() { return this._angle }, set: function(t) { this._angle = t } }), Object.defineProperty(t.prototype, "length", { get: function() { return this._length }, set: function(t) { this._length = t } }), Object.defineProperty(t.prototype, "boxThickness", { get: function() { return this._boxThickness }, set: function(t) { this._boxThickness = t } }), Object.defineProperty(t.prototype, "arc", { get: function() { return this._arc }, set: function(t) { this._arc = t } }), Object.defineProperty(t.prototype, "arcMode", { get: function() { return this._arcMode }, set: function(t) { this._arcMode = t } }), Object.defineProperty(t.prototype, "arcSpread", { get: function() { return this._arcSpread }, set: function(t) { this._arcSpread = t } }), Object.defineProperty(t.prototype, "arcSpeed", { get: function() { return this._arcSpeed }, set: function(t) { this._arcSpeed = t } }), Object.defineProperty(t.prototype, "arcSpeedMultiplier", { get: function() { return this._arcSpeedMultiplier }, set: function(t) { this._arcSpeedMultiplier = t } }), Object.defineProperty(t.prototype, "donutRadius", { get: function() { return this._donutRadius }, set: function(t) { this._donutRadius = t } }), Object.defineProperty(t.prototype, "position", { get: function() { return this._position }, set: function(t) { this.trsDirty = !0, this.trDirty = !0, this._position = t } }), Object.defineProperty(t.prototype, "rotation", { get: function() { return this._rotation }, set: function(t) { this.trsDirty = !0, this.trDirty = !0, this._rotation = t } }), Object.defineProperty(t.prototype, "scale", { get: function() { return this._scale }, set: function(t) { this.trsDirty = !0, this._scale = t } }), Object.defineProperty(t.prototype, "TRS", {
            get: function() {
                if (this.trsDirty) {
                    const t = new pc.Quat;
                    t.setFromEulerAngles_Unity(this.rotation.x, this.rotation.y, this.rotation.z), this._TRS = (new pc.Mat4).setTRS(this.position, t, this.scale), this.trsDirty = !1
                }
                return this._TRS
            }
        }), Object.defineProperty(t.prototype, "TR", {
            get: function() {
                if (this.trDirty) {
                    const t = new pc.Quat;
                    t.setFromEulerAngles_Unity(this.rotation.x, this.rotation.y, this.rotation.z), this._TR = (new pc.Mat4).setTRS(this.position, t, new pc.Vec3(1, 1, 1)), this.trDirty = !1
                }
                return this._TR
            }
        }), Object.defineProperty(t.prototype, "trsDirty", { get: function() { return this._trsDirty }, set: function(t) { this._trsDirty = t } }), Object.defineProperty(t.prototype, "trDirty", { get: function() { return this._trDirty }, set: function(t) { this._trDirty = t } }), Object.defineProperty(t.prototype, "impl", { get: function() { return this._impl }, set: function(t) { this._impl = t } });
        const e = new pc.Vec3,
            i = new pc.Vec3,
            n = new pc.Quat,
            s = new pc.Quat,
            r = new pc.Vec3,
            o = new pc.Vec3;
        t.prototype.applyNextTransform = function(t, a, c) {
            this.impl.applyTransformations(e, i), this.randomizePosition(e), this._shapeType === UnityEngine.ParticleSystemShapeType.Cone ? (this.impl.applyTransformations(r, o, 0), this.randomizeDirection(i, o)) : this.randomizeDirection(i), this.TRS.transformPoint(e, t), this.TRS.transformVector(i, c), c.normalize(), 0 === c.x && 0 === c.y && 0 === c.z && (c.z = 1);
            const h = Math.sign(this.m_ParticleSystem.main.startSpeed.evaluate(this.m_ParticleSystem.lifePart));
            this.spherizeDirection(t, c, this.position), c.scale(h), n.copy(this.rotationBetweenVectors(pc.Vec3.FORWARD, c)), s.copy(this.rotationBetweenVectors(pc.Vec3.UP, c)), this.m_ParticleSystem._entity._unityComponents.particleSystemRenderer[0]._particleSystemRenderer._renderMode === UnityEngine.ParticleSystemRenderMode.Stretch ? a.copy(s) : this.alignToDirection ? (a.setFromMat4(this.TR), a.mul(n)) : a.copy(pc.Quat.IDENTITY)
        };
        const a = new pc.Vec3;
        t.prototype.randomizePosition = function(t) {
            const e = this.m_ParticleSystem._random;
            this.randomPositionAmount > 0 && (a.x = e.nextFloat() - .5, a.y = e.nextFloat() - .5, a.z = e.nextFloat() - .5, a.scale(this.randomPositionAmount), t.add(a))
        };
        const c = new pc.Vec3;
        t.prototype.randomizeDirection = function(t, e) {
            const i = this.m_ParticleSystem._random;
            this.randomDirectionAmount > 0 && (e ? c.copy(e) : (c.x = i.nextFloat() - .5, c.y = i.nextFloat() - .5, c.z = i.nextFloat() - .5), c.normalize(), t.lerp(t, c, this.randomDirectionAmount)), t.normalize()
        };
        const h = new pc.Vec3;
        t.prototype.spherizeDirection = function(t, e, i) { this.sphericalDirectionAmount > 0 && (h.copy(t).sub(i).normalize(), e.lerp(e, h, this.sphericalDirectionAmount)), e.normalize() };
        const l = new pc.Quat,
            u = new pc.Vec3;
        t.prototype.rotationBetweenVectors = function(t, e) { return u.cross(t, e), l.x = u.x, l.y = u.y, l.z = u.z, l.w = Math.sqrt(t.lengthSq() * e.lengthSq()) + t.dot(e), l.normalize() }, t.prototype.getPointInRadius = function(t) {
            const e = this.m_ParticleSystem._random,
                i = 1 - this.radiusThickness;
            return (i + (1 - i) * e.nextFloat()) * t
        }, pc.ParticleSystemShape = t
    }(),
    function() {
        function t(t) { this.m_ParticleSystem = t, this.enabled = !1, this.frameOverTime = new pc.MinMaxCurve, this.frameOverTime._random = t._random, this.frameOverTimeMultiplier = 1, this.startFrame = new pc.MinMaxCurve, this.startFrame._random = t._random, this.startFrameMultiplier = 1 }
        Object.defineProperty(t.prototype, "enabled", { get: function() { return this._enabled }, set: function(t) { this._enabled = t } }), Object.defineProperty(t.prototype, "animation", { get: function() { return this._animation }, set: function(t) { this._animation = t } }), Object.defineProperty(t.prototype, "cycleCount", { get: function() { return this._cycleCount }, set: function(t) { this._cycleCount = t } }), Object.defineProperty(t.prototype, "flipU", { get: function() { return this._flipU }, set: function(t) { this._flipU = t } }), Object.defineProperty(t.prototype, "flipV", { get: function() { return this._flipV }, set: function(t) { this._flipV = t } }), Object.defineProperty(t.prototype, "frameOverTime", { get: function() { return this._frameOverTime }, set: function(t) { this._frameOverTime = t } }), Object.defineProperty(t.prototype, "frameOverTimeMultiplier", { get: function() { return this._frameOverTimeMultiplier }, set: function(t) { this._frameOverTimeMultiplier = t } }), Object.defineProperty(t.prototype, "mode", { get: function() { return this.m_Mode }, set: function(t) { this.m_Mode = t } }), Object.defineProperty(t.prototype, "numTilesX", { get: function() { return this._numTilesX }, set: function(t) { this._numTilesX = t } }), Object.defineProperty(t.prototype, "numTilesY", { get: function() { return this._numTilesY }, set: function(t) { this._numTilesY = t } }), Object.defineProperty(t.prototype, "rowIndex", { get: function() { return this._rowIndex }, set: function(t) { this._rowIndex = t } }), Object.defineProperty(t.prototype, "spriteCount", { get: function() { return this._spriteCount } }), Object.defineProperty(t.prototype, "startFrame", { get: function() { return this._startFrame }, set: function(t) { this._startFrame = t } }), Object.defineProperty(t.prototype, "startFrameMultiplier", { get: function() { return this._startFrameMultiplier }, set: function(t) { this._startFrameMultiplier = t } }), Object.defineProperty(t.prototype, "useRandomRow", { get: function() { return this._useRandomRow }, set: function(t) { this._useRandomRow = t } }), t.prototype._processGridMode = function(t, e) {
            const i = this.m_ParticleSystem._random,
                n = this.animation === UnityEngine.ParticleSystemAnimationType.WholeSheet ? this._numTilesX * this._numTilesY : this._numTilesX;
            null === t.startFrame && (t.startFrame = Math.floor(this.startFrame.evaluate(this.m_ParticleSystem.lifePart) * n));
            let s = Math.floor(this.frameOverTime.evaluate(t.lifePart) * n * this.cycleCount) + t.startFrame;
            this.animation === UnityEngine.ParticleSystemAnimationType.SingleRow ? (t.texSheetAnimationInitialized || (t.texSheetRow = this.useRandomRow ? i.nextInteger() % this.numTilesY : this.rowIndex, t.texSheetAnimationInitialized = !0), t.texSheetColumn = s % this.numTilesX) : this.animation === UnityEngine.ParticleSystemAnimationType.WholeSheet && (s %= this.numTilesX * this.numTilesY, t.texSheetRow = Math.floor(s / this.numTilesX), t.texSheetColumn = s % this.numTilesX)
        }, t.prototype.processInplace = function(t, e) { this.mode === UnityEngine.ParticleSystemAnimationMode.Grid ? this._processGridMode(t, e) : (this.mode, UnityEngine.ParticleSystemAnimationMode.Sprites) }, pc.ParticleSystemTextureSheetAnimation = t
    }(),
    function() {
        const t = new pc.Vec3;

        function e(t) { this.particleSystem = t, this.enabled = !1, this._curve = new pc.MinMaxCurve, this._curve._random = t._random, this._curveMultiplier = 1 }
        Object.defineProperty(e.prototype, "enabled", { get: function() { return this._enabled }, set: function(t) { this._enabled = t } }), Object.defineProperty(e.prototype, "mode", { get: function() { return this._mode }, set: function(t) { this._mode = t } }), Object.defineProperty(e.prototype, "curve", { get: function() { return this._curve }, set: function(t) { this._curve = t } }), Object.defineProperty(e.prototype, "curveMultiplier", { get: function() { return this._curveMultiplier }, set: function(t) { this._curveMultiplier = t } }), e.prototype.processInplace = function(e, i) {
            if (this.particleSystem.main.simulationSpace === UnityEngine.ParticleSystemSimulationSpace.World) {
                switch (t.copy(pc.Vec3.ONE), this._mode) {
                    case UnityEngine.ParticleSystemInheritVelocityMode.Initial:
                        e.inheritVelocityValue || (e.inheritVelocityValue = new pc.Vec3, e.inheritVelocityValue.copy(this.particleSystem.currentVelocity)), t.copy(e.inheritVelocityValue);
                        break;
                    case UnityEngine.ParticleSystemInheritVelocityMode.Current:
                        t.copy(this.particleSystem.currentVelocity)
                }
                t.scale(this._curve.evaluate(this.particleSystem.lifePart)), e.totalSpeed.add(t)
            }
        }, pc.ParticleSystemInheritVelocity = e
    }(),
    function() {
        let t = new pc.Vec3;

        function e(t) { this.m_ParticleSystem = t, this._enabled = !1, this._x = new pc.MinMaxCurve, this._x._random = t._random, this._y = new pc.MinMaxCurve, this._y._random = t._random, this._z = new pc.MinMaxCurve, this._z._random = t._random, this._xMultiplier = 0, this._yMultiplier = 0, this._zMultiplier = 0, this._space = 0, this._randomized = !1 }
        Object.defineProperty(e.prototype, "enabled", { get: function() { return this._enabled }, set: function(t) { this._enabled = t } }), Object.defineProperty(e.prototype, "x", { get: function() { return this._x }, set: function(t) { this._x = t } }), Object.defineProperty(e.prototype, "y", { get: function() { return this._y }, set: function(t) { this._y = t } }), Object.defineProperty(e.prototype, "z", { get: function() { return this._z }, set: function(t) { this._z = t } }), Object.defineProperty(e.prototype, "xMultiplier", { get: function() { return this._xMultiplier }, set: function(t) { this._xMultiplier = t } }), Object.defineProperty(e.prototype, "yMultiplier", { get: function() { return this._yMultiplier }, set: function(t) { this._yMultiplier = t } }), Object.defineProperty(e.prototype, "zMultiplier", { get: function() { return this._zMultiplier }, set: function(t) { this._zMultiplier = t } }), Object.defineProperty(e.prototype, "space", { get: function() { return this._space }, set: function(t) { this._space = t } }), Object.defineProperty(e.prototype, "randomized", { get: function() { return this._randomized }, set: function(t) { this._randomized = t } }), e.prototype.processInplace = function(e, i) { this._x.mode === pc.MinMaxCurveMode.Curve || this._randomized ? t = this.getForceValue(e) : e.forceOverLifetimeValue ? t.copy(e.forceOverLifetimeValue) : (t = this.getForceValue(e, i), e.forceOverLifetimeValue = new pc.Vec3, e.forceOverLifetimeValue.copy(t)), this._space === UnityEngine.ParticleSystemSimulationSpace.World && this.m_ParticleSystem.entity.worldTransformInverse.transformVector(t, t), t.scale(i), e.ownSpeed.add(t), e.totalSpeed.add(t) }, e.prototype.getForceValue = function(e) { return t.x = this._x.evaluate(e.lifePart), t.y = this._y.evaluate(e.lifePart), t.z = this._z.evaluate(e.lifePart), t }, pc.ParticleSystemForceOverLifetime = e
    }(),
    function() {
        let t = 0;
        const e = new pc.Vec3;

        function i(t) { this.m_ParticleSystem = t, this._enabled = !0, this._limit = new pc.MinMaxCurve, this._limit._random = t._random, this._limitMultiplier = 1, this._separateAxes = !1, this._limitX = new pc.MinMaxCurve, this._limitX._random = t._random, this._limitY = new pc.MinMaxCurve, this._limitY._random = t._random, this._limitZ = new pc.MinMaxCurve, this._limitZ._random = t._random, this._limitXMultiplier = 1, this._limitYMultiplier = 1, this._limitZMultiplier = 1, this._space = 0, this._dampen = 0, this._drag = new pc.MinMaxCurve, this._drag._random = t._random, this._dragMultiplier = 1, this._multiplyDragByParticleSize = !1, this._multiplyDragByParticleVelocity = !1 }
        Object.defineProperty(i.prototype, "enabled", { get: function() { return this._enabled }, set: function(t) { this._enabled = t } }), Object.defineProperty(i.prototype, "limit", { get: function() { return this._limit }, set: function(t) { this._limit = t } }), Object.defineProperty(i.prototype, "limitMultiplier", { get: function() { return this._limitMultiplier }, set: function(t) { this._limitMultiplier = t } }), Object.defineProperty(i.prototype, "separateAxes", { get: function() { return this._separateAxes }, set: function(t) { this._separateAxes = t } }), Object.defineProperty(i.prototype, "limitX", { get: function() { return this._limitX }, set: function(t) { this._limitX = t } }), Object.defineProperty(i.prototype, "limitY", { get: function() { return this._limitY }, set: function(t) { this._limitY = t } }), Object.defineProperty(i.prototype, "limitZ", { get: function() { return this._limitZ }, set: function(t) { this.limitY = t } }), Object.defineProperty(i.prototype, "limitXMultiplier", { get: function() { return this._limitXMultiplier }, set: function(t) { this._limitXMultiplier = t } }), Object.defineProperty(i.prototype, "limitYMultiplier", { get: function() { return this._limitYMultiplier }, set: function(t) { this._limitYMultiplier = t } }), Object.defineProperty(i.prototype, "limitZMultiplier", { get: function() { return this._limitZMultiplier }, set: function(t) { this._limitZMultiplier = t } }), Object.defineProperty(i.prototype, "space", { get: function() { return this._space }, set: function(t) { this._space = t } }), Object.defineProperty(i.prototype, "dampen", { get: function() { return this._dampen }, set: function(t) { this._dampen = t } }), Object.defineProperty(i.prototype, "drag", { get: function() { return this._drag }, set: function(t) { this._drag = t } }), Object.defineProperty(i.prototype, "dragMultiplier", { get: function() { return this._dragMultiplier }, set: function(t) { this._dragMultiplier = t } }), Object.defineProperty(i.prototype, "multiplyDragByParticleSize", { get: function() { return this._multiplyDragByParticleSize }, set: function(t) { this._multiplyDragByParticleSize = t } }), Object.defineProperty(i.prototype, "multiplyDragByParticleVelocity", { get: function() { return this._multiplyDragByParticleVelocity }, set: function(t) { this._multiplyDragByParticleVelocity = t } }), i.prototype.applyDamp = function(t, e, i) {
            const n = Math.abs(t),
                s = n - e;
            return Math.sign(t) * Math.min(s * this._dampen * i * (s / n) * 30.61, n)
        }, i.prototype.applyDragInplace = function(t, e, i) {
            let n = 1,
                s = 1;
            this._multiplyDragByParticleSize && this.multiplyDragByParticleVelocity ? (s = t.totalSpeed.length(), n = this.getScaleModifier(t), t.ownSpeed.scale(1 - e * n * s * i)) : this._multiplyDragByParticleSize ? (n = this.getScaleModifier(t), t.ownSpeed.x = Math.sign(t.ownSpeed.x) * Math.max(Math.abs(t.ownSpeed.x) - e * n * i, 0), t.ownSpeed.y = Math.sign(t.ownSpeed.y) * Math.max(Math.abs(t.ownSpeed.y) - e * n * i, 0), t.ownSpeed.z = Math.sign(t.ownSpeed.z) * Math.max(Math.abs(t.ownSpeed.z) - e * n * i, 0)) : this._multiplyDragByParticleVelocity ? (s = t.totalSpeed.length(), t.ownSpeed.scale(1 - e * s * i)) : (t.ownSpeed.x = Math.sign(t.ownSpeed.x) * Math.max(Math.abs(t.ownSpeed.x) - e * i, 0), t.ownSpeed.y = Math.sign(t.ownSpeed.y) * Math.max(Math.abs(t.ownSpeed.y) - e * i, 0), t.ownSpeed.z = Math.sign(t.ownSpeed.z) * Math.max(Math.abs(t.ownSpeed.z) - e * i, 0))
        }, i.prototype.getScaleModifier = function(t) { const e = Math.max(t.tmpScale.x, t.tmpScale.y, t.tmpScale.z); return Math.PI * e * e / 4 }, i.prototype.processInplace = function(i, n) {
            if (this.applyDragInplace(i, this.drag.evaluate(i.lifePart), n), e.x = this._separateAxes) e.x = this._limitX.evaluate(i.lifePart), e.y = this._limitY.evaluate(i.lifePart), e.z = this._limitZ.evaluate(i.lifePart);
            else {
                const t = this._limit.evaluate(i.lifePart);
                e.x = t, e.y = t, e.z = t
            }
            this._space === UnityEngine.ParticleSystemSimulationSpace.World && this.m_ParticleSystem.entity.worldTransformInverse.transformVector(e, e), Math.abs(i.totalSpeed.x) > e.x && (t = -this.applyDamp(i.totalSpeed.x, e.x, n), i.ownSpeed.x += t, i.totalSpeed.x += t), Math.abs(i.totalSpeed.y) > e.y && (t = -this.applyDamp(i.totalSpeed.y, e.y, n), i.ownSpeed.y += t, i.totalSpeed.y += t), Math.abs(i.totalSpeed.z) > e.z && (t = -this.applyDamp(i.totalSpeed.z, e.z, n), i.ownSpeed.z += t, i.totalSpeed.z += t)
        }, pc.ParticleSystemLimitVelocityOverLifetime = i
    }(), Object.assign(pc, function() {
        const t = function(t, e) { this.object = t, this.time = e, this.updatedAt = UnityEngine.Time.time, this.instant = !e || e <= 0, this.secondPassProcess = !1, this.enabled = !0, this.instant && this.prepare() };
        (t.prototype = Object.create(Object.prototype)).constructor = t, Object.assign(t.prototype, {
            prepare: function() { this.isValid && (this.object.enabled = !1) },
            update: function() {
                if (!this.isValid || this.instant || this.time <= 0) return;
                const t = UnityEngine.Time.time,
                    e = t - this.updatedAt;
                this.updatedAt = t, this.time -= e, this.time <= 0 && (this.prepare(), this.secondPassProcess = !0)
            },
            execute: function() { this.isValid && (this.object.onDestroy && this.object.onDestroy(), this.object.destroy(), this.object = null) }
        }), Object.defineProperty(t.prototype, "isValid", { get: function() { return null !== this.object && !this.object._destroyed } }), Object.defineProperty(t.prototype, "isReady", { get: function() { return this.enabled && (this.instant || this.time <= 0) || !this.isValid } });
        const e = function(e, i) { t.prototype.constructor.call(this, e, i) };
        (e.prototype = Object.create(t.prototype)).constructor = e, Object.assign(e.prototype, {
            prepare: function() { if (!this.isValid) return; const t = this.object.collectAllUnityComponents(); for (let e = 0; e < t.length; e++) { t[e].enabled = !1 } },
            execute: function() {
                if (!this.isValid) return;
                this.object._beingDestroyed = !0, this.object.enabled = !1;
                const t = this.object.collectAllUnityComponents();
                for (let e = 0; e < t.length; e++) {
                    const i = t[e];
                    i.onDestroy && i.onDestroy()
                }
                this.object.destroy(), this.object = null
            }
        }), Object.defineProperty(e.prototype, "isValid", { get: function() { return null !== this.object && !this.object._destroyed && !this.object._beingDestroyed } });
        const i = function(e, i) { t.prototype.constructor.call(this, e, i) };
        return (i.prototype = Object.create(t.prototype)).constructor = i, Object.assign(i.prototype, { prepare: function() {}, execute: function() { this.isValid && (this.object.CallOnDisable(), this.object.CallOnDestroy(), this.object._destroyed = !0) } }), Object.defineProperty(i.prototype, "isValid", { get: function() { return !this.object._destroyed } }), { DestroyTask: t, DestroyEntityTask: e, DestroyScriptableObjectTask: i }
    }()), Object.assign(pc, function() {
        class t extends pc.ComponentSystem {
            constructor(t) { super(t), this.id = "unitymanager", this.description = "Supports Unity-like components.", this.callbacksDisabled = !1, this.fixedTimeStep = .02, this.maximumAllowedTimeStep = .1, this.timeScale = 1, this.maximumParticleTimestep = .15, this._fixedAccumulator = 0, this.app.events.on("update", this.onUpdate, this), this.app.events.on("frameend", this.onFrameEnd, this), this.app.events.on("focus", this.onApplicationFocus, this), this.app.events.on("blur", this.onApplicationBlur, this), this.systems = [], this.destroyQueue = new Array(64), this.destroyQueueTmp = new Array(64), this.destroyQueueLength = 0, this.destroyQueueProcessing = !1 }
            registerSystem(t) { this.systems.push(t) }
            onUpdate(t) {
                if (this._invokeQueueOnSystems("onStart"), this._invokeQueueOnSystems("onBeforeUpdates", t), Math.abs(UnityEngine.Time.timeScale) > Number.EPSILON) {
                    for (this._fixedAccumulator = Math.min(this.maximumAllowedTimeStep, this._fixedAccumulator + t * UnityEngine.Time.timeScale), UnityEngine.Time.SetActiveFixedTime(!0); this._fixedAccumulator >= this.fixedTimeStep;) this._invokeQueueOnSystems("onFixedUpdate", this.fixedTimeStep), this._fixedAccumulator -= this.fixedTimeStep;
                    UnityEngine.Time.SetActiveFixedTime(!1)
                }
                this._invokeDestroyQueue(!1), this._invokeQueueOnSystems("onUpdate", t), this._invokeDestroyQueue(!0), this._invokeQueueOnSystems("onPostUpdate", t), this._invokeDestroyQueue(!1), this._invokeQueueOnSystems("onBeforeRender", t)
            }
            onFrameEnd() { this._invokeQueueOnSystems("onAfterRender", null) }
            onApplicationFocus() { this._invokeQueueOnSystems("onApplicationFocus", !0) }
            onApplicationBlur() { this._invokeQueueOnSystems("onApplicationFocus", !1) }
            _invokeQueueOnSystems(t, e) {
                for (let i = 0; i < this.systems.length; i++) {
                    const n = this.systems[i];
                    this._triggerPerformanceSample(n, !0), n[t].call(n, e), this._triggerPerformanceSample(n, !1)
                }
            }
            _triggerPerformanceSample(t, e) {
                const i = t.performanceSamplerSection;
                i && (e ? this.app.counters.startSection(i) : this.app.counters.endSection(i))
            }
            disableCallbacks() { this.callbacksDisabled = !0 }
            enableCallbacks() { this.callbacksDisabled = !1 }
            invokeCallbacks(t) {
                if (t.isPrefab && null == t.parent) return;
                this.callbacksDisabled = !1;
                const e = new pc.ComponentQueue;
                this._collectComponents(t, e), this._invokeQueue(e)
            }
            _collectComponents(t, e) {
                const i = t.collectAllUnityComponents();
                for (let t = 0; t < i.length; t++) {
                    const n = i[t];
                    (n.onAwake || n.onEnable || n.onDisable) && e.push(n)
                }
            }
            _invokeQueue(t, e) {
                if (0 === t.length) return;
                const i = t.getComponents(!0);
                for (let t = 0; t < i.length; t++) {
                    const n = i[t];
                    n.entity._enabledInHierarchy && (n.onInit && n.onInit.call(n, e), n.onEnable && n.enabled && n.onEnable.call(n, e), n.onDisable && !n.enabled && n.onDisable.call(n, e))
                }
            }
            enqueueDestroy(t) { t.isValid && (this.destroyQueueProcessing && (t.enabled = !1), this.destroyQueue[this.destroyQueueLength] = t, this.destroyQueueLength++) }
            _invokeDestroyQueue(t) {
                if (0 === this.destroyQueueLength) return;
                let e = 0;
                if (this.destroyQueueProcessing = !0, t)
                    for (let t = 0; t < this.destroyQueueLength; t++) this.destroyQueue[t].update();
                for (let t = 0; t < this.destroyQueueLength; t++) {
                    const i = this.destroyQueue[t];
                    i.isReady ? i.secondPassProcess || i.execute() : (this.destroyQueueTmp[e] = i, e++)
                }
                for (let t = 0; t < this.destroyQueueLength; t++) {
                    const e = this.destroyQueue[t];
                    e.isReady && e.secondPassProcess && e.execute()
                }
                for (let t = 0; t < this.destroyQueueLength; t++) this.destroyQueue[t].enabled = !0;
                const i = this.destroyQueue;
                this.destroyQueue = this.destroyQueueTmp, this.destroyQueueTmp = i, this.destroyQueueLength = e, this.destroyQueueProcessing = !1
            }
        }
        return { UnityComponentSystemManagerSystem: t }
    }()), Object.assign(pc, function() {
        const t = ["OnMouseDown", "OnMouseDrag", "OnMouseEnter", "OnMouseExit", "OnMouseOver", "OnMouseUp", "OnMouseUpAsButton", "OnTriggerEnter", "OnTriggerStay", "OnTriggerExit", "OnCollisionEnter", "OnCollisionStay", "OnCollisionExit", "OnTriggerEnter2D", "OnTriggerStay2D", "OnTriggerExit2D", "OnCollisionEnter2D", "OnCollisionStay2D", "OnCollisionExit2D", "UnityEngine$UI$IMaterialModifier$GetModifiedMaterial", "UnityEngine$UI$IMeshModifier$ModifyMesh", "UnityEngine$UI$IMeshModifier$ModifyMesh$1", "OnPopulateMesh", "UnityEngine$ICanvasRaycastFilter$IsRaycastLocationValid"],
            e = new Map;
        class i extends pc.UnityComponent {
            constructor(i, n, s) {
                super();
                const r = Bridge._getTypeByName(n);
                this.code = new r(this), this.scriptsExecutionOrder = 0, this.internalExecutionOrder = 100, this["__" + n] = this.code, this.code.handle = this, this.unityClass = r, this._enabled = void 0 === s || !!s, this._events = [],
                    function(i) {
                        const n = i.code.constructor;
                        if (e.has(n)) return;
                        const s = [];
                        for (let e = 0; e < t.length; e++) n.prototype[t[e]] !== UnityEngine.UI.Graphic.prototype.OnPopulateMesh && n.prototype[t[e]] && s.push(t[e]);
                        e.set(n, s)
                    }(this), this._addEventListeners()
            }
            storeMagicMethods(t) {
                if (t.isPrefab) return;
                const i = Bridge.as(this.code, UnityEngine.EventSystems.IEventSystemHandler);
                t._eventHanders || (t._eventHanders = []), i && t._eventHanders.push(i);
                const n = e.get(this.code.constructor);
                if (0 !== n.length) {
                    null === t._magicMethods && (t._magicMethods = {});
                    for (let e = 0; e < n.length; e++) {
                        const i = t._magicMethods[n[e]] || [];
                        i.push(this), t._magicMethods[n[e]] = i
                    }
                }
            }
            removeMagicMethods(t) {
                const i = e.get(this.code.constructor);
                if (0 !== i.length && null !== t._magicMethods)
                    for (let e = 0; e < i.length; e++) {
                        const n = t._magicMethods[i[e]];
                        if (n) {
                            const t = n.indexOf(this);
                            t >= 0 && (n[t] = n[n.length - 1], n.length -= 1)
                        }
                    }
            }
            configureForEntity(t) { this.code.ConfigureForEntity && this.code.ConfigureForEntity(t) }
            onEnable() { return !!pc.UnityComponent.prototype.onEnable.call(this) && (this._invokeOverload("OnEnable"), !0) }
            onDisable() { return !!pc.UnityComponent.prototype.onDisable.call(this) && (this._invokeOverload("OnDisable"), !0) }
            onDestroy() { return !!pc.UnityComponent.prototype.onDestroy.call(this) && (this.stopAllCoroutines(), this._invokeOverload("DestroyInternal"), this._invokeOverload("OnDestroy"), !0) }
            onAwake() { this._invokeOverload("Awake") }
            onStart() { this._invokeOverload("Start") }
            onUpdate() { this._invokeOverload("Update") }
            onFixedUpdate() { this._invokeOverload("FixedUpdate") }
            onPostUpdate() { this.code.LateUpdate() }
            onBeforeRender() { this.code.OnPreRender() }
            onAfterRender() { this.code.OnPostRender() }
            onApplicationFocus(t) { this.code.OnApplicationFocus(t) }
            onPointerEnter(t) {
                (this.code.OnPointerEnter || this.code.UnityEngine$EventSystems$IPointerEnterHandler$OnPointerEnter).call(this.code, t)
            }
            onPointerExit(t) {
                (this.code.OnPointerExit || this.code.UnityEngine$EventSystems$IPointerExitHandler$OnPointerExit).call(this.code, t)
            }
            onPointerDown(t) {
                (this.code.OnPointerDown || this.code.UnityEngine$EventSystems$IPointerDownHandler$OnPointerDown).call(this.code, t)
            }
            onPointerUp(t) {
                (this.code.OnPointerUp || this.code.UnityEngine$EventSystems$IPointerUpHandler$OnPointerUp).call(this.code, t)
            }
            onPointerClick(t) {
                (this.code.OnPointerClick || this.code.UnityEngine$EventSystems$IPointerClickHandler$OnPointerClick).call(this.code, t)
            }
            onBeginDrag(t) {
                (this.code.onBeginDrag || this.code.UnityEngine$EventSystems$IBeginDragHandler$OnBeginDrag).call(this.code, t)
            }
            onDrag(t) {
                (this.code.OnDrag || this.code.UnityEngine$EventSystems$IDragHandler$OnDrag).call(this.code, t)
            }
            onEndDrag(t) {
                (this.code.OnEndDrag || this.code.UnityEngine$EventSystems$IEndDragHandler$OnEndDrag).call(this.code, t)
            }
            addCoroutine(t) { this._system.addCoroutine(t, this) }
            addFixedUpdateCoroutine(t) { this._system.addFixedUpdateCoroutine(t, this) }
            addEndOfFrameCoroutine(t) { this._system.addEndOfFrameCoroutine(t, this) }
            stopAllCoroutines() { this._system.stopAllCoroutines(this) }
            stopCoroutine(t) { this._system.stopCoroutine(t, this) }
            _addEventListeners() { this.code.Update && this._events.push("onUpdate"), this.code.FixedUpdate && this._events.push("onFixedUpdate"), this.code.LateUpdate && this._events.push("onPostUpdate"), this.code.OnPostRender && this._events.push("onAfterRender"), this.code.OnApplicationFocus && this._events.push("onApplicationFocus") }
            _queuesToSubscribe() { return this._events }
            _invokeOverload(t) {
                try {
                    const e = this.code.overloads[t + "()"] || t,
                        i = this.code[e];
                    if (void 0 !== i) {
                        const t = i.call(this.code);
                        t && "Bridge.GeneratorEnumerator" === t.$$fullname && new UnityEngine.Coroutine(t, this)
                    }
                } catch (t) { t = t.hasOwnProperty("errorStack") ? t.errorStack : t, console.error(t), "undefined" != typeof Sentry && Sentry.captureException(t) }
            }
            onCanvasGroupChanged() { this._invokeOverload("OnCanvasGroupChanged") }
            onBeforeTransformParentChanged() { this._invokeOverload("OnBeforeTransformParentChanged") }
            onTransformParentChanged() { this._invokeOverload("OnTransformParentChanged") }
            onTransformChildrenChanged() { this._invokeOverload("OnTransformChildrenChanged") }
        }
        return i.create = t => { const e = Bridge._getTypeByName(t.type); return Bridge.isFunction(e) ? new i(t.entity, t.type, t.enabled) : null }, { MonoBehaviourComponent: i }
    }()), Object.assign(pc, function() {
        class t extends pc.UnityComponentSystem {
            constructor(t) { super(t), this.id = "monoBehaviour", this.performanceSamplerSection = pc.Counters.SCRIPTS, this.scriptsExecutionOrder = [], this._coroutines = { onUpdate: {}, onFixedUpdate: {}, onAfterRender: {} } }
            addComponent(t, e) { pc.UnityComponentSystem.prototype.addComponent.call(this, t, e), e.scriptsExecutionOrder = this.scriptsExecutionOrder[e.code.$$fullname] || 0, e.storeMagicMethods(t) }
            removeComponent(t, e) { pc.UnityComponentSystem.prototype.removeComponent.call(this, t, e), e.removeMagicMethods(t) }
            onBeforeUpdates() { UnityEngine.Input.OnMouseUpdate() }
            onUpdate(t) {
                pc.UnityComponentSystem.prototype.onUpdate.call(this, t);
                const e = this._coroutines.onUpdate;
                for (const i in e) {
                    const n = e[i],
                        s = n.length > 0 ? n[0][1] : null;
                    if (!s || !s._entity._activeSelf) { delete e[i]; continue }
                    let r = 0,
                        o = -1;
                    for (let e = n.length - 1; e >= 0; --e) {
                        const i = n[e][0];
                        i.Update(t), i.isDone ? (r++, o < 0 && (o = e)) : o >= 0 && (n[o--] = n[e])
                    }
                    r === n.length ? delete e[i] : r > 0 && n.splice(0, r)
                }
            }
            onFixedUpdate(t) { pc.UnityComponentSystem.prototype.onFixedUpdate.call(this, t), this._updateCoroutines(this._coroutines.onFixedUpdate, this._handleFixedUpdate) }
            onAfterRender(t) { pc.UnityComponentSystem.prototype.onAfterRender.call(this, t), this._updateCoroutines(this._coroutines.onAfterRender, this._handleEndOfFrame) }
            _updateCoroutines(t, e) {
                for (const i in t) {
                    const n = t[i],
                        s = n.length > 0 ? n[0][1] : null;
                    if (!s || !s._entity._activeSelf) { delete t[i]; continue }
                    const r = n.length;
                    for (let t = r - 1; t >= 0; --t) e(n[t][0]);
                    n.length === r ? delete t[i] : n.splice(0, r)
                }
            }
            _handleFixedUpdate(t) { t.HandleFixedUpdate() }
            _handleEndOfFrame(t) { t.HandleEndOfFrame() }
            stopAllCoroutines(t) {
                const e = this._coroutines.onUpdate[t._id];
                if (e)
                    for (let t = 0; t < e.length; ++t) { e[t][0].Cancel() }
            }
            stopCoroutine(t, e) {
                const i = this._coroutines.onUpdate[e._id];
                if (i)
                    for (let e = 0; e < i.length; ++e) {
                        const n = i[e][0];
                        n.enumerator === t && n.Cancel()
                    }
            }
            addCoroutine(t, e) { this._addCoroutineToQueue(t, e, this._coroutines.onUpdate) }
            addFixedUpdateCoroutine(t, e) { this._addCoroutineToQueue(t, e, this._coroutines.onFixedUpdate) }
            addEndOfFrameCoroutine(t, e) { this._addCoroutineToQueue(t, e, this._coroutines.onAfterRender) }
            _addCoroutineToQueue(t, e, i) { i[e._id] || (i[e._id] = []), i[e._id].push([t, e]) }
        }
        return { MonoBehaviourSystem: t }
    }()), Object.assign(pc, function() {
        class t extends pc.MonoBehaviourComponent {get sortingOrderInQueue() { return this._sortingOrderInQueue } }
        return t.create = function(e) { const i = Bridge._getTypeByName(e.type); return Bridge.isFunction(i) ? new t(e.entity, e.type, e.enabled) : null }, { UIBehaviourComponent: t }
    }()), Object.assign(pc, function() {
        class t extends pc.MonoBehaviourSystem { constructor(t) { super(t), this.id = "uiBehaviour" } }
        return { UIBehaviourSystem: t }
    }()), Object.assign(pc, function() {
        const t = "_MainTex";
        let e = 0;
        class i extends pc.UnityComponent {
            constructor() { super(), this.id = e++, this.model = new pc.Model, this._color = new pc.Color(1, 1, 1, 1), this._groupAlpha = 1, this.code = new UnityEngine.CanvasRenderer(this), this._parentCanvas = null, this._colorParameter = { const: [1, 1, 1, 1] }, this._showMaskGraphics = !0, this._absoluteDepth = 0, this._hasPopInstruction = !1, this._popMaterialCount = 0, this._popMaterials = [], this.mesh = null, this.isCanvas = !1, this._cullTransparentMesh = !1, this.cull = !1, this.culledByTransparency = !1 }
            get cullTransparentMesh() { return this._cullTransparentMesh }
            set cullTransparentMesh(t) { this._cullTransparentMesh = t }
            get showMaskGraphics() { return this._showMaskGraphics }
            set showMaskGraphics(t) { this._showMaskGraphics = t, this.model.setParameter("_ColorMask", t ? 15 : 0) }
            get absoluteDepth() { return this._absoluteDepth }
            set absoluteDepth(t) { this._absoluteDepth = t }
            get hasPopInstruction() { return this._hasPopInstruction }
            set hasPopInstruction(t) { this._hasPopInstruction = t }
            get popMaterialCount() { return this._popMaterialCount }
            set popMaterialCount(t) { this._popMaterialCount = t }
            onEnable() {
                const t = this.findParentCanvas();
                this.reparentCanvas(t), pc.UnityComponent.prototype.onEnable.call(this)
            }
            onDisable() { this.reparentCanvas(null), pc.UnityComponent.prototype.onDisable.call(this) }
            onScreenChanged(t) { this.reparentCanvas(t) }
            onCanvasGroupChanged() { this.setGroupAlpha(UnityEngine.CanvasGroup.ExtractAlpha(this.entity.element._canvasGroups)) }
            onAttached() {
                const t = this._entity;
                t.element || t.addComponent("element", { pivot: new pc.Vec2(.5, .5), anchor: new pc.Vec4(0, 0, 1, 1), sizeDelta: new pc.Vec2(0, 0), anchoredPosition: new pc.Vec2(0, 0) });
                const e = t.element;
                e.events.on("set:stencillayer", this._onStencilLayerChange, this), e.events.on("set:draworder", this._onDrawOrderChange, this), this.model.element = e, this.model.entity = t
            }
            _onStencilLayerChange(t) {
                if (this._ignoreMask) this.model.stencil = null;
                else {
                    const t = this.entity.element;
                    this.model.stencil = t._getStencilParameters(), this.model.masksChildren && this.model.setParameter("UNITY_UI_ALPHACLIP", 1)
                }
            }
            _onDrawOrderChange(t) {
                const e = this._entity.element,
                    i = e._nearestScreen;
                this.model.nearestScreen = i, this.model.element = e, this.model.drawOrder = t, i && (this.model.sortingLayerIndex = i.sortingLayerIndex, this.model.sortingOrder = i.sortingOrder)
            }
            setTexture(e) { e ? this.model.setParameter(t, e) : this.model.deleteParameter(t) }
            getTexture() { return this.model.getParameter(t) }
            setColor(t) { this._color.equals(t) || (this._color.copy(t), this.applyColor()) }
            getColor() { return this._color }
            setMaterial(t, e) {
                const i = this.model.materials;
                i[e] = t, this.model.materials = i
            }
            getMaterial(t) { return this.model.materials ? this.model.materials[t] : null }
            setMaterialCount(t) {
                const e = this.model.materials || [];
                e.length = t, this.model.materials = e
            }
            getMaterialCount() { return this.model.materials ? this.model.materials.length : 0 }
            setMesh(t) { this.model.mesh = t, this.cacheColors(t), this.applyColor() }
            cacheColors(t) {
                if (t && t.vertexBuffer.format.hasColor) {
                    const t = UnityEngine.Object.FromHandle(UnityEngine.Mesh, this.model._mesh);
                    this.vertexColors = t.colors
                }
            }
            getMesh() { return this.model.mesh }
            findParentCanvas() { return pc.UIUtils.findParentScreen(this._entity) }
            addToParentCanvas() { this._parentCanvas && !this._entity.isPrefab && this._parentCanvas.canvasMeshInstance.addRenderer(this) }
            removeFromParentCanvas() { this._parentCanvas && this._parentCanvas.canvasMeshInstance.removeRenderer(this) }
            reparentCanvas(t) {
                if (!this.entity.enabled) return this.removeFromParentCanvas(), void(this._parentCanvas = null);
                if (t !== this._parentCanvas) {
                    this.removeFromParentCanvas();
                    const e = this._parentCanvas ? this._parentCanvas["__UnityEngine.Canvas"] : null;
                    this._parentCanvas = t;
                    const i = t ? t["__UnityEngine.Canvas"] : null;
                    this.enabled && this.addToParentCanvas();
                    const n = this.entity.element ? this.entity.element["UnityEngine.UI.Graphic"] : null;
                    this.entity.element._nearestScreen = t, n && (n.m_canvas = i, n.OnCanvasChanged(e, i))
                }
            }
            setGroupAlpha(t) { this._groupAlpha = t, this.applyColor() }
            applyColor() {
                const t = this.model.mesh;
                if (null != t && t.vertexBuffer.format.hasColor) {
                    this.model.deleteConstant("COLOR");
                    const e = UnityEngine.Object.FromHandle(UnityEngine.Mesh, this.model._mesh),
                        i = e.colors;
                    if (0 === i.length) return;
                    let n = !0;
                    if (!t.alphaCorrected) {
                        for (let t = 0; t < this.vertexColors.length; t++) i[t].r = this.vertexColors[t].r * this._color.r, i[t].g = this.vertexColors[t].g * this._color.g, i[t].b = this.vertexColors[t].b * this._color.b, i[t].a = this.vertexColors[t].a * this._color.a * this._groupAlpha, i[t].a >= Number.EPSILON && (n = !1);
                        t.alphaCorrected = !0
                    }
                    e.colors = i, this.cullTransparentMesh && (this.culledByTransparency = n)
                } else {
                    const t = new pc.Color;
                    t.copy(this._color), t.a *= this._groupAlpha, this._colorParameter = t.data, this.model.setConstant("COLOR", this._colorParameter)
                }
            }
            setPopMaterial(t, e) { this._popMaterials[e] || this._popMaterialCount++, this._popMaterials[e] = t }
        }
        return { CanvasRendererComponent: i }
    }()), Object.assign(pc, function() {
        class t extends pc.UnityComponentSystem { constructor(t) { super(t), this.id = "canvasRenderer" } }
        return { CanvasRendererSystem: t }
    }()), Object.assign(pc, function() {
        class t extends pc.UnityComponentSystem { constructor(t) { super(t), this.id = "particlesystem" } }
        return { ParticleSystemSystem: t }
    }()), Object.assign(pc, function() {
        class t extends pc.UnityComponent {
            constructor(t) { super(), this._particleSystem = t.particleSystem, this._renderer = null }
            _fetchRenderer() { const t = this._entity._unityComponents.particleSystemRenderer[0]; return null == t ? null : (this._particleSystem.renderer = t._particleSystemRenderer, t) }
            _queuesToSubscribe() { return ["onUpdate"] }
            onAttached() { this._particleSystem._entity = this._entity, this._renderer || (this._renderer = this._fetchRenderer()) }
            onAwake() { this._particleSystem._entity = this._entity, this._renderer || (this._renderer = this._fetchRenderer()) }
            onEnable() { return !!pc.UnityComponent.prototype.onEnable.call(this) && (this._particleSystem.main.playOnAwake && this._particleSystem.play(), !0) }
            onDestroy() { return this._particleSystem._cache.dispose(), !!pc.UnityComponent.prototype.onDestroy.call(this) && (this._renderer && !this._renderer._destroyed && (this._renderer.enabled && (this._renderer.enabled = !1), this._renderer.destroy(), this._renderer = null), !0) }
            onUpdate(t) { this._renderer || (this._renderer = this._fetchRenderer()), this._particleSystem.update(t, this._entity.getWorldTransform()), this._renderer.enabled && this._renderer.update(this._particleSystem, t) }
            onDisable() { return !!pc.UnityComponent.prototype.onDisable.call(this) && (this._renderer && (this._renderer.enabled = !1), this._particleSystem.stop(!0, UnityEngine.ParticleSystemStopBehavior.StopEmittingAndClear), !0) }
        }
        return { ParticleSystemComponent: t }
    }()), Object.assign(pc, function() {
        class t extends pc.UnityComponentSystem { constructor(t) { super(t), this.id = "particleSystemRenderer" } }
        return { ParticleSystemRendererSystem: t }
    }()), Object.assign(pc, function() {
        class t extends pc.UnityComponent {
            constructor(t) { super(), this._particleSystemRenderer = t.particleSystemRenderer }
            get model() { return this._particleSystemRenderer ? this._particleSystemRenderer.model : null }
            onAttached() { pc.UnityComponent.prototype.onAttached.call(this), this._particleSystemRenderer.model && (this._particleSystemRenderer.model.entity = this.entity) }
            update(t, e) { this._particleSystemRenderer.update(t, e), this._particleSystemRenderer.render(t, e) }
            onEnable() { return !!pc.UnityComponent.prototype.onEnable.call(this) && (pc.Application.getApplication().scene.addRenderer(this), !0) }
            onDisable() { return !!pc.UnityComponent.prototype.onDisable.call(this) && (pc.Application.getApplication().scene.removeRenderer(this), !0) }
            getMeshInstancesForRender() { return this.model.meshInstances }
        }
        return { ParticleSystemRendererComponent: t }
    }()), Object.assign(pc, function() {
        class t extends pc.UnityComponentSystem {
            constructor(t) { super(t), this.id = "reflectionprobe" }
            scheduleProbeUpdate() { this.needsProbeUpdate = !0 }
            onBeforeRender(t) { this.needsProbeUpdate && this.refreshReflectionProbes(), this.needsProbeUpdate = !1, pc.UnityComponentSystem.prototype.onBeforeRender.call(this, t) }
            refreshReflectionProbes() {
                const t = this.app.systems.renderer._components;
                for (const e in t) {
                    if (!t.hasOwnProperty(e)) continue;
                    const i = t[e];
                    i.enabled && (i.code && i.code.UpdateReflectionProbes())
                }
            }
        }
        return { ReflectionProbeSystem: t }
    }()), Object.assign(pc, function() {
        class t extends pc.UnityComponent {
            onEnable() { return !!pc.UnityComponent.prototype.onEnable.call(this) && (this.code.OnEnable(), !0) }
            onDisable() { return !!pc.UnityComponent.prototype.onDisable.call(this) && (this.code.OnDisable(), !0) }
            onTransformChanged() { this.code.OnReflectionProbeChanged() }
            onBeforeRender(t) { this.code.OnBeforeRender() }
            _queuesToSubscribe() { return ["onBeforeRender"] }
            refreshReflectionProbes() { this.system.scheduleProbeUpdate() }
        }
        return { ReflectionProbeComponent: t }
    }()), Object.assign(pc, function() {
        class t extends pc.UnityComponentSystem { constructor(t) { super(t), this.id = "meshFilter" } }
        return { MeshFilterComponentSystem: t }
    }()), Object.assign(pc, function() {
        class t extends pc.UnityComponent {
            constructor(t) { super(), this._mesh = null }
            get mesh() { return this._mesh }
            set mesh(t) { this._mesh = t }
        }
        return { MeshFilterComponent: t }
    }()), Object.assign(pc, function() {
        class t extends pc.UnityComponentSystem { constructor(t) { super(t), this.id = "renderer", this.defaultMaterial = t.scene.defaultMaterial } }
        return { RendererComponentSystem: t }
    }()), Object.assign(pc, function() {
        class t extends pc.UnityComponent {
            constructor(t) { super(), this.model = new pc.Model, this._castShadows = !0, this._receiveShadows = !0, this.system = pc.Application.getApplication().systems.renderer, this._material = this.system.defaultMaterial, this.code = null, this._lastAABBVersion = -1 }
            get aabb() { return this._aabb || (this._aabb = new pc.BoundingBox), this.model && this.model.mesh ? this._aabb.setFromTransformedAabb(this.model.mesh.aabb, this.entity.worldTransform) : this._aabb.setMinMax(pc.Vec3.ZERO, pc.Vec3.ZERO), this._aabb }
            get meshInstances() { return this.model ? this.model.meshInstances : null }
            set meshInstances(t) { this.model && (this.model.meshInstances = t) }
            get castShadows() { return this._castShadows }
            set castShadows(t) { this._castShadows !== t && (this._castShadows = t) }
            get receiveShadows() { return this._receiveShadows }
            set receiveShadows(t) { this._receiveShadows !== t && (this._receiveShadows = t) }
            onAttached() { pc.UnityComponent.prototype.onAttached.call(this), this.model && (this.model.entity = this.entity) }
            onDestroy() { return !!pc.UnityComponent.prototype.onDestroy.call(this) }
            onEnable() { return !!pc.UnityComponent.prototype.onEnable.call(this) && (pc.Application.getApplication().scene.addRenderer(this), !0) }
            onDisable() { return !!pc.UnityComponent.prototype.onDisable.call(this) && (pc.Application.getApplication().scene.removeRenderer(this), !0) }
            synchronizeWithEntity() { this.entity && this.code && (this._destroyed || this._lastAABBVersion === this.entity.aabbVersion || (this._lastAABBVersion = this.entity.aabbVersion, this.code._lightProbeUsage && this.code.UpdateProbes(), this.model.flipFaces = this.entity._isOddlyScaled())) }
            getMeshInstancesForRender() { return this.synchronizeWithEntity(), this.code.OnBeforeRender && this.code.OnBeforeRender(), this.model.update(), this.model.meshInstances }
            getPropertyBlock(t, e) {
                this.model.update();
                const i = this.model.meshInstances[e];
                i ? t.handle.copyFromMeshInstance(i) : console.warn("MaterialPropertyBlock index " + e + " is out of range")
            }
            setPropertyBlock(t, e) {
                this.model.update();
                const i = this.model.meshInstances[e];
                i ? t.handle.applyToMeshInstance(i) : console.warn("MaterialPropertyBlock index " + e + " is out of range")
            }
            setMesh(t) { this.model.setMeshDirectlyToMeshInstance(t) }
        }
        return { RendererComponent: t }
    }()), Object.assign(pc, function() {
        const t = new pc.StencilParameters({ func: pc.FUNC_LESSEQUAL, ref: 1, writeMask: 255, readMask: 255, zfail: pc.STENCILOP_KEEP, zpass: pc.STENCILOP_KEEP, fail: pc.STENCILOP_KEEP }),
            e = new pc.StencilParameters({ func: pc.FUNC_GREATER, ref: 1, writeMask: 255, readMask: 255, zfail: pc.STENCILOP_KEEP, zpass: pc.STENCILOP_KEEP, fail: pc.STENCILOP_KEEP });
        class i extends pc.RendererComponent {
            constructor(t) { super(), this.code = new UnityEngine.SpriteRenderer(this) }
            onEnable() {
                if (!pc.RendererComponent.prototype.onEnable.call(this)) return !1;
                if (this.code.maskInteraction === UnityEngine.SpriteMaskInteraction.None) this.model._stencil = null;
                else {
                    const i = this.code.maskInteraction === UnityEngine.SpriteMaskInteraction.VisibleInsideMask;
                    this.model._stencil = i ? t : e
                }
                return !0
            }
        }
        return { SpriteRendererComponent: i }
    }()), Object.assign(pc, function() {
        const t = new pc.StencilParameters({ func: pc.FUNC_ALWAYS, ref: 0, writeMask: 255, readMask: 255, zfail: pc.STENCILOP_KEEP, zpass: pc.STENCILOP_INCREMENT, fail: pc.STENCILOP_KEEP }),
            e = new pc.StencilParameters({ func: pc.FUNC_ALWAYS, ref: 0, writeMask: 255, readMask: 255, zfail: pc.STENCILOP_KEEP, zpass: pc.STENCILOP_DECREMENT, fail: pc.STENCILOP_KEEP });
        class i extends pc.RendererComponent {
            constructor() { super(), this.code = new UnityEngine.SpriteMask(this), this._sprite = null, this._alphaCutoff = .2, this._isCustomRangeActive = !1, this._frontSortingLayerID = 0, this._frontSortingOrder = 0, this._backSortingLayerID = -1e6, this._backSortingOrder = -1e3, this._dirty = !0 }
            get isCustomRangeActive() { return this._isCustomRangeActive }
            set isCustomRangeActive(t) { this._isCustomRangeActive !== t && (this._isCustomRangeActive = t, this._dirty = !0) }
            get alphaCutoff() { return this._alphaCutoff }
            set alphaCutoff(t) { this._alphaCutoff !== t && (this._alphaCutoff = t, this.model.setParameter("_Cutoff", this._alphaCutoff)) }
            get frontSortingLayerID() { return this._frontSortingLayerID }
            set frontSortingLayerID(t) { this._isCustomRangeActive && this._frontSortingLayerID !== t && (this._frontSortingLayerID = t, this._dirty = !0) }
            get frontSortingOrder() { return this._frontSortingOrder }
            set frontSortingOrder(t) { this._isCustomRangeActive && this._frontSortingOrder !== t && (this._frontSortingOrder = t, this._dirty = !0) }
            get backSortingLayerID() { return this._backSortingLayerID }
            set backSortingLayerID(t) { this._isCustomRangeActive && this._backSortingLayerID !== t && (this._backSortingLayerID = t, this._dirty = !0) }
            get backSortingOrder() { return this._backSortingOrder }
            set backSortingOrder(t) { this._isCustomRangeActive && this._backSortingOrder !== t && (this._backSortingOrder = t, this._dirty = !0) }
            get sprite() { return this._sprite }
            set sprite(t) { this._sprite !== t && (this._sprite = t, this.model.setParameter("_MainTex", this._sprite.texture), this.model.mesh = this._sprite.getMesh()) }
            onEnable() { return !!pc.RendererComponent.prototype.onEnable.call(this) && (this.model._stencil = t, this.model.setParameter("_Cutoff", this.alphaCutoff), !0) }
            updateMaskRange() { this._dirty && (this.isCustomRangeActive ? (this.model.meshInstances[0].sortingOrder = this.backSortingOrder, this.model.meshInstances[0].sortingLayerIndex = UnityEngine.SortingLayer.GetLayerValueFromID(this.backSortingLayerID), this.model.meshInstances[1].sortingOrder = this.frontSortingOrder, this.model.meshInstances[1].sortingLayerIndex = UnityEngine.SortingLayer.GetLayerValueFromID(this.frontSortingLayerID)) : (this.model.meshInstances[0].sortingOrder = 0, this.model.meshInstances[0].sortingLayerIndex = -1, this.model.meshInstances[1].sortingOrder = 0, this.model.meshInstances[1].sortingLayerIndex = Number.MAX_SAFE_INTEGER), this._dirty = !1) }
            changeStencilToAdditionalDrawCall() { const t = this.model.meshInstances.length; return !(!this._dirty || 0 === t) && (this.model.meshInstances[1].stencilFront = e, this.model.meshInstances[1].stencilBack = e, this.updateMaskRange(), !0) }
            getMeshInstancesForRender() { return null != this.model._mesh && (this.model._mesh.subMeshes.length = 2, this.model._mesh.subMeshes[1] = this.model._mesh.subMeshes[0], this.changeStencilToAdditionalDrawCall()), this.code.OnBeforeRender && this.code.OnBeforeRender(), this.model.update(), this.model.meshInstances }
        }
        return { SpriteMaskComponent: i }
    }()), Object.assign(pc, function() {
        class t extends pc.RendererComponent {
            constructor(t) { super(), this.meshFilter = null, this.code = new UnityEngine.MeshRenderer(this) }
            onEnable() { return !!pc.RendererComponent.prototype.onEnable.call(this) && (this.updateMesh(), !0) }
            getMeshInstancesForRender() { return this.synchronizeWithEntity(), this.updateMesh(), this.model.update(), this.model.meshInstances }
            updateMesh() {
                this.meshFilter && !this.meshFilter._destroyed || (this.meshFilter = this.entity.getUnityComponent("meshFilter"));
                const t = null != this.meshFilter ? this.meshFilter.mesh : null;
                this.model.mesh !== t && (this.model.mesh = t)
            }
        }
        return { MeshRendererComponent: t }
    }()), Object.assign(pc, function() {
        class t extends pc.RendererComponent { constructor(t) { super(), this.code = new UnityEngine.SkinnedMeshRenderer(this) } }
        return { SkinnedMeshRendererComponent: t }
    }()), Object.assign(pc, function() {
        class t extends pc.RendererComponent {
            constructor(t) { super(), this.code = new UnityEngine.LineRenderer(this) }
            onEnable() { return !!pc.RendererComponent.prototype.onEnable.call(this) && (this.code.OnEnable(), !0) }
        }
        return { LineRendererComponent: t }
    }()), Object.assign(pc, function() {
        class t extends pc.RendererComponent {
            constructor(t) { super(), this.code = new UnityEngine.TrailRenderer(this) }
            _queuesToSubscribe() { return ["onUpdate"] }
            onEnable() { return !!pc.RendererComponent.prototype.onEnable.call(this) && (this.code.OnEnable(), !0) }
            onUpdate(t) { this.code.Update() }
        }
        return { TrailRendererComponent: t }
    }()), Object.assign(pc, function() {
        const t = new pc.Mat4,
            e = new pc.Vec3,
            i = function(t) { this.options = t, this._rigidbodies = [], this._fauxBodies = {}, this._colliders = [], this._constraints = [], this._isSimulating = !1, this.setup() };
        return i.PreSyncStages = { TransformToPhysics: 1, PhysicsToTransform: 2 }, i.prototype = {
            enableRigidbody: function(t) { t.body._component = t, this.addRigidbody(t.body), this._rigidbodies.push(t), this.reattachCollidersInChildren(t.entity) },
            disableRigidbody: function(t) {
                const e = this._rigidbodies,
                    i = e.indexOf(t);
                i < 0 || (this.removeRigidbody(t.body), t.body._component = null, e[i] = e[e.length - 1], e.pop(), this.reattachCollidersInChildren(t.entity))
            },
            enableCollider: function(i) {
                i.shape && (i.shape._component = i);
                const n = this.fetchBody(i.entity);
                i._body = n, this.getRelTransformAndAccumScale(n, i, t, e), i.updateShape(t, e, n), this.addCollider(n, i), this._colliders.push(i)
            },
            disableCollider: function(t) {
                const e = this._colliders,
                    i = e.indexOf(t);
                i < 0 || (t._body && this.removeCollider(t._body, t), e[i] = e[e.length - 1], e.length -= 1)
            },
            enableConstraint: function(t) { t.constraint._component = t, this.addConstraint(t), this._constraints.push(t) },
            disableConstraint: function(t) {
                const e = this._constraints,
                    i = e.indexOf(t);
                i < 0 || (this.removeConstraint(t), e[i] = e[e.length - 1], e.length -= 1)
            },
            fetchBody: function(t) {
                let e = t;
                for (; e;) {
                    if (e._enabledInHierarchy) { const t = this.getAttachedRigidbody(e); if (t) return t }
                    e = e._parent
                }
                let i = this._fauxBodies[t._guid];
                return i || (i = this._fauxBodies[t._guid] = this.attachFauxRigidbody(t), i._body = i, i._entity = t, i)
            },
            onFixedUpdate: function(t) { this._isSimulating = !0, this.onBeforeSimulation(), this.onSimulationStep(t), this.onAfterSimulation(), this._isSimulating = !1 },
            onBeforeSimulation: function() {
                let t, e = this._rigidbodies;
                e.sort(this.compareBodyDepths);
                let n = e.length;
                for (t = 0; t < n; t++) this.preSimulationSynchronization(e[t], i.PreSyncStages.TransformToPhysics);
                for (t = 0; t < n; t++) this.preSimulationSynchronization(e[t], i.PreSyncStages.PhysicsToTransform);
                e = this._fauxBodies;
                for (const t in e) this.preSimulationSynchronization(e[t], i.PreSyncStages.TransformToPhysics);
                for (e = this._constraints, n = e.length, t = 0; t < n; ++t) this.updateConstraint(e[t]);
                for (e = this._colliders, n = e.length, t = 0; t < n; t++) this.preSimulationSynchronizationForCollider(e[t])
            },
            onAfterSimulation: function() {
                let t, e, i = this._rigidbodies,
                    n = i.length;
                for (e = 0; e < n; e++) {
                    t = i[e], this.postSimulationSynchronization(t);
                    const n = t._entity;
                    t._worldTransformVersion = n.aabbVersion
                }
                for (i = this._colliders, n = i.length, e = 0; e < n; e++) {
                    t = i[e];
                    const n = t._entity;
                    t._worldTransformVersion = n.aabbVersion
                }
                this.handleContacts()
            },
            compareBodyDepths: function(t, e) { return t._entity.graphDepth - e._entity.graphDepth },
            dispatchContact: function(t, e, i) { return t.sendPhysicsEvent(e, i) },
            entityHasEventListeners: function(t, e) { return t._magicMethods && t._magicMethods[e] },
            setIgnoreCollisionBetweenLayers: function(t, e, i) {
                const n = this._world.collision_matrix,
                    s = n[t] = n[t] || 0,
                    r = n[e] = n[e] || 0;
                i ? (n[t] = s | 1 << e, n[e] = r | 1 << t) : (n[t] = s & ~(1 << e), n[e] = r & ~(1 << t))
            },
            reattachCollidersInChildren: function(t) {
                if (!t._enabledInHierarchy) return;
                const e = this.getAttachedColliders(t);
                for (let i = 0; i < e.length; i++) { const n = e[i];!n.enabled || !n._body || n._body._component && n._body._component._entity === t || (this.disableCollider(n), this.enableCollider(n)) }
                const i = t._children;
                for (let t = 0, e = i.length; t < e; t++) {
                    const e = i[t];
                    this.getAttachedRigidbody(e) || this.reattachCollidersInChildren(e)
                }
            },
            syncHierarchy: function(t) {
                if (t._enabledInHierarchy) {
                    if (this.getAttachedRigidbody(t)) return;
                    this.reattachCollidersInChildren(t)
                }
            },
            syncTransformsInChildren: function(t) {
                if (!t._enabledInHierarchy) return;
                const e = this.getAttachedRigidbody(t);
                let n = e && e._component;
                n && this.preSimulationSynchronization(n, i.PreSyncStages.TransformToPhysics), n = this._fauxBodies[t._guid], n && this.preSimulationSynchronization(n, i.PreSyncStages.TransformToPhysics);
                const s = this.getAttachedColliders(t);
                for (let t = 0; t < s.length; t++) {
                    const e = s[t];
                    e.enabled && e._body && this.preSimulationSynchronizationForCollider(e)
                }
                const r = t._children;
                for (let t = 0, e = r.length; t < e; t++) this.syncTransformsInChildren(r[t])
            },
            syncTransforms: function(t) { this._isSimulating || this.syncTransformsInChildren(t) },
            setup: function() { throw new Error("Not Implemented") },
            onSimulationStep: function(t) { throw new Error("Not Implemented") },
            getAttachedColliders: function(t) { throw new Error("Not Implemented") },
            getAttachedRigidbody: function(t) { throw new Error("Not Implemented") },
            attachFauxRigidbody: function(t) { throw new Error("Not Implemented") },
            addRigidbody: function(t) { throw new Error("Not Implemented") },
            removeRigidbody: function(t) { throw new Error("Not Implemented") },
            addCollider: function(t, e) { throw new Error("Not Implemented") },
            removeCollider: function(t, e) { throw new Error("Not Implemented") },
            handleContacts: function() { throw new Error("Not Implemented") },
            addConstraint: function(t) { throw new Error("Not Implemented") },
            removeConstraint: function(t) { throw new Error("Not Implemented") },
            getRelTransformAndAccumScale: function(t, e, i, n) { throw new Error("Not Implemented") },
            updateConstraint: function(t) { throw new Error("Not Implemented") },
            preSimulationSynchronization: function(t, e) { throw new Error("Not Implemented") },
            preSimulationSynchronizationForCollider: function(i) {
                const n = i._entity.aabbVersion;
                i._worldTransformVersion !== n && (this.getRelTransformAndAccumScale(i._body, i, t, e), i.updateShape(t, e), i._worldTransformVersion = n)
            },
            postSimulationSynchronization: function(t) { throw new Error("Not Implemented") }
        }, { BasePhysicsAdapter: i }
    }()), Object.assign(pc, function() {
        const t = new pc.Vec3,
            e = new pc.Quat,
            i = new pc.Vec3,
            n = new pc.Quat,
            s = new Goblin.Vector3,
            r = new Goblin.Quaternion,
            o = function(t) { pc.BasePhysicsAdapter.call(this, t) };
        return (o.prototype = Object.create(pc.BasePhysicsAdapter.prototype)).constructor = o, Object.assign(o.prototype, {
            setup: function() { this.wheelColliders = [], this._world = this.options.world, this._world.eventEmitter._onCollisionContactEnter = this.onCollisionContactEnter.bind(this), this._world.eventEmitter._onCollisionContactStay = this.onCollisionContactStay.bind(this), this._world.eventEmitter._onCollisionContactExit = this.onCollisionContactExit.bind(this), this._world.eventEmitter._onTriggerContactEnter = this.onTriggerContactEnter.bind(this), this._world.eventEmitter._onTriggerContactStay = this.onTriggerContactStay.bind(this), this._world.eventEmitter._onTriggerContactExit = this.onTriggerContactExit.bind(this), this.integratedTime = 0, this.integratedPhysicsTime = 0 },
            addRigidbody: function(t) { t.world || (this.synchronizeBodyWithEntity(t._component || t._fauxComponent), this._world.addRigidBody(t)) },
            removeRigidbody: function(t) { this._world.removeRigidBody(t) },
            addCollider: function(t, e) { e._shape && (t.shape.addChildShape(e._shape, e.getColliderPositionGoblin(), e.getColliderRotationGoblin()), t.onShapeUpdated(), this.preSimulationSynchronizationForCollider(e)) },
            removeCollider: function(t, e) { e._shape && (t.shape.removeChildShape(e.id), t.onShapeUpdated()) },
            enableWheelCollider: function(t) { this.wheelColliders.push(t) },
            disableWheelCollider: function(t) { const e = this.wheelColliders.indexOf(t); - 1 !== e && (this.wheelColliders[e] = this.wheelColliders[this.wheelColliders.length - 1], this.wheelColliders.pop()) },
            addConstraint: function(t) { this._world.addConstraint(t.constraint) },
            removeConstraint: function(t) { this._world.removeConstraint(t.constraint) },
            onSimulationStep: function(t) { this._world.step(t) },
            getAttachedColliders: function(t) { return t._unityComponents.collider },
            getAttachedRigidbody: function(t) {
                const e = t._unityComponents.rigidbody[0];
                if (!e) return null;
                const i = e.enabled,
                    n = !!e._body && !!e._body._component;
                return i && n ? e._body : null
            },
            attachFauxRigidbody: function(t) {
                const e = new Goblin.RigidBody(-1, 1 / 0),
                    i = pc.RigidbodyComponent.fromStaticBody(e);
                return i.useGravity = !1, i.isStatic = !0, i.entity = t, i._entity = t, this.addRigidbody(e), this.synchronizeBodyWithEntity(i), e
            },
            getRelTransformAndAccumScale: function(t, e, i, n) {},
            synchronizeBodyWithEntity: function(t, e = !0, i = !0) {
                const n = t._entity,
                    o = t._body,
                    a = n.getPosition(),
                    c = n.getRotation();
                s.set(a.x, a.y, a.z), r.set(c.x, c.y, c.z, c.w), e && i ? (o.setTransform(s, r), t._previousSyncPosition.copy(a), t.interpolatedPosition.copy(a), t._previousSyncRotation.copy(c), t.interpolatedRotation.copy(c)) : e ? (o.setPosition(s), t._previousSyncPosition.copy(a), t.interpolatedPosition.copy(a)) : (o.setRotation(r), t._previousSyncRotation.copy(c), t.interpolatedRotation.copy(c)), t.interpolatedFraction = 0, t.interpolatedAABBVersion = n.aabbVersion
            },
            synchronizeEntityWithBody: function(i, n = !0, s = !0) {
                const r = i.entity;
                i.body.getTransform(t, e);
                const o = r.getPosition(),
                    a = r.getRotation();
                if (n && !o.equals(t)) {
                    const e = i.constraints;
                    let n = !1;
                    e & UnityEngine.RigidbodyConstraints.FreezePositionX && (t.x = o.x, n = !0), e & UnityEngine.RigidbodyConstraints.FreezePositionY && (t.y = o.y, n = !0), e & UnityEngine.RigidbodyConstraints.FreezePositionZ && (t.z = o.z, n = !0), r.setPosition(t), n && (i.position = t), i._previousSyncPosition.copy(t), i.interpolatedPosition.copy(t), i.interpolatedFraction = 0
                }
                s && Math.abs(a.dot(e)) < 1 - Goblin.EPSILON && (r.setRotation(e), i._previousSyncRotation.copy(e), i.interpolatedRotation.copy(e), i.interpolatedFraction = 0)
            },
            updateConstraint: function(t) {},
            synchronizeBodyTransform: function(t) {},
            preSimulationSynchronization: function(t, e) {
                t._fauxComponent && (t = t._fauxComponent);
                const i = t._body,
                    n = t._entity;
                if (!t.isInterpolationOrExtrapolationEnabled() || !i.isDynamic || n.aabbVersion !== t.interpolatedAABBVersion) {
                    if (e === pc.BasePhysicsAdapter.PreSyncStages.TransformToPhysics) {
                        if (!(t._worldTransformVersion !== n.aabbVersion)) return;
                        const e = !t._previousSyncPosition.equals(n.getPosition()),
                            i = !t._previousSyncRotation.equals(n.getRotation());
                        return this.synchronizeBodyWithEntity(t, e, i), void(t._worldTransformVersion = n.aabbVersion)
                    }
                    if (e === pc.BasePhysicsAdapter.PreSyncStages.PhysicsToTransform) {
                        const e = !i.isKinematic || t._dirtyPosition,
                            n = !i.isKinematic || t._dirtyRotation;
                        if (!e && !n) return;
                        this.synchronizeEntityWithBody(t, e, n), t._dirtyPosition = !1, t._dirtyRotation = !1
                    }
                }
            },
            preSimulationSynchronizationForCollider: function(t) { pc.BasePhysicsAdapter.prototype.preSimulationSynchronizationForCollider.call(this, t), t.layer = t.entity.cullingLayer },
            postSimulationSynchronization: function(i) {
                const n = i._entity,
                    s = i._body,
                    r = i._worldTransformVersion !== n.aabbVersion;
                if (s.isKinematic) r && this.synchronizeBodyWithEntity(i);
                else if (!s.isStatic || r) {
                    if (s.isDynamic && i.shouldInterpolatePosition()) return n.setPosition(i._previousSyncPosition), n.setRotation(i._previousSyncRotation), i.interpolatedPosition.copy(n.getPosition()), i.interpolatedRotation.copy(n.getRotation()), i.interpolatedFraction = 0, i.interpolatedAABBVersion = n.aabbVersion, s.getTransform(t, e), i._previousSyncPosition.copy(t), void i._previousSyncRotation.copy(e);
                    this.synchronizeEntityWithBody(i), s.isDynamic && i.shouldExtrapolatePosition() && (i.interpolatedPosition.copy(n.getPosition()), i.interpolatedRotation.copy(n.getRotation()), i.interpolatedFraction = 0, i.interpolatedAABBVersion = n.aabbVersion)
                }
            },
            onFixedUpdate: function(t) {
                this.integratedPhysicsTime += t;
                for (let t = 0; t < this.wheelColliders.length; t++) this.wheelColliders[t].fixedUpdate();
                pc.BasePhysicsAdapter.prototype.onFixedUpdate.call(this, t), this._world.emitEvents()
            },
            handleContacts: function() {},
            onUpdate: function(t) {
                this.integratedTime += t * UnityEngine.Time.timeScale;
                const e = this._getPhysicsSystem(),
                    i = e.autoSyncTransforms;
                e.autoSyncTransforms = !1;
                for (let t = 0; t < this._rigidbodies.length; t++) {
                    const e = this._rigidbodies[t];
                    e.body.isDynamic && (e.shouldInterpolatePosition() ? this._interpolatePosition(e) : e.shouldExtrapolatePosition() && this._extrapolatePosition(e))
                }
                i && (e.autoSyncTransforms = !0)
            },
            onTriggerContactEnter: function(t) { this.emitTriggerContactEvent("OnTriggerEnter", t) },
            onTriggerContactStay: function(t) { this.emitTriggerContactEvent("OnTriggerStay", t) },
            onTriggerContactExit: function(t) { this.emitTriggerContactEvent("OnTriggerExit", t) },
            emitTriggerContactEvent: function(t, e) {
                const i = e.shape_a._component,
                    n = e.bodyA._component,
                    s = e.shape_b._component,
                    r = e.bodyB._component;
                if (!!i && 0 === i._enabled || !!s && 0 === s._enabled) return;
                let o = !1,
                    a = !1;
                this.componentHasEventListeners(i, t) && (o = this.dispatchContact(i._entity, t, s.code)), this.componentHasEventListeners(s, t) && (a = this.dispatchContact(s._entity, t, i.code)), o = o && !!n && n.entity === i.entity, a = a && !!r && r.entity === s.entity, !o && this.componentHasEventListeners(n, t) && this.dispatchContact(n._entity, t, s.code), !a && this.componentHasEventListeners(r, t) && this.dispatchContact(r._entity, t, i.code)
            },
            onCollisionContactEnter: function(t) { this.emitCollisionContactEvent("OnCollisionEnter", t) },
            onCollisionContactStay: function(t) { this.emitCollisionContactEvent("OnCollisionStay", t) },
            onCollisionContactExit: function(t) { this.emitCollisionContactEvent("OnCollisionExit", t) },
            emitCollisionContactEvent: function(t, e) {
                const i = e.shape_a._component,
                    n = e.shape_b._component,
                    s = e.bodyA._component,
                    r = e.bodyB._component;
                let o = !1,
                    a = !1;
                this.componentHasEventListeners(s, t) && (o = this.dispatchContact(s._entity, t, UnityEngine.Object.FromHandle(UnityEngine.Collision, e).ConfigureFor(0))), this.componentHasEventListeners(r, t) && (a = this.dispatchContact(r._entity, t, UnityEngine.Object.FromHandle(UnityEngine.Collision, e).ConfigureFor(1))), !o && this.componentHasEventListeners(i, t) && this.dispatchContact(i._entity, t, UnityEngine.Object.FromHandle(UnityEngine.Collision, e).ConfigureFor(0)), !a && this.componentHasEventListeners(n, t) && this.dispatchContact(n._entity, t, UnityEngine.Object.FromHandle(UnityEngine.Collision, e).ConfigureFor(1))
            },
            componentHasEventListeners: function(t, e) { return !!t && !!t._entity && !!t._entity._enabledInHierarchy && this.entityHasEventListeners(t._entity, e) },
            setIgnoreCollisionBetweenLayers: function(t, e, i) { pc.BasePhysicsAdapter.prototype.setIgnoreCollisionBetweenLayers.call(this, t, e, i), this._world.onCollisionMatrixUpdated() },
            _interpolatePosition: function(s) {
                const r = s.entity,
                    o = s.body;
                if (r.aabbVersion !== s.interpolatedAABBVersion) return;
                const a = this.integratedPhysicsTime,
                    c = a + UnityEngine.Time.fixedDeltaTime,
                    h = this.integratedTime;
                if (a === h || c < h) return;
                const l = (h - a) / (c - a),
                    u = (l - s.interpolatedFraction) / (1 - s.interpolatedFraction);
                o.getTransform(t, e), i.sub2(t, s.interpolatedPosition), i.scale(u), i.add(s.interpolatedPosition), r.setPosition(i), n.slerp(s.interpolatedRotation, e, u), r.setRotation(n), s.interpolatedPosition.copy(r.getPosition()), s.interpolatedRotation.copy(r.getRotation()), s.interpolatedFraction = l, s.interpolatedAABBVersion = r.aabbVersion
            },
            _extrapolatePosition: function(t) {
                const e = t.entity;
                if (e.aabbVersion !== t.interpolatedAABBVersion) return;
                const s = this.integratedPhysicsTime,
                    r = s + UnityEngine.Time.fixedDeltaTime,
                    o = this.integratedTime;
                if (s === o || r < o) return;
                const a = (o - s) / (r - s),
                    c = (r - s) * (a - t.interpolatedFraction);
                i.copy(t.velocity), i.scale(c), i.add(t.interpolatedPosition), e.setPosition(i), i.copy(t.angularVelocity);
                let h = i.length();
                h * c > Math.PI / 4 && (h = Math.PI / 4 / c), h < .001 ? i.scale(.5 * c - c * c * c * .020833333333 * h * h) : i.scale(Math.sin(.5 * h * c) / h), n.x = i.x, n.y = i.y, n.z = i.z, n.w = Math.cos(h * c * .5), n.mul(t.interpolatedRotation), e.setRotation(n), t.interpolatedPosition.copy(e.getPosition()), t.interpolatedRotation.copy(e.getRotation()), t.interpolatedFraction = a, t.interpolatedAABBVersion = e.aabbVersion
            },
            _getPhysicsSystem: () => pc.Application.getApplication().systems.physics
        }), { PhysicsAdapter: o }
    }()), Object.assign(pc, function() {
        const t = new pc.Vec3;
        class e extends pc.UnityComponentSystem {
            constructor(t) { super(t), this.id = "physics", this.performanceSamplerSection = pc.Counters.PHYSICS, this._autoSyncTransforms = !1, this._autoSimulation = !0, this.initializePhysicsEngine() }
            initializePhysicsEngine() { this._world = Goblin.World.initialize(), this._adapter = new pc.PhysicsAdapter({ world: this._world }) }
            onFixedUpdate(t) { this._autoSimulation && this.simulate(t) }
            simulate(t) { this._adapter.onFixedUpdate(t) }
            onUpdate(t) { this._adapter.onUpdate(t) }
            setIgnoreCollisionBetweenLayers(t, e, i) { this._adapter.setIgnoreCollisionBetweenLayers(t, e, i) }
            syncHierarchy(t) { this._adapter.syncHierarchy(t) }
            syncTransforms(t) { this._autoSyncTransforms && this._adapter.syncTransforms(t) }
            get gravity() { const e = this._world.gravity; return t.set(e.x, e.y, e.z), t }
            set gravity(t) { this._world.gravity.set(t.x, t.y, t.z) }
            get defaultSolverIterations() { return this._world.solver.max_iterations }
            set defaultSolverIterations(t) { this._world.solver.max_iterations = t }
            get adapter() { return this._adapter }
            get autoSyncTransforms() { return this._autoSyncTransforms }
            set autoSyncTransforms(t) { this._autoSyncTransforms = t }
            get autoSimulation() { return this._autoSimulation }
            set autoSimulation(t) { this._autoSimulation = t }
        }
        return { PhysicsSystem: e }
    }()), Object.assign(pc, function() {
        class t extends pc.UnityComponentSystem {
            constructor(t) { super(t), this.id = "rigidbody", this.performanceSamplerSection = pc.Counters.PHYSICS, this._world = t.systems.physics._world, this._bodies = {}, this._contacts = {}, this._previousContacts = {} }
            removeComponent(t, e) { e.onDisable(), pc.UnityComponentSystem.prototype.removeComponent.call(this, t, e) }
        }
        return { RigidbodySystem: t }
    }()), Object.assign(pc, function() {
        const t = new pc.Vec3,
            e = new Goblin.Vector3,
            i = new Goblin.Vector3,
            n = new Goblin.Quaternion,
            s = new pc.Vec3,
            r = new pc.Quat;

        function o(t) {
            switch (t) {
                case 0:
                    return Goblin.RigidBody.CollisionDetectionMode.Discrete;
                case 1:
                case 2:
                    return Goblin.RigidBody.CollisionDetectionMode.ContinuousConservativeAdvancement;
                case 3:
                    return Goblin.RigidBody.CollisionDetectionMode.ContinuousSpeculative;
                default:
                    throw new Error("Unrecognized collision detection mode")
            }
        }
        class a extends pc.UnityComponent {
            constructor(t = {}) {
                super();
                const e = { mass: 1, drag: 0, angularDrag: 0, useGravity: !0, isKinematic: !1, collisionDetectionMode: 0, enabled: !0, maxAngularVelocity: 7, constraints: 0, interpolation: UnityEngine.RigidbodyInterpolation.None, goblinBody: null };
                t = Object.assign(e, t), this.id = a.uid++, this._body = t.goblinBody || new Goblin.RigidBody(this.id, t.mass), this._body._component = this, this._body.linear_damping = t.drag || 0, this._body.angular_damping = t.angularDrag || 0, this._body.useGravity = !!t.useGravity, this._body.isKinematic = t.isKinematic, this._body.collisionDetectionMode = o(t.collisionDetectionMode), this._body.maxAngularVelocity = t.maxAngularVelocity, this._enabled = t.enabled, this._collisionDetectionMode = t.collisionDetectionMode, this.constraints = t.constraints || 0, this.interpolation = t.interpolation || UnityEngine.RigidbodyInterpolation.None, this._previousSyncPosition = new pc.Vec3, this._previousSyncRotation = new pc.Quat, this.interpolatedPosition = new pc.Vec3, this.interpolatedRotation = new pc.Quat, this.interpolatedFraction = 0, this.interpolatedAABBVersion = 0, this._dirtyPosition = !1, this._dirtyRotation = !1, this._adapter = pc.Application.getApplication().systems.physics.adapter
            }
            get body() { return this._body }
            get position() { const t = new pc.Vec3; return this._body.getTransform(t, r), t }
            set position(t) { e.set(t.x, t.y, t.z), this._body.setPosition(e), this._dirtyPosition = !0 }
            get constraints() { let t = 0; return this._body.positionLockX && (t |= UnityEngine.RigidbodyConstraints.FreezePositionX), this._body.positionLockY && (t |= UnityEngine.RigidbodyConstraints.FreezePositionY), this._body.positionLockZ && (t |= UnityEngine.RigidbodyConstraints.FreezePositionZ), this._body.rotationLockX && (t |= UnityEngine.RigidbodyConstraints.FreezeRotationX), this._body.rotationLockY && (t |= UnityEngine.RigidbodyConstraints.FreezeRotationY), this._body.rotationLockZ && (t |= UnityEngine.RigidbodyConstraints.FreezeRotationZ), t }
            set constraints(t) { this._body.positionLockX = !!(t & UnityEngine.RigidbodyConstraints.FreezePositionX), this._body.positionLockY = !!(t & UnityEngine.RigidbodyConstraints.FreezePositionY), this._body.positionLockZ = !!(t & UnityEngine.RigidbodyConstraints.FreezePositionZ), this._body.rotationLockX = !!(t & UnityEngine.RigidbodyConstraints.FreezeRotationX), this._body.rotationLockY = !!(t & UnityEngine.RigidbodyConstraints.FreezeRotationY), this._body.rotationLockZ = !!(t & UnityEngine.RigidbodyConstraints.FreezeRotationZ), this._body.wakeUp() }
            get rotation() { return (new pc.Quat).copy(this._body.getRotation()) }
            set rotation(t) { n.set(t.x, t.y, t.z, t.w), this._body.setRotation(n), this._dirtyRotation = !0 }
            get angularDrag() { return this._body.angular_damping }
            set angularDrag(t) { this._body.angular_damping = t }
            get drag() { return this._body.linear_damping }
            set drag(t) { this._body.linear_damping = t }
            get angularVelocity() { return (new pc.Vec3).copy(this._body.angular_velocity) }
            set angularVelocity(t) { e.x = t.x, e.y = t.y, e.z = t.z, this._body.setAngularVelocity(e) }
            get velocity() { return (new pc.Vec3).copy(this._body.linear_velocity) }
            set velocity(t) { e.x = t.x, e.y = t.y, e.z = t.z, this._body.setLinearVelocity(e) }
            get centerOfMass() { return (new pc.Vec3).copy(this._body.getCenterOfMass()) }
            set centerOfMass(t) { e.set(t.x, t.y, t.z), this._body.overrideCenterOfMass(e) }
            get mass() { return this._body.mass }
            set mass(t) { this._body.mass = t }
            get maxAngularVelocity() { return this._body.maxAngularVelocity }
            set maxAngularVelocity(t) { this._body.maxAngularVelocity = t }
            get inertiaTensor() { const t = this.body.getDiagonalizedInertiaTensor(); return s.set(t.x, t.y, t.z), s }
            set inertiaTensor(t) { throw new Error("Not implemented") }
            get inertiaTensorRotation() { const t = this.body.getDiagonalizedInertiaTensorRotation(); return r.set(t.x, t.y, t.z, t.w), r }
            set inertiaTensorRotation(t) { throw new Error("Not implemented") }
            get isKinematic() { return this._body.isKinematic }
            set isKinematic(t) { this._body.isKinematic = t }
            get isStatic() { return this._body.isStatic }
            set isStatic(t) { this._body.isStatic = t }
            get useGravity() { return this._body.useGravity }
            set useGravity(t) { this._body.useGravity = t }
            get disableCollisions() { return this._body.disableCollisions }
            set disableCollisions(t) { this._body.disableCollisions = t }
            get collisionDetectionMode() { return this._collisionDetectionMode }
            set collisionDetectionMode(t) { this._body.collisionDetectionMode = o(t), this._collisionDetectionMode = t }
            addLinearForce(e, i, n) {
                switch (t.copy(e), n && this._body.getRotation().transformVector3(t), i) {
                    case UnityEngine.ForceMode.Force:
                        t.scale(UnityEngine.Time.fixedDeltaTime), this._body.addLinearImpulse(t);
                        break;
                    case UnityEngine.ForceMode.Acceleration:
                        t.scale(this._body.mass), t.scale(UnityEngine.Time.fixedDeltaTime), this._body.addLinearImpulse(t);
                        break;
                    case UnityEngine.ForceMode.Impulse:
                        t.scale(1 / this._body.mass), this._body.addLinearVelocity(t);
                        break;
                    case UnityEngine.ForceMode.VelocityChange:
                        this._body.addLinearVelocity(t);
                        break;
                    default:
                        throw new Error("Not Implemented")
                }
            }
            addLinearForceAtPosition(n, s, r) {
                switch (t.copy(n), e.set(s.x, s.y, s.z), r) {
                    case UnityEngine.ForceMode.Force:
                        t.scale(UnityEngine.Time.fixedDeltaTime), i.set(t.x, t.y, t.z), this._body.applyImpulseAtWorldPoint(i, e);
                        break;
                    case UnityEngine.ForceMode.Acceleration:
                        t.scale(this._body.mass), t.scale(UnityEngine.Time.fixedDeltaTime), i.set(t.x, t.y, t.z), this._body.applyImpulseAtWorldPoint(i, e);
                        break;
                    case UnityEngine.ForceMode.Impulse:
                        i.set(t.x, t.y, t.z), this._body.applyImpulseAtWorldPoint(i, e);
                        break;
                    case UnityEngine.ForceMode.VelocityChange:
                        t.scale(this._body.mass), i.set(t.x, t.y, t.z), this._body.applyImpulseAtWorldPoint(i, e);
                        break;
                    default:
                        throw new Error("Not Implemented")
                }
            }
            getPointVelocity(t) { e.set(t.x, t.y, t.z), this._body.getVelocityInGlobalPoint(e, i); const n = new pc.Vec3; return n.set(i.x, i.y, i.z), n }
            addAngularForce(e, i, n) {
                switch (t.copy(e), n && this._body.getRotation().transformVector3(t), i) {
                    case UnityEngine.ForceMode.Force:
                        t.scale(UnityEngine.Time.fixedDeltaTime), this._body.addAngularImpulse(t);
                        break;
                    case UnityEngine.ForceMode.Acceleration:
                        t.scale(UnityEngine.Time.fixedDeltaTime), this._body.addAngularVelocity(t);
                        break;
                    case UnityEngine.ForceMode.Impulse:
                        this._body.addAngularImpulse(t);
                        break;
                    case UnityEngine.ForceMode.VelocityChange:
                        this._body.addAngularVelocity(t);
                        break;
                    default:
                        throw new Error("Not Implemented")
                }
            }
            onEnable() { return !!pc.UnityComponent.prototype.onEnable.call(this) && (this._adapter.enableRigidbody(this), !0) }
            onDisable() { return !!pc.UnityComponent.prototype.onDisable.call(this) && (this._adapter.disableRigidbody(this), !0) }
            movePosition(t) { e.set(t.x, t.y, t.z), this._body.setPosition(e), this._dirtyPosition = !0 }
            moveRotation(t) { n.set(t.x, t.y, t.z, t.w), this._body.setRotation(n), this._dirtyRotation = !0 }
            rayIntersect(t, n, s) { e.set(t.x, t.y, t.z), i.set(n.x, n.y, n.z); const r = []; return this._body.rayIntersect(e, i, s, -1, !0, r), r }
            closestPointOnBounds(t) { e.set(t.x, t.y, t.z), this._body.getClosestPointOnBounds(e, i); const n = new pc.Vec3; return n.set(i.x, i.y, i.z), n }
            wakeUp() { this._body.wakeUp(!0) }
            sleep() { this._body.isSleeping = !0 }
            isSleeping() { return this._body.isSleeping }
            resetCenterOfMass() { this._body.resetCenterOfMass() }
            isInterpolationOrExtrapolationEnabled() { return this.interpolation !== UnityEngine.RigidbodyInterpolation.None }
            shouldInterpolatePosition() { return this.interpolation === UnityEngine.RigidbodyInterpolation.Interpolate }
            shouldExtrapolatePosition() { return this.interpolation === UnityEngine.RigidbodyInterpolation.Extrapolate }
        }
        return a.uid = 0, a.fromStaticBody = t => { const e = new a({ goblinBody: t }); return t.id = e.id, t._component = null, t._fauxComponent = e, e }, { RigidbodyComponent: a }
    }()), Object.assign(pc, function() {
        class t extends pc.UnityComponentSystem {
            constructor(t) { super(t), this.id = "collider", this.performanceSamplerSection = pc.Counters.PHYSICS, this._world = t.systems.physics._world }
            removeComponent(t, e) { e.onDisable(), pc.UnityComponentSystem.prototype.removeComponent.call(this, t, e) }
        }
        return { ColliderSystem: t }
    }()), Object.assign(pc, function() {
        const t = new pc.Vec3,
            e = new pc.Quat,
            i = new Goblin.Vector3,
            n = new Goblin.Vector3;

        function s(t, e) { return Math.round(t * (1 / e)) * e }
        class r extends pc.UnityComponent {
            constructor(t) { super(), this.id = r.uid++, this._position = t.position, this._enabled = t.enabled, this._isTrigger = t.isTrigger, this._convex = t.convex, this._guid = pc.guid.create(), this._material = t.material, this._relativeTransform = (new pc.Mat4).setIdentity(), this._accumulatedScale = new pc.Vec3(1, 1, 1), this._colliderPosition = new pc.Vec3, this._colliderRotation = new pc.Quat, this._colliderPositionGoblin = new Goblin.Vector3, this._colliderRotationGoblin = new Goblin.Quaternion, this._shape = null, this._layer = 0, this._adapter = pc.Application.getApplication().systems.physics.adapter, this._lastBuildParams = {} }
            get code() { return this._code || this.initializeCode(), this._code }
            get bounds() {
                const t = this._body,
                    e = new UnityEngine.Bounds;
                e.setMinMax(pc.Vec3.ZERO, pc.Vec3.ZERO);
                let i = null;
                for (let e = 0; e < t.shape.child_shapes.length; e++)
                    if (t.shape.child_shapes[e].shape === this._shape) { i = t.shape.child_shapes[e]; break }
                if (!i) return e;
                const n = new Goblin.AABB,
                    s = new Goblin.Matrix4;
                return s.makeTransform(t.getRotation(), t.getPosition()), n.transform(i.aabb, s), e.setMinMax((new pc.Vec3).copy(n.min), (new pc.Vec3).copy(n.max)), e
            }
            get shape() { return this._shape }
            get material() { return this._shape.material }
            set material(t) { this._material = t, this._shape.material = t }
            get isTrigger() { return this._isTrigger }
            set isTrigger(t) { this._isTrigger = t, this._shape && this._shape.isTrigger !== t && (this._shape.isTrigger = t, this._body.shape.updateIsTriggerFlag(), this._body.onShapeUpdated()) }
            get layer() { return this._shape.layer }
            set layer(t) { this._layer = t, this.syncLayer() }
            get center() { return this._position }
            set center(t) { this._position.copy(t), this._updateShapeSizeAndPosition() }
            initializeCode() { throw new Error("Not Implemented") }
            getEntity() { return this.entity }
            getAttachedBodyEntity() { return (this._body._component || this._body._fauxComponent)._entity }
            getColliderPositionGoblin() { return this._colliderPositionGoblin.x = this._colliderPosition.x, this._colliderPositionGoblin.y = this._colliderPosition.y, this._colliderPositionGoblin.z = this._colliderPosition.z, this._colliderPositionGoblin }
            getColliderRotationGoblin() { return this._colliderRotationGoblin.x = this._colliderRotation.x, this._colliderRotationGoblin.y = this._colliderRotation.y, this._colliderRotationGoblin.z = this._colliderRotation.z, this._colliderRotationGoblin.w = this._colliderRotation.w, this._colliderRotationGoblin }
            syncLayer() { this._shape && this._shape.layer !== this._layer && (this._shape.layer = this._layer, this._body && this._body.shape.updateLayersMasks()) }
            updateShape() { this._updateShapeSizeAndPosition(), this._layer = this.entity.cullingLayer, this.syncLayer() }
            _calculateRelativePositionAndRotation(t) {
                const e = this.getEntity(),
                    i = this.getAttachedBodyEntity();
                e.transformPoint(t, this._colliderPosition), i.transformPointInverse(this._colliderPosition, this._colliderPosition), this._colliderPosition.mul(i.getLossyScale()), i.transformQuaternionInverse(e.getRotation(), this._colliderRotation)
            }
            _updateShapeSizeAndPosition() { throw new Error("Not Implemented") }
            onAttached() { pc.UnityComponent.prototype.onAttached.call(this), this._layer = this.entity.cullingLayer }
            onEnable() { return !!pc.UnityComponent.prototype.onEnable.call(this) && (this._adapter.enableCollider(this), !0) }
            onDisable() { return !!pc.UnityComponent.prototype.onDisable.call(this) && (this._adapter.disableCollider(this), !0) }
            closestPoint(t) { i.set(t.x, t.y, t.z), this._body.getClosestPointOnShape(this._shape, i, n); const e = new pc.Vec3; return e.set(n.x, n.y, n.z), e }
            closestPointOnBounds(t) { i.set(t.x, t.y, t.z), this._body.getClosestPointOnShapeBounds(this._shape, i, n); const e = new pc.Vec3; return e.set(n.x, n.y, n.z), e }
            rayIntersect(t, e, s) {
                i.set(t.x, t.y, t.z), n.set(e.x, e.y, e.z);
                const r = [];
                this._body.rayIntersect(i, n, s, -1, !0, r);
                for (let t = 0; t < r.length; t++) r[t].shape !== this._shape && (r[t] = r[r.length - 1], r.pop(), t--);
                return r[0] || null
            }
        }
        r.uid = 0;
        class o extends r {
            constructor(t = {}) {
                const e = { center: pc.Vec3.ZERO, size: pc.Vec3.ONE, enabled: !0, material: null, isTrigger: !1 };
                super({ position: (t = Object.assign({}, e, t)).center.clone(), material: t.material, enabled: t.enabled, isTrigger: t.isTrigger }), this._size = t.size.clone(), this._lastBuildParams.colliderSize = new pc.Vec3, this._lastBuildParams.colliderPosition = new pc.Vec3, this._lastBuildParams.colliderRotation = new pc.Quat, this._lastBuildParams.body = null
            }
            get size() { return this._size }
            set size(t) { this._size.copy(t), this._updateShapeSizeAndPosition() }
            _generateConvexHullShape(t, e, i) {
                const n = s(t.x, Goblin.EPSILON) + 1e4 * s(t.y, Goblin.EPSILON) + 1e8 * s(t.z, Goblin.EPSILON),
                    r = o._cache[n];
                if (r) { const t = r.getShallowCopy(); return t.uid = this.id, t._component = this, t.layer = this._layer, t.isTrigger = this._isTrigger, t.material = this._material, t }
                const a = Goblin.ConvexHullShape.fromAABB(this.id, .5 * t.x, .5 * t.y, .5 * t.z, e, i);
                return a._component = this, o._cache[n] = a, a
            }
            _updateShapeSizeAndPosition() {
                this._calculateRelativePositionAndRotation(this._position), this._accumulatedScale.copy(this.entity.getLossyScale()).abs(), t.copy(this._size), t.mul(this._accumulatedScale);
                const e = !this._lastBuildParams.colliderSize.equals(t, Goblin.EPSILON),
                    i = !this._lastBuildParams.colliderPosition.equals(this._colliderPosition, Goblin.EPSILON) || !this._lastBuildParams.colliderRotation.equals(this._colliderRotation),
                    n = this._lastBuildParams.body !== this._body;
                if (!this._shape || e) this._shape = this._generateConvexHullShape(t, this._material, this._isTrigger), this._body.shape.addChildShape(this._shape, this.getColliderPositionGoblin(), this.getColliderRotationGoblin()), this._body.onShapeUpdated();
                else if (n) this._body.shape.addChildShape(this._shape, this.getColliderPositionGoblin(), this.getColliderRotationGoblin()), this._body.onShapeUpdated();
                else {
                    if (!i) return;
                    this._body.shape.updateShapeTransform(this.id, this.getColliderPositionGoblin(), this.getColliderRotationGoblin()), this._body.onShapeUpdated()
                }
                this._lastBuildParams.colliderSize.copy(t), this._lastBuildParams.colliderPosition.copy(this._colliderPosition), this._lastBuildParams.colliderRotation.copy(this._colliderRotation), this._lastBuildParams.body = this._body
            }
            initializeCode() { this._code = new UnityEngine.BoxCollider(this), this["__UnityEngine.BoxCollider"] = this._code, this["__UnityEngine.Collider"] = this._code, this._code.handle = this }
        }
        o._cache = {};
        class a extends r {
            constructor(t = {}) {
                t = Object.assign({}, { material: null, mesh: null, convex: !1, enabled: !0, isTrigger: !1 }, t);
                const e = { position: pc.Vec3.ZERO, material: t.material, enabled: t.enabled, isTrigger: t.isTrigger, convex: t.convex };
                super(e), this._mesh = t.mesh, this._lastBuildParams.mesh = null, this._lastBuildParams.meshVersion = -1, this._lastBuildParams.scale = new pc.Vec3, this._lastBuildParams.colliderPosition = new pc.Vec3, this._lastBuildParams.colliderRotation = new pc.Quat, this._lastBuildParams.body = null, this._lastBuildParams.convex = e.convex
            }
            get sharedMesh() { return this._mesh }
            set sharedMesh(t) { this._mesh = t, this._updateShapeSizeAndPosition() }
            get convex() { return this._convex }
            set convex(t) { this._convex = t, this._updateShapeSizeAndPosition() }
            getCacheKeyForCurrentMesh() { return `${this._mesh.id}-${this._mesh.version}-${s(this._accumulatedScale.x,Goblin.EPSILON)+1e4*s(this._accumulatedScale.y,Goblin.EPSILON)+1e8*s(this._accumulatedScale.z,Goblin.EPSILON)}-${this._convex?1:0}` }
            _updateShapeSizeAndPosition() {
                if (!this._body) return void(this._shape = null);
                if (!this._mesh || 0 === this._mesh.vertexBuffer.numVertices || 0 === this.getMeshTriangleCount()) return this._body.shape.removeChildShape(this.id), void(this._shape = null);
                this._calculateRelativePositionAndRotation(pc.Vec3.ZERO), this._accumulatedScale.copy(this.entity.getLossyScale());
                const t = !this._lastBuildParams.scale.equals(this._accumulatedScale, Goblin.EPSILON) || this._lastBuildParams.mesh !== this._mesh || this._lastBuildParams.meshVersion !== this._mesh.version || this._lastBuildParams.convex !== this._convex,
                    e = !this._lastBuildParams.colliderPosition.equals(this._colliderPosition, Goblin.EPSILON) || !this._lastBuildParams.colliderRotation.equals(this._colliderRotation),
                    i = this._lastBuildParams.body !== this._body;
                if (this._shape)
                    if (t) this._shape = this.generateShape(), this._body.shape.addChildShape(this._shape, this.getColliderPositionGoblin(), this.getColliderRotationGoblin()), this._body.onShapeUpdated();
                    else if (i) this._body.shape.addChildShape(this._shape, this.getColliderPositionGoblin(), this.getColliderRotationGoblin()), this._body.onShapeUpdated();
                else {
                    if (!e) return;
                    this._body.shape.updateShapeTransform(this.id, this.getColliderPositionGoblin(), this.getColliderRotationGoblin()), this._body.onShapeUpdated()
                } else this._shape = this.generateShape(), this._body.shape.addChildShape(this._shape, this.getColliderPositionGoblin(), this.getColliderRotationGoblin()), this._body.onShapeUpdated();
                this._lastBuildParams.colliderPosition.copy(this._colliderPosition), this._lastBuildParams.colliderRotation.copy(this._colliderRotation), this._lastBuildParams.body = this._body, this._lastBuildParams.scale.copy(this._accumulatedScale), this._lastBuildParams.mesh = this._mesh, this._lastBuildParams.meshVersion = this._mesh.version, this._lastBuildParams.convex = this._convex
            }
            generateShape() {
                const t = this.getCacheKeyForCurrentMesh(),
                    e = a._cache[t];
                if (e) { const t = e.getShallowCopy(); return t.uid = this.id, t._component = this, t.layer = this._layer, t.isTrigger = this._isTrigger, t.material = this._material, t }
                const i = new Float32Array(this._mesh.vertexBuffer.storage),
                    n = this._mesh.vertexBuffer.getFormat().getStructureFor(pc.SEMANTIC_POSITION);
                let s = this._mesh.subMeshes || [];
                0 === s.length && (s = [this._mesh]);
                const r = this.getMeshTriangleCount(),
                    o = this._convex ? null : new Array(r),
                    c = this._convex ? null : new Array(r),
                    h = [],
                    l = new Set;
                let u = 0;
                for (let t = 0; t < s.length; t++) {
                    const e = s[t];
                    if (e && e.indexBuffer && e.indexBuffer[0]) {
                        const t = new Uint16Array(e.indexBuffer[0].storage);
                        for (let e = 0; e < t.length; e++) {
                            const s = t[e] * (n.stride / 4) + n.offset,
                                r = i[s + 0],
                                a = i[s + 1],
                                d = i[s + 2],
                                p = r + 1e4 * a + 1e8 * d;
                            let _ = null;
                            if (l.has(p))
                                for (let t = h.length - 1; t >= 0; t--) { const e = h[t]; if (e.x === r && e.y === a && e.z === d) { _ = e; break } }
                            _ || (_ = new Goblin.Vector3(r, a, d), h.push(_), l.add(p)), this._convex || (c[u] = _, o[u] = u), u++
                        }
                    }
                }
                this._convex && Goblin.ConvexHullShape.approximateByAABBIfNecessary(h);
                for (let t = 0; t < h.length; t++) {
                    const e = h[t];
                    e.x *= this._accumulatedScale.x, e.y *= this._accumulatedScale.y, e.z *= this._accumulatedScale.z
                }
                this._convex && Goblin.ConvexHullShape.approximateByAABBIfNecessary(h);
                const d = this._convex ? new Goblin.ConvexHullShape(this.id, h, this._material, !1, this._isTrigger) : new Goblin.MeshShape(this.id, c, o, this._material, this._isTrigger);
                return d._component = this, a._cache[t] = d, d
            }
            getMeshTriangleCount() {
                let t = this._mesh.subMeshes || [];
                0 === t.length && (t = [this._mesh]);
                let e = 0;
                for (let i = 0; i < t.length; i++) {
                    const n = t[i];
                    n && n.indexBuffer && n.indexBuffer[0] && (e += n.indexBuffer[0].numBytes / n.indexBuffer[0].bytesPerIndex)
                }
                return e
            }
            initializeCode() { this._code = new UnityEngine.MeshCollider(this), this["__UnityEngine.MeshCollider"] = this._code, this["__UnityEngine.Collider"] = this._code, this._code.handle = this }
        }
        a._cache = {};
        class c extends pc.UnityComponent {
            constructor(t = {}) { super(), this._adapter = pc.Application.getApplication().systems.physics.adapter }
            get code() { return this._code || this.initializeCode(), this._code }
            initializeCode() { this._code = new UnityEngine.WheelCollider(this), this["__UnityEngine.WheelCollider"] = this._code, this["__UnityEngine.Collider"] = this._code, this._code.handle = this }
            onEnable() { return !!pc.UnityComponent.prototype.onEnable.call(this) && (this._adapter.enableWheelCollider(this), !0) }
            onDisable() { return !!pc.UnityComponent.prototype.onDisable.call(this) && (this._adapter.disableWheelCollider(this), !0) }
            onAwake() { this.code.OnAwake() }
            fixedUpdate() { this.code.FixedUpdate() }
        }
        class h extends pc.UnityComponent {get code() { return this._code || this.initializeCode(), this._code }
            initializeCode() { this._code = new UnityEngine.CharacterController(this), this["__UnityEngine.CharacterController"] = this._code, this["__UnityEngine.Collider"] = this._code, this._code.handle = this }
            onAwake() { this.code.OnAwake() }
        }
        return {
            ColliderComponent: r,
            BoxColliderComponent: o,
            SphereColliderComponent: class extends r {
                constructor(t = {}) {
                    const e = { center: pc.Vec3.ZERO, radius: .5, material: null, enabled: !0, isTrigger: !1 };
                    super({ position: (t = Object.assign({}, e, t)).center.clone(), material: t.material, enabled: t.enabled, isTrigger: t.isTrigger }), this._radius = t.radius, this._lastBuildParams.radius = 0, this._lastBuildParams.colliderPosition = new pc.Vec3, this._lastBuildParams.colliderRotation = new pc.Quat, this._lastBuildParams.body = null
                }
                get radius() { return this._radius }
                set radius(t) { this._radius = t, this._updateShapeSizeAndPosition() }
                _updateShapeSizeAndPosition() {
                    this._calculateRelativePositionAndRotation(this._position), this._accumulatedScale.copy(this.entity.getLossyScale()), this._accumulatedScale.abs();
                    const t = this._radius * Math.max(Math.max(this._accumulatedScale.x, this._accumulatedScale.y), this._accumulatedScale.z),
                        e = Math.abs(this._lastBuildParams.radius - t) > Goblin.EPSILON,
                        i = !this._lastBuildParams.colliderPosition.equals(this._colliderPosition, Goblin.EPSILON) || !this._lastBuildParams.colliderRotation.equals(this._colliderRotation),
                        n = this._lastBuildParams.body !== this._body;
                    if (!this._shape || e) this._shape = new Goblin.SphereShape(this.id, t, this._material, this._isTrigger), this._shape._component = this, this._body.shape.addChildShape(this._shape, this.getColliderPositionGoblin(), this.getColliderRotationGoblin()), this._body.onShapeUpdated();
                    else if (n) this._body.shape.addChildShape(this._shape, this.getColliderPositionGoblin(), this.getColliderRotationGoblin()), this._body.onShapeUpdated();
                    else {
                        if (!i) return;
                        this._body.shape.updateShapeTransform(this.id, this.getColliderPositionGoblin(), this.getColliderRotationGoblin()), this._body.onShapeUpdated()
                    }
                    this._lastBuildParams.radius = t, this._lastBuildParams.colliderPosition.copy(this._colliderPosition), this._lastBuildParams.colliderRotation.copy(this._colliderRotation), this._lastBuildParams.body = this._body
                }
                initializeCode() { this._code = new UnityEngine.SphereCollider(this), this["__UnityEngine.SphereCollider"] = this._code, this["__UnityEngine.Collider"] = this._code, this._code.handle = this }
            },
            MeshColliderComponent: a,
            CapsuleColliderComponent: class extends r {
                constructor(t = {}) {
                    const e = { center: pc.Vec3.ZERO, radius: .5, height: 1, material: null, enabled: !0, isTrigger: !1, direction: 1 };
                    super({ position: (t = Object.assign({}, e, t)).center.clone(), material: t.material, enabled: t.enabled, isTrigger: t.isTrigger }), this._radius = t.radius, this._height = t.height, this._direction = t.direction, this._lastBuildParams.radius = 0, this._lastBuildParams.halfHeight = 0, this._lastBuildParams.colliderPosition = new pc.Vec3, this._lastBuildParams.colliderRotation = new pc.Quat, this._lastBuildParams.body = null
                }
                get radius() { return this._radius }
                set radius(t) { this._radius = t, this._updateShapeSizeAndPosition() }
                get height() { return this._height }
                set height(t) { this._height = t, this._updateShapeSizeAndPosition() }
                get direction() { return this._direction }
                set direction(t) { this._direction = t, this._updateShapeSizeAndPosition() }
                _updateShapeSizeAndPosition() {
                    this._calculateRelativePositionAndRotation(this._position), this.updateCapsuleQuaternion(this._direction, e), this._colliderRotation.mul2(e, this._colliderRotation), this._accumulatedScale.copy(this.entity.getLossyScale()), this._accumulatedScale.abs();
                    let t = 1,
                        i = 1;
                    switch (this._direction) {
                        case 0:
                            t = Math.max(this._accumulatedScale.y, this._accumulatedScale.z), i = this._accumulatedScale.x;
                            break;
                        case 1:
                            t = Math.max(this._accumulatedScale.x, this._accumulatedScale.z), i = this._accumulatedScale.y;
                            break;
                        case 2:
                            t = Math.max(this._accumulatedScale.x, this._accumulatedScale.y), i = this._accumulatedScale.z
                    }
                    const n = this._radius * t,
                        s = Math.max(.5 * this._height * i - n, 10 * Goblin.EPSILON),
                        r = Math.abs(this._lastBuildParams.radius - n) > Goblin.EPSILON || Math.abs(this._lastBuildParams.halfHeight - s) > Goblin.EPSILON,
                        o = !this._lastBuildParams.colliderPosition.equals(this._colliderPosition, Goblin.EPSILON) || !this._lastBuildParams.colliderRotation.equals(this._colliderRotation),
                        a = this._lastBuildParams.body !== this._body;
                    if (!this._shape || r) this._shape = new Goblin.CapsuleShape(this.id, n, s, this._material, this._isTrigger), this._shape._component = this, this._body.shape.addChildShape(this._shape, this.getColliderPositionGoblin(), this.getColliderRotationGoblin()), this._body.onShapeUpdated();
                    else if (a) this._body.shape.addChildShape(this._shape, this.getColliderPositionGoblin(), this.getColliderRotationGoblin()), this._body.onShapeUpdated();
                    else {
                        if (!o) return;
                        this._body.shape.updateShapeTransform(this.id, this.getColliderPositionGoblin(), this.getColliderRotationGoblin()), this._body.onShapeUpdated()
                    }
                    this._lastBuildParams.radius = n, this._lastBuildParams.halfHeight = s, this._lastBuildParams.colliderPosition.copy(this._colliderPosition), this._lastBuildParams.colliderRotation.copy(this._colliderRotation), this._lastBuildParams.body = this._body
                }
                updateCapsuleQuaternion(t, e) {
                    switch (t) {
                        case 0:
                            return e.setFromAxisAngle(pc.Vec3.FORWARD, 90);
                        case 1:
                            return e.set(0, 0, 0, 1);
                        case 2:
                            return e.setFromAxisAngle(pc.Vec3.RIGHT, 90);
                        default:
                            return NaN
                    }
                }
                initializeCode() { this._code = new UnityEngine.CapsuleCollider(this), this["__UnityEngine.CapsuleCollider"] = this._code, this["__UnityEngine.Collider"] = this._code, this._code.handle = this }
            },
            WheelColliderComponent: c,
            CharacterControllerComponent: h
        }
    }()), Object.assign(pc, function() {
        class t extends pc.UnityComponentSystem { constructor(t) { super(t), this.id = "joint", this.performanceSamplerSection = pc.Counters.PHYSICS, this._world = t.systems.physics._world } }
        return { JointSystem: t }
    }()), Object.assign(pc, function() {
        class t extends pc.UnityComponent {
            constructor(t) { super(), (t = t || {}).type = t.type || "UnityEngine.FixedJoint", this.unityClass = Bridge._getTypeByName(t.type), this.type = t.type, this.constraint = new Goblin.Constraint, this.constraint.active = !1, this.constraint.update = Bridge.fn.bind(this, this._updateConstraint), this._adapter = pc.Application.getApplication().systems.physics.adapter }
            get sortingOrderInQueue() { return this._sortingOrderInQueue }
            onEnable() { return !!pc.UnityComponent.prototype.onEnable.call(this) && (this.code && this.code.OnEnable(), this._adapter.enableConstraint(this), !0) }
            onDisable() { return !!pc.UnityComponent.prototype.onDisable.call(this) && (this.code && this.code.OnDisable(), this._adapter.disableConstraint(this), !0) }
            _updateConstraint(t) { this.code && this.code.OnUpdate(t) }
            onAwake() { this.code && this.code.OnAwake() }
        }
        return { JointComponent: t }
    }()), Object.assign(pc, function() {
        const t = new pc.Vec3,
            e = new pc.Vec3,
            i = function(t) { pc.BasePhysicsAdapter.call(this, t), this._effectors2d = new Map };
        return (i.prototype = Object.create(pc.BasePhysicsAdapter.prototype)).constructor = i, Object.assign(i.prototype, {
            setup: function() { this._world = this.options.world, this._newContacts = {}, this._contacts = {}, this._oldContacts = {}, this._disabledContacts = {}, this._world.on("begin-contact", Bridge.fn.bind(this, this._onBeginContact)), this._world.on("end-contact", Bridge.fn.bind(this, this._onEndContact)), this._world.on("pre-solve", Bridge.fn.bind(this, this._onPresolve)) },
            addRigidbody: function(t) { t.setActive(!0), this.preSimulationSynchronization(t._component || t, pc.BasePhysicsAdapter.PreSyncStages.TransformToPhysics) },
            removeRigidbody: function(t) {
                for (let e = t.getFixtureList(); e; e = e.getNext()) e._component && this._exitContacts(e._component);
                t.setActive(!1)
            },
            _exitContacts: function(t) {
                const e = t._getContacts();
                if (e)
                    for (const t in e) {
                        if (!e.hasOwnProperty(t)) continue;
                        const i = e[t];
                        i._childContactsCount = 0, this._onEndContact(i)
                    }
            },
            destroyRigidbody: function(t) { this._world.destroyBody(t) },
            addCollider: function(t, e) { e.addFixture(t), e.enable(), this.preSimulationSynchronizationForCollider(e) },
            removeCollider: function(t, e) { this._exitContacts(e), e.disable(), this._clearDisabledContacts(e) },
            _clearDisabledContacts: function(t) {
                const e = t._disabledContacts;
                if (e) {
                    for (let t = 0, i = e.length; t < i; ++t) delete this._disabledContacts[e[t]];
                    e.length = 0
                }
            },
            addConstraint: function(t) { t.createJoint(), t.enable() },
            removeConstraint: function(t) { t.disable() },
            onSimulationStep: function(t) { this._world.step(t) },
            getAttachedColliders: function(t) { return t._unityComponents.collider2D },
            getAttachedRigidbody: function(t) { const e = t._unityComponents.rigidbody2D[0]; return e && e.enabled && e.getSimulated() && !e.destroyed ? e._body : null },
            attachFauxRigidbody: function(t) { const e = this.createWorldBody(); return e._body = e, e._entity = t, this.addRigidbody(e), e },
            getRelTransformAndAccumScale: function(i, n, s, r) {
                const o = i._component ? i._component._entity : n._entity,
                    a = n._entity.getWorldTransform(),
                    c = o.getWorldTransform();
                o === n._entity ? s.setTranslation(pc.Vec3.ZERO) : (a.getTranslation(e), c.getTranslation(t), e.sub(t), s.setTranslation(e)), a.getScale(r).abs()
            },
            synchronizeBodyWithEntity: function(t) {
                const e = t._entity,
                    i = t._body;
                i.setLayer(e.cullingLayer), i.setLayerMask(e.layerMask);
                const n = e.getPosition(),
                    s = e.getEulerAngles();
                pc.Rigidbody2DComponent.setBodyTransform(i, n, s.z)
            },
            synchronizeEntityWithBody: function(t) { pc.Rigidbody2DComponent.setEntityTransform(t._body, t._entity) },
            updateConstraint: function(t) { t.update() },
            preSimulationSynchronization: function(t, e) {
                if (e !== pc.BasePhysicsAdapter.PreSyncStages.TransformToPhysics) return;
                const i = t._entity;
                if (t._worldTransformVersion === i.aabbVersion) return;
                this.synchronizeBodyWithEntity(t), t._worldTransformVersion = i.aabbVersion;
                t._body._isEntityTransformed = !0
            },
            postSimulationSynchronization: function(t) {
                t._body._isEntityTransformed = !1;
                const e = t._entity,
                    i = t._worldTransformVersion !== e.aabbVersion;
                if (t.getIsKinematic()) { if (i) return void this.synchronizeBodyWithEntity(t) } else if (t.getIsStatic() && !i) return;
                this.synchronizeEntityWithBody(t)
            },
            onAfterSimulation: function(t) { pc.BasePhysicsAdapter.prototype.onAfterSimulation.call(this, t) },
            _onBeginContact: function(t) {
                const e = this._getContactUid(t),
                    i = this._contacts[e] || this._newContacts[e];
                i ? i._childContactsCount++ : (t._childContactsCount = 1, this._newContacts[e] = t)
            },
            _onEndContact: function(t) {
                const e = this._getContactUid(t),
                    i = this._contacts[e];
                i && --i._childContactsCount <= 0 && (this._oldContacts[e] = i)
            },
            _onPresolve: function(t) {
                const e = t.getFixtureA()._component,
                    i = t.getFixtureB()._component;
                if (e._usedByEffector) {
                    const i = this._effectors2d.get(e._entity._guid);
                    i && i.onBeforeCollision2D(t)
                } else if (i._usedByEffector) {
                    const e = this._effectors2d.get(i._entity._guid);
                    e && e.onBeforeCollision2D(t)
                }
            },
            _getContactUid: function(t) { return this._getCollidersUid(t.getFixtureA()._component, t.getFixtureB()._component) },
            _getCollidersUid: function(t, e) {
                const i = t._id,
                    n = e._id;
                return i > n ? i + ":" + n : n + ":" + i
            },
            handleContacts: function() { this._triggerNewContacts(), this._triggerPersistentContacts(), this._removeNewContacts(), this._triggerOldContacts() },
            _triggerNewContacts: function() { for (const t in this._newContacts) this._contacts[t] || this._triggerContactCallback("Enter", this._newContacts[t], t, !0) },
            _triggerPersistentContacts: function() { for (const t in this._contacts) this._triggerContactCallback("Stay", this._contacts[t], t) },
            _removeNewContacts: function() { for (const t in this._newContacts) this._contacts[t] = this._newContacts[t], delete this._newContacts[t] },
            _triggerOldContacts: function() {
                for (const t in this._oldContacts) {
                    const e = this._oldContacts[t];
                    e.getFixtureA()._component.removeContact(t), e.getFixtureB()._component.removeContact(t), this._triggerContactCallback("Exit", e, t), delete this._oldContacts[t], delete this._contacts[t]
                }
            },
            _triggerContactCallback: function(t, e, i, n) {
                if (this._disabledContacts[i]) return;
                const s = e.getFixtureA(),
                    r = s.getBody();
                if (!r) return;
                const o = e.getFixtureB(),
                    a = o.getBody();
                if (!a) return;
                const c = s._component,
                    h = o._component;
                if (c._isTrigger || h._isTrigger) {
                    const e = "OnTrigger" + t + "2D";
                    this.dispatchContact(c._entity, e, h.code);
                    let i = r._component;
                    i && c._entity !== i._entity && this.dispatchContact(i._entity, e, h.code), this.dispatchContact(h._entity, e, c.code), i = a._component, i && h._entity !== i._entity && this.dispatchContact(i._entity, e, c.code)
                } else {
                    n && (c.addContact(e, i), h.addContact(e, i));
                    const s = "OnCollision" + t + "2D";
                    this.dispatchContact(c._entity, s, UnityEngine.Object.FromHandle(UnityEngine.Collision2D, e).ConfigureFor(0));
                    let o = r._component;
                    o && c._entity !== o._entity && this.dispatchContact(o._entity, s, UnityEngine.Object.FromHandle(UnityEngine.Collision2D, e).ConfigureFor(0)), this.dispatchContact(h._entity, s, UnityEngine.Object.FromHandle(UnityEngine.Collision2D, e).ConfigureFor(1)), o = a._component, o && h._entity !== o._entity && this.dispatchContact(o._entity, s, UnityEngine.Object.FromHandle(UnityEngine.Collision2D, e).ConfigureFor(1))
                }
            },
            ignoreCollision: function(t, e, i) {
                if (!t.entity._enabledInHierarchy || !e.entity._enabledInHierarchy) return;
                const n = this._getCollidersUid(t, e);
                this._disabledContacts[n] = i, i && (t._disabledContacts = t._disabledContacts || [], e._disabledContacts = e._disabledContacts || [], t._disabledContacts.push(n), e._disabledContacts.push(n))
            },
            getWorldBody: function() { return this._worldBody || (this._worldBody = this.createWorldBody()), this._worldBody },
            createWorldBody: function() { const t = this._world.createBody({ type: planck.Body.STATIC, userData: { isWorldBody: !0 } }); return t.equals = function(e) { return e === t || e && (e = e.getUserData()) && e.isWorldBody }, t },
            enableEffector: function(t) { this._effectors2d.set(t._entity._guid, t) },
            disableEffector: function(t) { this._effectors2d.delete(t._entity._guid) }
        }), Object.defineProperty(i.prototype, "world", { get: function() { return this._world } }), { Physics2DAdapter: i }
    }()), Object.assign(pc, (() => {
        let t, e, i, n;
        const s = new planck.Vec2,
            r = new planck.Vec2;
        let o, a, c, h, l, u;
        class d extends pc.UnityComponentSystem {
            constructor(t) { super(t), this.id = "physics2D", this.performanceSamplerSection = pc.Counters.PHYSICS2D, this.initializePhysicsEngine() }
            initializePhysicsEngine() { this._defaultMaterial = new UnityEngine.PhysicsMaterial2D, this._defaultMaterial.friction = .4, this._defaultMaterial.bounciness = 0, this._gravity = new pc.Vec2(0, -9.81), d._world = this._world = planck.World({ gravity: new planck.Vec2(this._gravity.x, this._gravity.y) }), d._adapter = this._adapter = new pc.Physics2DAdapter({ world: this._world }) }
            onFixedUpdate(t) { this._adapter.onFixedUpdate(t) }
            setIgnoreCollisionBetweenLayers(t, e, i) { this._adapter.setIgnoreCollisionBetweenLayers(t, e, i) }
            syncHierarchy(t) { this._adapter.syncHierarchy(t) }
            syncTransforms(t) { this._autoSyncTransforms && this._adapter.syncTransforms(t) }
            get adapter() { return this._adapter }
            get gravity() { return this._gravity }
            set gravity(t) {
                this._gravity = t;
                const e = this._world.getGravity();
                e.x = t.x, e.y = t.y, this._world.setGravity(e)
            }
            get defaultMaterial() { return this._defaultMaterial }
            set defaultMaterial(t) { t && (this._defaultMaterial = t) }
            get autoSyncTransforms() { return this._autoSyncTransforms }
            set autoSyncTransforms(t) { this._autoSyncTransforms = t }
            get velocityIterations() { return this._world.getVelocityIterations() }
            set velocityIterations(t) { this._world.setVelocityIterations(t > 0 ? t : 1) }
            get positionIterations() { return this._world.getPositionIterations() }
            set positionIterations(t) { this._world.setPositionIterations(t > 0 ? t : 1) }
        }

        function p(t, s, r, o) { return o >= e || _(t) ? e : (e = o, h.collider = t._component.code, h.fraction = (h.distance = o * i) / n, h.m_Normal.set(r.x, r.y), h.m_Point.set(s.x, s.y), h.m_Centroid.set(s.x, s.y), o) }

        function _(e) { if (e._isFaux) return !0; const i = e._component._entity; if (!(i.layerMask & t)) return !0; const n = i.getPosition().z; return n < l || u < n }

        function f(t) { return t === Number.POSITIVE_INFINITY ? 3402823e32 : t === Number.NEGATIVE_INFINITY ? -3402823e32 : t }

        function m(t, e, s, r) { if (_(t)) return 1; let o = c.length; for (c.push(new UnityEngine.RaycastHit2D), g(o, t, e, s, e, (r *= i) / n, r); o > 0 && !(c[o].fraction >= c[o - 1].fraction); --o) E(o, o - 1); return 1 }

        function y(t, e, s, r) {
            if (_(t)) return 1;
            const a = r * i;
            let h;
            if (r = a / n, o < c.length) h = o++;
            else if (r >= c[h = c.length - 1].fraction) return 1;
            for (g(h, t, e, s, e, r, a); h > 0 && !(r >= c[h - 1].fraction); --h) E(h, h - 1);
            return 1
        }

        function g(t, e, i, n, s, r, o) {
            const a = c[t];
            a.collider = e._component.code, a.fraction = r, a.distance = o, a.m_Normal.set(n.x, n.y), a.m_Point.set(i.x, i.y), a.m_Centroid.set(s.x, s.y)
        }

        function E(t, e) {
            const i = c[t];
            c[t] = c[e], c[e] = i
        }

        function A(t) { if (_(t)) return 1; const e = t._component; return (null == h || e._entity.getPosition().z < h.handle._entity.getPosition().z) && (h = e.code), 1 }

        function b(t) {
            if (_(t)) return 1;
            let e = c.length;
            const i = t._component,
                n = i._entity.getPosition().z;
            for (c.push(i.code); e > 0 && !(n >= c[e - 1].handle._entity.getPosition().z); --e) E(e, e - 1);
            return 1
        }

        function C(t) {
            if (_(t)) return 1;
            let e;
            const i = t._component,
                n = i._entity.getPosition().z;
            if (o < c.length) e = o++;
            else if (n >= c[e = c.length - 1].handle._entity.getPosition().z) return 1;
            for (c[e] = i.code; e > 0 && !(n >= c[e - 1].handle._entity.getPosition().z); --e) E(e, e - 1);
            return 1
        }

        function T(t) { const e = t.fixture; if (_(e)) return 1; const i = e._component._id; let n = a[i]; if (n >= 0) { if (t.fraction >= c[n].fraction) return 1 } else n = c.length, c.push(new UnityEngine.RaycastHit2D); for (g(n, e, t.point, t.normal, t.centroid, t.fraction, t.distance); n > 0 && !(c[n].fraction >= c[n - 1].fraction); --n) E(n, n - 1), a[c[n].collider.handle._id] = n; return a[i] = n, 1 }

        function S(t, e) {
            const i = .5 * t.x;
            let n = .5 * t.y;
            const s = new planck.Vec2,
                r = new planck.Vec2;
            e === UnityEngine.CapsuleDirection2D.Vertical ? (s.set(0, -n), r.set(0, n)) : (s.set(-n, 0), r.set(n, 0)), n <= 0 && (n = i);
            const o = Math.max(planck.Math.EPSILON, 1 - i / n);
            return s.mul(o), r.mul(o), { vertex1: s, vertex2: r, radius: i }
        }

        function M(t, i) {
            if (i > e) return e;
            const n = t.fixture;
            if (_(n)) return e;
            e = i, h.collider = n._component.code, h.fraction = t.fraction, h.distance = t.distance;
            const s = t.normal;
            h.m_Normal.set(s.x, s.y);
            const r = t.point;
            h.m_Point.set(r.x, r.y);
            const o = t.centroid;
            return h.m_Centroid.set(o.x, o.y), e
        }

        function x(t) {
            const e = t.fixture;
            if (_(e)) return 1;
            const i = e._component._id;
            let n = a[i];
            if (n >= 0) { if (t.fraction >= c[n].fraction) return 1 } else if (o < c.length) n = o++;
            else {
                if (n = c.length - 1, t.fraction >= c[n].fraction) return 1;
                a[c[n].collider.handle._id] = -1
            }
            for (g(n, e, t.point, t.normal, t.centroid, t.fraction, t.distance); n > 0 && !(t.fraction >= c[n - 1].fraction); --n) E(n, n - 1), a[c[n].collider.handle._id] = n;
            return a[i] = n, 1
        }
        return d.raycast = (o, a, c, _, m, y) => { c = f(c), s.set(o.x, o.y), a = r.set(a.x, a.y), n = a.normalize(), 0 === n && (n = 1), r.mul(c), r.add(s), i = c, t = _, l = m, u = y, e = 1 / 0; const g = h = new UnityEngine.RaycastHit2D; return d._world.rayCast(s, r, p), h = null, g }, d.linecast = (o, a, c, _, f) => { s.set(o.x, o.y), r.set(a.x, a.y), i = planck.Vec2.distance(s, r), n = i, 0 === n && (n = 1), t = c, l = _, u = f, e = 1; const m = h = new UnityEngine.RaycastHit2D; return d._world.rayCast(s, r, p), h = null, m }, d.raycastAll = (e, o, a, h, p, _) => { a = f(a), s.set(e.x, e.y), o = r.set(o.x, o.y), n = o.normalize(), 0 === n && (n = 1), r.mul(a), r.add(s), i = a, t = h, l = p, u = _; const y = c = []; return d._world.rayCast(s, r, m), c = null, y }, d.raycastNonAlloc = (e, a, h, p, _, m, g) => null == h || 0 === h.length ? 0 : (p = f(p), s.set(e.x, e.y), r.set(a.x, a.y), n = r.normalize(), 0 === n && (n = 1), r.mul(p), r.add(s), i = p, t = _, l = m, u = g, o = 0, c = h, d._world.rayCast(s, r, y), c = null, o), d.overlapCircle = (e, i, n, r, o) => { s.set(e.x, e.y), t = n, l = r, u = o, h = null, d._world.queryCircle(s, i, A); const a = h; return h = null, a }, d.overlapCircleAll = (e, i, n, r, o) => { s.set(e.x, e.y), t = n, l = r, u = o; const a = c = []; return d._world.queryCircle(s, i, b), c = null, a }, d.overlapCircleNonAlloc = (e, i, n, r, a, h) => null == n || 0 === n.length ? 0 : (s.set(e.x, e.y), t = r, l = a, u = h, o = 0, c = n, d._world.queryCircle(s, i, C), c = null, o), d.overlapPoint = (e, i, n, o) => { r.set(s.set(e.x, e.y)), t = i, l = n, u = o, h = null, d._world.rayCast(s, r, A); const a = h; return h = null, a }, d.overlapPointAll = (e, i, n, o) => { r.set(s.set(e.x, e.y)), t = i, l = n, u = o; const a = c = []; return d._world.rayCast(s, r, b), c = null, a }, d.overlapPointNonAlloc = (e, i, n, a, h) => null == i || 0 === i.length ? 0 : (r.set(s.set(e.x, e.y)), t = n, l = a, u = h, o = 0, c = i, d._world.rayCast(s, r, C), c = null, o), d.ignoreCollision = (t, e, i) => { d._adapter.ignoreCollision(t, e, i) }, d.circleCastAll = (e, i, n, o, h, p, _) => { o = f(o), s.set(e.x, e.y), n = r.set(n.x, n.y), t = h, l = p, u = _; const m = c = []; return a = {}, d._world.circleCast(s, i, n, o, T), c = a = null, m }, d.boxCastAll = (e, i, n, o, h, p, _, m) => { h = f(h), s.set(e.x, e.y), o = r.set(o.x, o.y), n *= pc.math.DEG_TO_RAD, t = p, l = _, u = m; const y = c = []; return a = {}, d._world.boxCast(s, .5 * i.x, .5 * i.y, n, o, h, T), c = a = null, y }, d.capsuleCastAll = (e, i, n, o, h, p, _, m, y) => {
            p = f(p), s.set(e.x, e.y), h = r.set(h.x, h.y), o *= pc.math.DEG_TO_RAD, t = _, l = m, u = y;
            const g = S(i, n),
                E = c = [];
            return a = {}, d._world.capsuleCast(s, g.vertex1, g.vertex2, g.radius, o, h, p, T), c = a = null, E
        }, d.circleCast = (i, n, o, a, c, p, _) => { a = f(a), s.set(i.x, i.y), o = r.set(o.x, o.y), t = c, l = p, u = _, e = 1; const m = h = new UnityEngine.RaycastHit2D; return d._world.circleCast(s, n, o, a, M), h = null, m }, d.boxCast = (i, n, o, a, c, p, _, m) => { c = f(c), s.set(i.x, i.y), a = r.set(a.x, a.y), o *= pc.math.DEG_TO_RAD, t = p, l = _, u = m, e = 1; const y = h = new UnityEngine.RaycastHit2D; return d._world.boxCast(s, .5 * n.x, .5 * n.y, o, a, c, M), y }, d.capsuleCast = (i, n, o, a, c, p, _, m, y) => {
            p = f(p), s.set(i.x, i.y), c = r.set(c.x, c.y), a *= pc.math.DEG_TO_RAD, t = _, l = m, u = y;
            const g = S(n, o);
            e = 1;
            const E = h = new UnityEngine.RaycastHit2D;
            return d._world.capsuleCast(s, g.vertex1, g.vertex2, g.radius, a, c, p, M), E
        }, d.circleCastNonAlloc = (e, i, n, h, p, _, m, y) => null == h || 0 === h.length ? 0 : (p = f(p), s.set(e.x, e.y), n = r.set(n.x, n.y), t = _, l = m, u = y, o = 0, c = h, a = {}, d._world.circleCast(s, i, n, p, x), c = a = null, o), d.boxCastNonAlloc = (e, i, n, h, p, _, m, y, g) => null == p || 0 === p.length ? 0 : (_ = f(_), s.set(e.x, e.y), h = r.set(h.x, h.y), n *= pc.math.DEG_TO_RAD, t = m, l = y, u = g, o = 0, c = p, a = {}, d._world.boxCast(s, .5 * i.x, .5 * i.y, n, h, _, x), c = a = null, o), d.capsuleCastNonAlloc = (e, i, n, h, p, _, m, y, g, E) => {
            if (null == _ || 0 === _.length) return 0;
            m = f(m), s.set(e.x, e.y), p = r.set(p.x, p.y), h *= pc.math.DEG_TO_RAD, t = y, l = g, u = E;
            const A = S(i, n);
            return o = 0, c = _, a = {}, d._world.capsuleCast(s, A.vertex1, A.vertex2, A.radius, h, p, m, x), c = a = null, o
        }, d.getRayIntersectionAll = (t, e, i, n) => {
            if (0 === e.z) return [];
            i = f(i);
            const s = d.raycastAll(t, e, i, n, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY);
            for (let i = 0; i < s.length; i++) {
                const n = s[i],
                    r = n.transform.position;
                if (Math.sign(r.z - t.z) !== Math.sign(e.z)) { s.splice(i, 1), i--; continue }
                const o = Math.abs((t.z - r.z) / e.z),
                    a = new pc.Vec2(t.x + e.x * o, t.y + e.y * o);
                n.collider.OverlapPoint(a) ? (n.point = a, n.distance = pc.Vec3.distance(t, a), n.fraction = n.distance, s[i] = n) : (s.splice(i, 1), i--)
            }
            return e.z > 0 ? s.sort(((t, e) => t.transform.position.z - e.transform.position.z)) : s.sort(((t, e) => e.transform.position.z - t.transform.position.z))
        }, d.getRayIntersectionNonAlloc = (t, e, i, n, s) => {
            if (null == i || 0 === i.length || 0 === e.z) return 0;
            n = f(n);
            const r = d.raycastAll(t, e, n, s, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY);
            let o = 0;
            for (let n = 0; n < r.length && o < i.length; n++) {
                const s = r[n],
                    a = s.transform.position;
                if (Math.sign(a.z - t.z) !== Math.sign(e.z)) continue;
                const c = Math.abs((t.z - a.z) / e.z),
                    h = new pc.Vec2(t.x + e.x * c, t.y + e.y * c);
                s.collider.OverlapPoint(h) && (s.point = h, s.distance = pc.Vec3.distance(t, h), s.fraction = s.distance, i[o] = s, o++)
            }
            return e.z > 0 ? i.sort(((t, e) => t.transform === e.transform ? 0 : null === t.transform ? 1 : null === e.transform ? -1 : t.transform.position.z - e.transform.position.z)) : i.sort(((t, e) => t.transform === e.transform ? 0 : null === t.transform ? 1 : null === e.transform ? -1 : e.transform.position.z - t.transform.position.z)), o
        }, d.isTouching = (t, e) => {
            const i = t.handle,
                n = e.handle.$id;
            if (!i._contacts || i.$id === n) return !1;
            for (const t in i._contacts) {
                if (!i._contacts.hasOwnProperty(t)) continue;
                const e = i._contacts[t],
                    s = e.getFixtureA(),
                    r = e.getFixtureB(),
                    o = s._component,
                    a = r._component;
                if (o.$id === n || a.$id === n) return !0
            }
            return !1
        }, { Physics2DSystem: d }
    })()), Object.assign(pc, function() {
        class t extends pc.UnityComponentSystem {
            constructor(t) { super(t), this.id = "rigidbody2D", this.performanceSamplerSection = pc.Counters.PHYSICS2D, this._physics2DSystem = pc.Application.getApplication().systems.physics2D }
            removeComponent(t, e) { e.onDestroy(), pc.UnityComponentSystem.prototype.removeComponent.call(this, t, e) }
            get adapter() { return this._physics2DSystem.adapter }
        }
        return { Rigidbody2DSystem: t }
    }()), Object.assign(pc, function() {
        const t = planck.Math.EPSILON,
            e = .001,
            i = Math.PI * e * e,
            n = planck.Body,
            s = new planck.Vec2,
            r = new planck.Vec2,
            o = new pc.Quat,
            a = new pc.Vec3;
        class c extends pc.UnityComponent {
            constructor(t) { super(), t = t || { enabled: !0, simulated: !0, type: UnityEngine.RigidbodyType2D.Dynamic, collisionDetectionMode: UnityEngine.CollisionDetectionMode2D.Discrete, mass: 1 }, this._system = pc.Application.getApplication().systems.rigidbody2D, this._enabled = t.enabled, this._simulated = t.simulated, this._collisionDetectionMode = t.collisionDetectionMode, this._constraints = t.constraints || 0, this._freezeRotation = !!(this._constraints & UnityEngine.RigidbodyConstraints2D.FreezeRotation), this._freezeX = !!(this._constraints & UnityEngine.RigidbodyConstraints2D.FreezePositionX), this._freezeY = !!(this._constraints & UnityEngine.RigidbodyConstraints2D.FreezePositionY), this._useCollidersDensity = !!t.useAutoMass, this._adapter = this._system.adapter, this._world = this._adapter.world, this._body = this._world.createBody({ type: t.type === UnityEngine.RigidbodyType2D.Dynamic ? n.DYNAMIC : t.type === UnityEngine.RigidbodyType2D.Kinematic ? n.KINEMATIC : n.STATIC, bullet: this._collisionDetectionMode === UnityEngine.CollisionDetectionMode2D.Continuous, gravityScale: Number.isFinite(t.gravityScale) ? t.gravityScale : 1, angularDamping: t.angularDrag >= 0 ? t.angularDrag : .05, linearDamping: t.drag > 0 ? t.drag : 0, fixedRotation: this._freezeRotation, defaultMass: t.mass, fixedX: this._freezeX, fixedY: this._freezeY, active: !1 }), this._body._component = this, this._body._entity = t.entity, this._body._material = t.material, this.createFauxFixture() }
            get body() { return this._body }
            get destroyed() { return this._destroyed }
            get useCollidersDensity() { return this._useCollidersDensity }
            createFauxFixture() {
                const t = this._body._density = this._body.getDefaultMass() / i;
                this._body.createFixture(new planck.Circle(e), { density: t, filterMaskBits: 0 })._isFaux = !0
            }
            onEnable() { return !!pc.UnityComponent.prototype.onEnable.call(this) && (this._simulated && this._adapter.enableRigidbody(this), !0) }
            onDisable() {
                if (!pc.UnityComponent.prototype.onDisable.call(this)) return !1;
                if (this._simulated && this._enabled && this._adapter.disableRigidbody(this), this._entity._enabled) return !0;
                let t = this._body.getJointList();
                for (; t;) {
                    const e = t.joint;
                    t = t.next, e.getBodyB() === this._body && this._world.destroyJoint(e)
                }
                return !0
            }
            onDestroy() { return !!pc.UnityComponent.prototype.onDestroy.call(this) && (this._destroyed = !0, this.onDisable(), this._world.destroyBody(this._body), !0) }
            addForce(t) { this._body.applyForceToCenter(s.set(t.x, t.y), !0) }
            addImpulse(t) { this._body.applyLinearImpulseToCenter(s.set(t.x, t.y), !0) }
            addForceAtPosition(t, e) { this._body.applyForce(s.set(t.x, t.y), r.set(e.x, e.y), !0) }
            addImpulseAtPosition(t, e) { this._body.applyLinearImpulse(s.set(t.x, t.y), r.set(e.x, e.y), !0) }
            addRelativeForce(t) { this._body.applyForceToCenter(s.set(t.x, t.y).rot(this._body.getTransform().q), !0) }
            addRelativeImpulse(t) { this._body.applyLinearImpulseToCenter(s.set(t.x, t.y).rot(this._body.getTransform().q), !0) }
            addTorque(t) { this._body.applyTorque(t, !0) }
            addTorqueImpulse(t) { this._body.applyAngularImpulse(t, !0) }
            getVelocity() { const t = this._body.getLinearVelocity(); return this._velocity = (this._velocity || new pc.Vec2).set(t.x, t.y), this._velocity }
            setVelocity(t) { this._freezeX && this._freezeY || (this._freezeX || this._freezeY ? (s.set(this._body.getLinearVelocity()), this._freezeX ? s.y = t.y : s.x = t.x, this._body.setLinearVelocity(s)) : this._body.setLinearVelocity(s.set(t.x, t.y))) }
            getAngularVelocity() { return this._body.getAngularVelocity() * pc.math.RAD_TO_DEG }
            setAngularVelocity(t) { this._freezeRotation || this._body.setAngularVelocity(t * pc.math.DEG_TO_RAD) }
            getMass() { return this._body.getMass() }
            setMass(t) {
                if (this._useCollidersDensity) return void UnityEngine.Debug.LogWarningFormat("Mass cannot be set on the rigid-body when it is using auto-mass.");
                const e = this._body;
                e.getMass() !== t && (e.setDefaultMass(t), c.setDensity(e, e.getDefaultMass() / e.getMass() * e._density), e.setAwake(!0))
            }
            getUseAutoMass() { return this._useCollidersDensity }
            setUseAutoMass(t) { this._useCollidersDensity !== t && (this._useCollidersDensity = !!t, this._resetMassData()) }
            _resetMassData() {
                const t = this._body;
                if (!this._useCollidersDensity) { const e = t.getDefaultMass(); return c.setDensity(t, 1), void this.setMass(e) }
                let e = t.getFixtureList();
                if (!e._isFaux) {
                    for (; e; e = e.getNext()) {
                        const t = e._component.getDensity();
                        e.setDensity(t)
                    }
                    t.resetMassData(), t.setAwake(!0)
                }
            }
            getInertia() { return this._body.getInertia() }
            setInertia(t) { this._body.setInertia(Math.max(t, 1e-4)) }
            getDrag() { return this._body.getLinearDamping() }
            setDrag(t) { this._body.setLinearDamping(t) }
            getAngularDrag() { return this._body.getAngularDamping() }
            setAngularDrag(t) { this._body.setAngularDamping(t) }
            getPosition() { const t = this._body.getPosition(); return new pc.Vec2(t.x, t.y) }
            setPosition(t) { this._body.setPosition(r.set(t.x, t.y)) }
            getRotation() { return this._body.getAngle() * pc.math.RAD_TO_DEG }
            setRotation(t) { this._body.setAngle(t * pc.math.DEG_TO_RAD) }
            getGravityScale() { return this._body.getGravityScale() }
            setGravityScale(t) { this._body.setGravityScale(t) }
            getCollisionDetectionMode() { return this._collisionDetectionMode }
            setCollisionDetectionMode(t) { this._collisionDetectionMode !== t && (this._collisionDetectionMode = t, this._body.setBullet(t === UnityEngine.CollisionDetectionMode2D.Continuous)) }
            getSimulated() { return this._simulated }
            setSimulated(t) { t !== this._simulated && (this._simulated = t, this._enabled && (t ? this._adapter.enableRigidbody(this) : this._adapter.disableRigidbody(this))) }
            getBodyType() {
                switch (this._body.getType()) {
                    case n.DYNAMIC:
                        return UnityEngine.RigidbodyType2D.Dynamic;
                    case n.KINEMATIC:
                        return UnityEngine.RigidbodyType2D.Kinematic;
                    case n.STATIC:
                        return UnityEngine.RigidbodyType2D.Static;
                    default:
                        return NaN
                }
            }
            setBodyType(t) {
                if (this.getBodyType() !== t) switch (t) {
                    case UnityEngine.RigidbodyType2D.Dynamic:
                        this._body.setType(n.DYNAMIC), this._resetMassData();
                        break;
                    case UnityEngine.RigidbodyType2D.Kinematic:
                        this._body.setType(n.KINEMATIC);
                        break;
                    case UnityEngine.RigidbodyType2D.Static:
                        this._body.setType(n.STATIC)
                }
            }
            getIsKinematic() { return this._body.getType() === n.KINEMATIC }
            setIsKinematic(t) { this._body.setType(t ? n.KINEMATIC : n.DYNAMIC) }
            getIsStatic() { return this._body.getType() === n.STATIC }
            getFreezeRotation() { return this._freezeRotation }
            setFreezeRotation(t) { t !== this._freezeRotation && (this._body.setFixedRotation(this._freezeRotation = !!t), this._freezeRotation ? this._constraints |= UnityEngine.RigidbodyConstraints2D.FreezeRotation : this._constraints &= ~UnityEngine.RigidbodyConstraints2D.FreezeRotation) }
            getConstraints() { return this._constraints }
            setConstraints(t) { t !== this._constraints && (this._constraints = t, this._freezeRotation !== !!(t & UnityEngine.RigidbodyConstraints2D.FreezeRotation) && this._body.setFixedRotation(this._freezeRotation = !this._freezeRotation), this._freezeX !== !!(t & UnityEngine.RigidbodyConstraints2D.FreezePositionX) && this._body.setFixedX(this._freezeX = !this._freezeX), this._freezeY !== !!(t & UnityEngine.RigidbodyConstraints2D.FreezePositionY) && this._body.setFixedY(this._freezeY = !this._freezeY)) }
            getCenterOfMass() { const t = this._body.getLocalCenter(); return new pc.Vec2(t.x, t.y) }
            setCenterOfMass(t) { r.set(t.x, t.y), this._body.setLocalCenter(r) }
            moveRotation(t) { this._freezeRotation || (t *= pc.math.DEG_TO_RAD, this._body.setAngularVelocity((t - this._body.getAngle()) / this._world.getLastTimeStep())) }
            movePosition(t) { this._body.setPosition(t) }
            wakeUp() { this._body.setAwake(!0) }
            getAttachedColliderCount() {
                let t = this.body.getFixtureList(),
                    e = 0;
                for (; t;) e++, t = t.getNext();
                return e
            }
            getAttachedColliders(t) {
                let e = this.body.getFixtureList(),
                    i = 0;
                for (; i < t.length && e;) t[i] = e, i++, e = e.getNext();
                return i
            }
        }
        return c.setBodyTransform = (e, i, n) => {
            if (r.set(i.x, i.y), n *= pc.math.DEG_TO_RAD, e.getPosition().closeTo(r)) { const i = (n - e.getAngle()) / (2 * Math.PI); if (Math.abs(Math.round(i) - i) <= t) return }
            e.setTransform(r, n), e.dirtifyTransform(!1)
        }, c.setEntityTransform = (e, i) => {
            if (!e.isDirtyTransform()) return;
            const n = e.getTransform(),
                s = i.getPosition();
            r.set(s.x, s.y), i.getRotation().getEulerAngles(a);
            const c = n.q.getAngle() * pc.math.RAD_TO_DEG;
            Math.abs(c - a.z) > t && (o.setFromEulerAngles(a.x, a.y, c), i.setRotation(o)), r.closeTo(n.p) || i.setPosition(n.p.x, n.p.y, s.z), e.dirtifyTransform(!1)
        }, c.setDensity = (t, e) => {
            t._density = e;
            for (let i = t.getFixtureList(); i; i = i.getNext()) i.setDensity(e);
            t.resetMassData()
        }, { Rigidbody2DComponent: c }
    }()), Object.assign(pc, function() {
        class t extends pc.UnityComponentSystem {
            constructor(t) { super(t), this.id = "collider2D", this.performanceSamplerSection = pc.Counters.PHYSICS2D, this._physics2DSystem = pc.Application.getApplication().systems.physics2D }
            removeComponent(t, e) { e.onDestroy(), pc.UnityComponentSystem.prototype.removeComponent.call(this, t, e) }
            get defaultMaterial() { return this._physics2DSystem.defaultMaterial }
            set defaultMaterial(t) { this._physics2DSystem.defaultMaterial = t }
        }
        return { Collider2DSystem: t }
    }()), Object.assign(pc, function() {
        const t = .005,
            e = planck.Math.EPSILON,
            i = new planck.Vec2,
            n = new pc.Vec3;
        let s, r;
        const o = new pc.Vec3,
            a = new pc.Vec3;
        let c;
        class h extends pc.UnityComponent {
            constructor(t) { super(), t = t || { enabled: !0 }, this._enabled = void 0 === t.enabled || t.enabled, this._fixtureDef = t.fixture || { active: !1 }, this._shape = t.shape, this._isTrigger = t.isTrigger, this._usedByEffector = t.usedByEffector, this._density = t.density >= 0 ? t.density : 1, this._offset = this._offset || t.offset, this._type = t.type || "collider2D", this._relativePosition = new pc.Vec3(0, 0, 0), this._accumulatedScale = new pc.Vec3(1, 1, 1), this._adapter = pc.Application.getApplication().systems.physics2D.adapter, this._material = t.material, this._material && (this._fixtureDef.friction = this._material.friction, this._fixtureDef.restitution = this._material.bounciness), this._fixtureDef.isSensor = this._isTrigger }
            get code() { return this._code || this._initializeCode(), this._code }
            get shape() { return this._shape }
            get type() { return this._type }
            _initializeCode() { this._code && (this["__UnityEngine.Collider2D"] = this._code, this._code.handle = this) }
            onEnable() { return !!pc.UnityComponent.prototype.onEnable.call(this) && (this._adapter.enableCollider(this), !0) }
            onDisable() { return !!pc.UnityComponent.prototype.onDisable.call(this) && (this._adapter.disableCollider(this), !0) }
            onDestroy() {
                if (!pc.UnityComponent.prototype.onDestroy.call(this)) return !1;
                if (this.onDisable(), this._fixture) {
                    const t = this._fixture.getBody();
                    t.destroyFixture(this._fixture), t._component && !t.getFixtureList() && t._component.createFauxFixture(), this._fixture = null
                }
                return !0
            }
            addFixture(t) {
                if (this._fixture) {
                    const e = this._fixture.getBody();
                    if (e === t) return;
                    e.destroyFixture(this._fixture), this._fixture = null
                } else {
                    const e = t.getFixtureList();
                    e && e._isFaux && t.destroyFixture(e)
                }
                const e = t._component && t._component.useCollidersDensity;
                if (this._fixtureDef.density = e ? this._density : t._density, !this._material) {
                    const e = t._material || this._system.defaultMaterial;
                    this._fixtureDef.friction = e.friction, this._fixtureDef.restitution = e.bounciness
                }
                this._fixture = t.createFixture(this._shape, this._fixtureDef), this._fixture._component = this, this._body = t
            }
            updateShape(t, e, i) { t.getTranslation(this._relativePosition), this._accumulatedScale.copy(e), i && i !== this._body || this._updateShapeSizeAndPosition() }
            _updateShapeSizeAndPosition(t) {
                const e = this._fixture;
                e && (e.createProxies(), this._resetMassData())
            }
            _resetMassData() { this._resetBodyMassData(this._fixture.getBody()) }
            _resetBodyMassData(t) {
                if (t.resetMassData(), t.fixturesAreBlank() || t.isStatic() || t.isKinematic() || t._component && t._component.useCollidersDensity) return t.setDefaultMass(t.getMass()), void t.setAwake(!0);
                const e = this._fixtureDef.density = t.getDefaultMass() / t.getMass() * t._density;
                pc.Rigidbody2DComponent.setDensity(t, e), t.setAwake(!0)
            }
            _transformVertices() {
                const t = this._entity.getWorldTransform(),
                    e = this._vertices,
                    s = this._vertices2D;
                let r = !1;
                const o = this._getAngle2D(),
                    a = Math.cos(o),
                    c = Math.sin(o),
                    h = this._relativePosition;
                let l;
                for (let o = e.length, u = 0; u < o; ++u) n.copy(e[u]), t.transformVector(n, n).add(h), l = s[u], i.set(n).rotate(a, c).closeTo(l) || (l.set(i), r = !0);
                return r
            }
            _getAngle2D() { return -(this._body._entity || this._body._component._entity).getEulerAngles().z * pc.math.DEG_TO_RAD }
            enable() { this._fixtureDef.active = !0, this._fixture && (this._fixture.setActive(!0), this._resetMassData()) }
            disable() { this._fixtureDef.active = !1, this._fixture && (this._fixture.setActive(!1), this._resetMassData()) }
            addContact(t, e) { this._contacts = this._contacts || {}, this._contacts[e] = t }
            removeContact(t) { this._contacts && delete this._contacts[t] }
            _getContacts() { return this._contacts }
            overlapPoint(t) { return !!this._fixture && this._fixture.testPoint(i.set(t.x, t.y)) }
            getContactedColliders(t) {
                if (!(t && t.length > 0 && this._contacts)) return 0;
                let e = 0;
                for (const i in this._contacts) {
                    if (!this._contacts.hasOwnProperty(i)) continue;
                    const n = this._contacts[i],
                        s = n.getFixtureA(),
                        r = n.getFixtureB();
                    if (!s.getBody() || !r.getBody()) continue;
                    const o = s._component,
                        a = r._component;
                    if (!o._isTrigger && !a._isTrigger && (s === this._fixture ? t[e++] = a.code : r === this._fixture && (t[e++] = o.code), e >= t.length)) break
                }
                return e
            }
            getIsTrigger() { return this._isTrigger }
            setIsTrigger(t) { t = !!t, this._isTrigger !== t && (this._fixtureDef.isSensor = this._isTrigger = t, this._fixture && this._fixture.setSensor(t)) }
            getIsUsedByEffector() { return this._usedByEffector }
            setIsUsedByEffector(t) { this._usedByEffector = !!t }
            getOffset() { return this._offset.clone() }
            setOffset(t) { throw new Error("Not Implemented") }
            getShapeCount() { return 1 }
            overlapCollider(t, e) { return null != e && 0 !== e.length && this._fixture ? (s = 0, r = e, this._fixture.queryOverlaps(this._reportOverlap), r = null, s) : 0 }
            _reportOverlap(t) { return !!t._isFaux || (r[s++] = t._component.code, s < r.length) }
            getDistance(t) {
                const e = new UnityEngine.ColliderDistance2D;
                if (null == t || null == t._fixture || null == this._fixture) return e;
                const i = this._adapter.world.getDistance(this._fixture, t._fixture);
                if (null == i) return e;
                let n = i.pointA,
                    s = i.pointB;
                return n = e.pointA.set(n.x, n.y), s = e.pointB.set(s.x, s.y), e.distance = i.distance, e.normal.copy(n).sub(s).normalize(), e.isValid = !0, e
            }
            getBounds() {
                const t = new UnityEngine.Bounds;
                if (!this._fixture || !this._fixtureDef.active) return t;
                const e = this._fixture.getProxyCount();
                if (e < 1) return t;
                c = c || new planck.AABB, c.set(this._fixture.getAABB(0));
                for (let t = 1; t < e; ++t) c.combine(c, this._fixture.getAABB(t));
                const i = this._entity.getPosition().z;
                return o.set(c.lowerBound.x, c.lowerBound.y, i), a.set(c.upperBound.x, c.upperBound.y, i), t.SetMinMax(o, a), t
            }
            getDensity() { return this._density }
            setDensity(t) {
                if (this._density === t) return;
                const e = this._body;
                if (e && e._component && !e._component.useCollidersDensity) return void UnityEngine.Debug.LogWarningFormat("Density cannot be set on the collider unless it is attached to a dynamic rigid-body that is using auto-mass.");
                this._fixtureDef.density = this._density = t = t >= 0 ? t : 0;
                const i = this._fixture;
                i && (i.setDensity(t), this._resetBodyMassData(i.getBody()))
            }
            getSharedMaterial() { return this._material }
            setSharedMaterial(t) {
                this._material = t, t || (this._body && (t = this._body._material), t = t || this._system.defaultMaterial);
                const e = this._fixtureDef;
                e.friction = t.friction, e.restitution = t.bounciness;
                const i = this._fixture;
                i && (i.setFriction(t.friction), i.setRestitution(t.bounciness))
            }
        }
        return {
            Collider2DComponent: h,
            BoxCollider2DComponent: class extends h {
                constructor(e) {
                    (e = e || {}).type = "boxCollider2D";
                    const n = (new pc.Vec2).copy(e.size || pc.Vec2.ZERO).setFromMax(t, t),
                        s = (new pc.Vec2).copy(e.center || pc.Vec2.ZERO),
                        r = new planck.Box(.5 * n.x, .5 * n.y, i.set(s.x, s.y));
                    r.setRadius(e.radius), e.shape = r, super(e), this._offset = s, this._size = n;
                    const o = this._vertices2D = r.m_vertices,
                        a = this._vertices = new Array(o.length);
                    for (let t = a.length, e = 0; e < t; ++e) a[e] = new pc.Vec3(o[e].x, o[e].y, 0)
                }
                _initializeCode() { this._code = new UnityEngine.BoxCollider2D(this), this["__UnityEngine.BoxCollider2D"] = this._code, h.prototype._initializeCode.call(this) }
                _updateShapeSizeAndPosition(t) {
                    (this._fixture || t) && (this._transformVertices() || t) && (this._shape._set(this._vertices2D), h.prototype._updateShapeSizeAndPosition.call(this))
                }
                getSize() { return this._size.clone() }
                setSize(e) {
                    let i = (e = e || pc.Vec2.ZERO).x,
                        n = e.y;
                    i < t && (i = t), n < t && (n = t), (e = this._size).x === i && e.y === n || (this._size.set(i, n), this._rebuild())
                }
                _rebuild() {
                    this._shape._setAsBox(.5 * this._size.x, .5 * this._size.y, i.set(this._offset.x, this._offset.y));
                    const t = this._vertices;
                    let e;
                    const n = this._vertices2D;
                    for (let i = t.length, s = 0; s < i; ++s) e = n[s], t[s].set(e.x, e.y, 0);
                    this._updateShapeSizeAndPosition()
                }
                setOffset(t) { this._offset.equals(t = t || pc.Vec2.ZERO) || (this._offset.copy(t), this._rebuild()) }
                getShapeCount() { return this._size.x <= t || this._size.y <= t ? 0 : 1 }
            },
            CircleCollider2DComponent: class extends h {
                constructor(e) {
                    (e = e || {}).type = "circleCollider2D";
                    const n = (new pc.Vec2).copy(e.center || pc.Vec2.ZERO);
                    i.set(n.x, n.y);
                    const s = e.radius = e.radius > 0 ? e.radius : t,
                        r = e.shape = new planck.Circle(i, s);
                    super(e), this._center = new pc.Vec3(i.x, i.y, 0), this._vertices = [this._center], this._vertices2D = [r.m_p], this._radius = s, this._offset = n
                }
                _initializeCode() { this._code = new UnityEngine.CircleCollider2D(this), this["__UnityEngine.CircleCollider2D"] = this._code, h.prototype._initializeCode.call(this) }
                _updateShapeSizeAndPosition(t) {
                    if (this._fixture || t) {
                        const e = this._transformVertices(),
                            i = this._scaleRadius();
                        (e || i || t) && this._rebuild()
                    }
                }
                _rebuild() { h.prototype._updateShapeSizeAndPosition.call(this), this._shape.m_vertices = null }
                _scaleRadius() {
                    const t = this._radius * Math.max(this._accumulatedScale.x, this._accumulatedScale.y),
                        i = t - this._shape.getRadius();
                    return !(-e <= i && i <= e) && (this._shape.setRadius(t), !0)
                }
                getRadius() { return this._radius }
                setRadius(t) { this._radius !== t && (this._radius = t, this._fixture && this._scaleRadius() && this._rebuild()) }
                setOffset(t) { this._offset.equals(t = t || pc.Vec2.ZERO) || (this._offset.copy(t), this._center.set(t.x, t.y, 0), this._fixture && this._transformVertices() && this._rebuild()) }
            },
            CapsuleCollider2DComponent: class extends h {
                constructor(e) {
                    (e = e || {}).type = "capsuleCollider2D", super(e), this._offset = (new pc.Vec2).copy(e.center || pc.Vec2.ZERO), this._size = (new pc.Vec2).copy(e.size || pc.Vec2.ZERO).setFromMax(t, t), this._direction = e.direction || UnityEngine.CapsuleDirection2D.Vertical, this._vertices2D = [new planck.Vec2, new planck.Vec2, new planck.Vec2], this._vertices = [new pc.Vec3, new pc.Vec3, new pc.Vec3], this._vertex1 = new planck.Vec2, this._vertex2 = new planck.Vec2, this._radius = 0, this._calculateVertices(), this._calculateShape(), this._shape = new planck.Capsule(this._vertex1, this._vertex2, this._radius)
                }
                _calculateVertices() {
                    const t = this._offset.x,
                        e = this._offset.y,
                        i = .5 * this._size.x,
                        n = .5 * this._size.y,
                        s = this._vertices2D,
                        r = this._vertices;
                    this._direction === UnityEngine.CapsuleDirection2D.Vertical ? (s[0].set(t, e - n), s[1].set(t, e + n), s[2].set(t + i, e)) : (s[0].set(t - n, e), s[1].set(t + n, e), s[2].set(t, e + i));
                    for (let t = 0, e = s.length; t < e; ++t) {
                        const e = s[t];
                        r[t].set(e.x, e.y, 0)
                    }
                }
                _calculateShape() {
                    const t = this._vertices2D[0],
                        i = this._vertices2D[1],
                        n = this._vertices2D[2],
                        s = t.x,
                        r = t.y,
                        o = i.x,
                        a = i.y,
                        c = .5 * (s + o),
                        h = .5 * (r + a),
                        l = n.x - c,
                        u = n.y - h,
                        d = Math.sqrt(l * l + u * u);
                    this._radius = d;
                    let p = s - c,
                        _ = r - h,
                        f = Math.sqrt(p * p + _ * _);
                    f <= 0 && (f = d);
                    const m = Math.max(e, 1 - d / f);
                    this._vertex1.x = c + m * p, this._vertex1.y = h + m * _, p = o - c, _ = a - h, this._vertex2.x = c + m * p, this._vertex2.y = h + m * _
                }
                _initializeCode() { this._code = new UnityEngine.CapsuleCollider2D(this), this["__UnityEngine.CapsuleCollider2D"] = this._code, h.prototype._initializeCode.call(this) }
                _updateShapeSizeAndPosition(t) {
                    (this._fixture || t) && (this._transformVertices() || t) && (this._calculateShape(), this._shape.setRadius(this._radius), this._shape.setVertex1(this._vertex1), this._shape.setVertex2(this._vertex2), h.prototype._updateShapeSizeAndPosition.call(this))
                }
                getSize() { return this._size.clone() }
                setSize(t) { this._size.equals(t) || (this._size = t, this._calculateVertices(), this._updateShapeSizeAndPosition()) }
                getDirection() { return this._direction }
            },
            EdgeCollider2DComponent: class extends h {
                constructor(t) {
                    (t = t || {}).type = "edgeCollider2D", super(t), this._init(t), this._shape = new planck.Chain(this._vertices2D, !1, t.radius)
                }
                get edgeRadius() { return this._shape.getRadius() }
                set edgeRadius(t) { this._shape.setRadius(t) }
                _initializeCode() { this._code = new UnityEngine.EdgeCollider2D(this), this["__UnityEngine.EdgeCollider2D"] = this._code, h.prototype._initializeCode.call(this) }
                _updateShapeSizeAndPosition(t) {
                    (this._fixture || t) && (!this._body || this._transformVertices() || t) && (this._shape._createChain(this._vertices2D), h.prototype._updateShapeSizeAndPosition.call(this))
                }
                _init(t) {
                    this._offset = (new pc.Vec2).copy(t.offset || pc.Vec2.ZERO);
                    const e = t.points || [],
                        i = e.length,
                        n = i / 2,
                        s = this._points = new Array(n),
                        r = this._vertices = new Array(n),
                        o = this._vertices2D = new Array(n),
                        a = this._offset.x,
                        c = this._offset.y;
                    for (let t, n, h, l, u = 0, d = 0; u < i; u += 2, ++d) t = e[u], n = e[u + 1], h = a + t, l = c + n, s[d] = new pc.Vec2(t, n), o[d] = new planck.Vec2(h, l), r[d] = new pc.Vec3(h, l, 0)
                }
                setOffset(t) {
                    if (this._offset.equals(t = t || pc.Vec2.ZERO)) return;
                    this._offset.copy(t);
                    const e = this._points,
                        i = this._vertices,
                        n = t.x,
                        s = t.y;
                    for (let t, r = 0, o = e.length; r < o; ++r) t = e[r], i[r].set(n + t.x, s + t.y, 0);
                    this._updateShapeSizeAndPosition()
                }
                getPoints() {
                    let t;
                    const e = this._points,
                        i = e.length,
                        n = new Array(i);
                    for (let s = 0; s < i; ++s) t = e[s], n[s] = new pc.Vec2(t.x, t.y);
                    return n
                }
                setPoints(t) {
                    let e, i, n, s, r, o = 0;
                    const a = (t = t || []).length,
                        c = this._offset.x,
                        h = this._offset.y,
                        l = this._vertices,
                        u = this._vertices2D,
                        d = this._points;
                    for (let e = Math.min(a, l.length); o < e; ++o) n = t[o], s = n.x, r = n.y, l[o].set(c + s, h + r, 0), d[o].set(s, r);
                    for (l.length = u.length = d.length = a; o < a; ++o) n = t[o], s = n.x, r = n.y, e = c + s, i = h + r, u[o] = new planck.Vec2(e, i), l[o] = new pc.Vec3(e, i, 0), d[o] = new pc.Vec2(s, r);
                    this._updateShapeSizeAndPosition(!0)
                }
                getPointCount() { return this._vertices.length }
            },
            PolygonCollider2DComponent: class extends h {
                constructor(t) {
                    (t = t || {}).type = "polygonCollider2D", super(t), this._init(t), this._shape = new planck.CompositePolygon(this._contours)
                }
                _initializeCode() { this._code = new UnityEngine.PolygonCollider2D(this), this["__UnityEngine.PolygonCollider2D"] = this._code, h.prototype._initializeCode.call(this) }
                _updateShapeSizeAndPosition(t) {
                    (this._fixture || t) && (!this._body || this._transformVertices() || t) && (this._shape._set(this._contours), h.prototype._updateShapeSizeAndPosition.call(this))
                }
                _init(t) {
                    this._offset = (new pc.Vec2).copy(t.offset || pc.Vec2.ZERO);
                    const e = this._offset.x,
                        i = this._offset.y,
                        n = this._points = t.points || [],
                        s = n.length,
                        r = this._vertices = new Array(s),
                        o = this._contours = new Array(s);
                    for (let t = 0; t < s; ++t) {
                        const s = n[t] || [],
                            a = s.length,
                            c = a >> 1,
                            h = r[t] = new Array(c),
                            l = o[t] = new Array(a);
                        for (let t, n, r = 0, o = 0; r < a; r += 2, ++o) t = l[r] = s[r] + e, n = l[r + 1] = s[r + 1] + i, h[o] = new pc.Vec3(t, n, 0)
                    }
                }
                _transformVertices() {
                    let t = !1;
                    const e = this._entity.getWorldTransform(),
                        i = this._getAngle2D(),
                        n = Math.cos(i),
                        s = Math.sin(i),
                        r = this._relativePosition,
                        o = this._vertices,
                        a = this._contours;
                    for (let i = o.length, c = 0; c < i; ++c) {
                        const i = a[c],
                            h = o[c];
                        t = this._setContour(i, h, e, n, s, r) || t
                    }
                    return t
                }
                _transformContour(t) {
                    const e = this._entity.getWorldTransform(),
                        i = this._getAngle2D(),
                        n = Math.cos(i),
                        s = Math.sin(i),
                        r = this._relativePosition,
                        o = this._contours[t],
                        a = this._vertices[t];
                    return this._setContour(o, a, e, n, s, r)
                }
                _setContour(t, e, s, r, o, a) { let c = !1; for (let h = t.length, l = 0, u = 0; l < h; l += 2, ++u) n.copy(e[u]), s.transformVector(n, n).add(a), i.set(n).rotate(r, o).closeToValues(t[l], t[l + 1]) || (t[l] = i.x, t[l + 1] = i.y, c = !0); return c }
                setOffset(t) {
                    if (this._offset.equals(t = t || pc.Vec2.ZERO)) return;
                    this._offset.copy(t);
                    const e = t.x,
                        i = t.y,
                        n = this._points,
                        s = this._vertices;
                    for (let t = 0, r = n.length; t < r; ++t) {
                        const r = n[t],
                            o = s[t];
                        for (let t = 0, s = 0, a = n.length; t < a; t += 2, ++s) o[s].set(e + r[t], i + r[t + 1], 0)
                    }
                    this._updateShapeSizeAndPosition()
                }
                getPoints() { return 0 === this._points.length ? [] : this.getPath(0) }
                getPath(t) {
                    if (t >= this._points.length || t < 0) throw new System.ArgumentOutOfRangeException.ctor;
                    const e = this._points[t],
                        i = e.length,
                        n = new Array(i >> 1);
                    for (let t = 0, s = 0; t < i; t += 2, ++s) n[s] = new pc.Vec2(e[t], e[t + 1]);
                    return n
                }
                setPoints(t) { null != t && 0 !== t.length && this.setPath(0, t) }
                setPath(t, e) {
                    if (null == e) throw new System.ArgumentNullException;
                    const i = this._points,
                        n = i.length;
                    if (t > 0 && t >= n || t < 0) throw new System.ArgumentOutOfRangeException.ctor;
                    const s = this._contours,
                        r = this._vertices;
                    let o, a;
                    0 === n && (i[0] = [], s[0] = [], r[0] = []);
                    let c = 0,
                        l = 0;
                    const u = e.length;
                    let d, p, _;
                    const f = this._offset.x,
                        m = this._offset.y,
                        y = i[t],
                        g = s[t],
                        E = r[t],
                        A = E.length !== u;
                    for (let t = Math.min(u, E.length); c < t; ++c, l += 2) d = e[c], p = d.x, _ = d.y, E[c].set(f + p, m + _, 0), y[l] = p, y[l + 1] = _;
                    for (E.length = u, g.length = y.length = 2 * u; c < u; ++c, l += 2) d = e[c], p = d.x, _ = d.y, o = f + p, a = m + _, E[c] = new pc.Vec3(o, a, 0), g[l] = o, g[l + 1] = a, y[l] = p, y[l + 1] = _;
                    (!this._body || this._transformContour(t) || A) && (this._shape._set(this._contours), h.prototype._updateShapeSizeAndPosition.call(this))
                }
                getPathCount() { return this._points.length }
                setPathCount(t) {
                    const e = this._points,
                        i = e.length;
                    if (i === t) return;
                    t < 0 && (t = 0);
                    const n = this._contours,
                        s = this._vertices;
                    if (e.length = t, n.length = t, s.length = t, t < i) return this._shape._set(this._contours), void h.prototype._updateShapeSizeAndPosition.call(this);
                    for (let r = i; r < t; ++r) e[r] = [], n[r] = [], s[r] = []
                }
                getTotalPointCount() { let t = 0; const e = this._vertices; for (let i = 0, n = e.length; i < n; ++i) t += e[i].length; return t }
            }
        }
    }()), pc.extend(planck.Contact.prototype, {
        getContactPoint: function(t, e) {
            const i = new UnityEngine.ContactPoint2D;
            i.collider = e.collider, i.otherCollider = e.otherCollider, i.rigidbody = e.rigidbody, i.otherRigidbody = e.otherRigidbody;
            const n = this.v_points[t];
            return i.point.set(n.worldPoint.x, n.worldPoint.y), i.normal.set(this.v_normal.x, this.v_normal.y), i.normalImpulse = n.normalImpulse, i.tangentImpulse = n.tangentImpulse, i.separation = n.separation, i
        }
    }), Object.assign(pc, function() {
        class t extends pc.UnityComponent {
            constructor(t) { super(), t && (this._enabled = !!t.enabled, this._useColliderMask = !!t.useColliderMask, this._colliderMask = t.colliderMask), this._adapter = pc.Application.getApplication().systems.physics2D.adapter }
            get useColliderMask() { return this._useColliderMask }
            set useColliderMask(t) { this._useColliderMask = t }
            _initializeCode() { this._code && (this["__UnityEngine.Effector2D"] = this._code, this._code.handle = this) }
            onEnable() { return !!pc.UnityComponent.prototype.onEnable.call(this) && (this._adapter.enableEffector(this), !0) }
            onBeforeCollision2D(t) {
                const e = t.getFixtureA(),
                    i = t.getFixtureB(),
                    n = e._component._body.getLinearVelocity(),
                    s = i._component._body.getLinearVelocity();
                n.y + s.y > 0 && t.setEnabled(!1)
            }
            onDisable() { return !!pc.UnityComponent.prototype.onDisable.call(this) && (this._adapter.disableEffector(this), !0) }
            onDestroy() { return !!pc.UnityComponent.prototype.onDestroy.call(this) && (this.onDisable(), !0) }
        }
        return { Effector2DComponent: t, PlatformEffector2DComponent: class extends t { _initializeCode() { this._code = new UnityEngine.PlatformEffector2D(this), this["__UnityEngine.PlatformEffector2D"] = this._code, t.prototype._initializeCode.call(this) } } }
    }()), Object.assign(pc, function() {
        class t extends pc.UnityComponentSystem {
            constructor(t) { super(t), this.id = "effector2D", this.performanceSamplerSection = pc.Counters.PHYSICS2D }
            removeComponent(t, e) { e.onDestroy(), pc.UnityComponentSystem.prototype.removeComponent.call(this, t, e) }
        }
        return { Effector2DSystem: t }
    }()), Object.assign(pc, function() {
        class t extends pc.UnityComponentSystem {
            constructor(t) { super(t), this.id = "joint2D", this.performanceSamplerSection = pc.Counters.PHYSICS2D }
            removeComponent(t, e) { e.onDestroy(), pc.UnityComponentSystem.prototype.removeComponent.call(this, t, e) }
        }
        return { Joint2DSystem: t }
    }()), Object.assign(pc, function() {
        const t = ["onFixedUpdate"],
            e = pc.math.DEG_TO_RAD,
            i = pc.math.RAD_TO_DEG,
            n = new planck.Vec2;
        class s extends pc.UnityComponent {
            constructor(t) {
                if (super(), this.constraint = this._jointDef = { active: !1 }, t) {
                    this._enabled = !!t.enabled, this._enableCollision = !!t.enableCollision;
                    const e = t.breakForce,
                        i = t.breakTorque;
                    this._breakForce = Number.isFinite(e) && e >= 0 ? e : 1 / 0, this._breakTorque = Number.isFinite(i) && i >= 0 ? i : 1 / 0
                } else this._enabled = !0, this._enableCollision = !1, this._breakForce = 1 / 0, this._breakTorque = 1 / 0;
                this._breakForceSq = this._breakForce * this._breakForce, this._adapter = pc.Application.getApplication().systems.physics2D.adapter, this._world = this._adapter.world, this._dt = 0
            }
            get sortingOrderInQueue() { return this._sortingOrderInQueue }
            get code() { return this._code || this._initializeCode(), this._code }
            get joint() { return this._joint }
            get type() { return this._type }
            _initializeCode() { this._code && (this["__UnityEngine.Joint2D"] = this._code, this._code.handle = this) }
            onEnable() { return !!pc.UnityComponent.prototype.onEnable.call(this) && (this._adapter.enableConstraint(this), !0) }
            onDisable() { return !!pc.UnityComponent.prototype.onDisable.call(this) && (this._adapter.disableConstraint(this), !0) }
            onDestroy() { return !!pc.UnityComponent.prototype.onDestroy.call(this) && (this.onDisable(), this._joint && (this._world.destroyJoint(this._joint), this._joint = null), !0) }
            _queuesToSubscribe() { return t }
            onFixedUpdate(t) { if (null != this._joint) { if (this._dt = t, this._breakTorque < 1 / 0) { if (this._joint.getReactionTorque(1 / t) > this._breakTorque) return void this.onDestroy() } if (this._breakForce < 1 / 0) { this._joint.getReactionForce(1 / t, n).lengthSquared() > this._breakForceSq && this.onDestroy() } } }
            createJoint() {
                if (this._joint) return;
                this._connectedBody = this.code.connectedBody;
                let t = this._connectedBody && this._connectedBody.handle.body;
                const e = this.getAttachedRigidbody().handle.body;
                t || (t = this._adapter.getWorldBody()), this._joint = this._createJoint(e, t), this._joint._component = this
            }
            _createJoint(t, e) { const i = this._jointDef; return i.bodyA = t, i.bodyB = e, i.active = this.enabled, i.collideConnected = this._enableCollision, i }
            update() {}
            enable() { this._jointDef.active = !0, this._joint && this._joint.setActive(!0) }
            disable() { this._jointDef.active = !1, this._joint && this._joint.setActive(!1) }
            getEnableCollision() { return this._enableCollision }
            setEnableCollision(t) { this._enableCollision = !!t, this._joint && this._joint.setCollideConnected(t) }
            getAttachedRigidbody() { if (this._attachedRigidbody) return this._attachedRigidbody; const t = this._entity._unityComponents.rigidbody2D[0]; return this._attachedRigidbody = UnityEngine.Object.FromHandle(UnityEngine.Rigidbody2D, t), this._attachedRigidbody }
            getConnectedBody() { return this._connectedBody }
            setConnectedBody(t) { this._connectedBody !== t && (this._connectedBody = t, this._joint && this._joint.setBodyB(t ? this._connectedBody.handle.body : this._adapter.getWorldBody())) }
            getBreakForce() { return this._breakForce }
            setBreakForce(t) { t < 0 && (t = 0), this._breakForce = t, this._breakForceSq = t * t }
            getBreakTorque() { return this._breakTorque }
            setBreakTorque(t) { this._breakTorque = t < 0 ? 0 : t }
            getReactionForce(t) { return t > 0 && this._joint ? (new pc.Vec2).copy(this._joint.getReactionForce(1 / t, n)) : new pc.Vec2 }
            getFrameReactionForce() { return this._dt > 0 && this._joint ? (new pc.Vec2).copy(this._joint.getReactionForce(1 / this._dt, n)) : new pc.Vec2 }
            getReactionTorque(t) { return t > 0 && this._joint ? this._joint.getReactionTorque(1 / t) : 0 }
            getFrameReactionTorque() { return this._dt > 0 && this._joint ? this._joint.getReactionTorque(1 / this._dt) : 0 }
        }
        class r extends s {
            constructor(t) { super(t), t ? (this._autoConfigureConnectedAnchor = !!t.autoConfigureConnectedAnchor, this._connectedAnchor = t.connectedAnchor, this._anchor = t.anchor) : (this._autoConfigureConnectedAnchor = !0, this._connectedAnchor = new pc.Vec2, this._anchor = pc.Vec2.ZERO) }
            _initializeCode() { this._code && (this["__UnityEngine.AnchoredJoint2D"] = this._code), s.prototype._initializeCode.call(this) }
            _createJoint(t, e) {
                const i = s.prototype._createJoint.call(this, t, e);
                i.localAnchorA = new planck.Vec2(this._anchor);
                const n = new planck.Vec2(this._connectedAnchor);
                return this._autoConfigureConnectedAnchor ? (i.localAnchorB = this._getConnectedAnchor(t, e, i.localAnchorA, n), this._connectedAnchor.set(n.x, n.y)) : i.localAnchorB = n, i
            }
            _getConnectedAnchor(t, e, i, n) { return e.getLocalPoint(t.getWorldPoint(i, n), n) }
            getAutoConfigureConnectedAnchor() { return this._autoConfigureConnectedAnchor }
            setAutoConfigureConnectedAnchor(t) { this._autoConfigureConnectedAnchor = !!t }
            getAnchor() { return this._anchor.clone() }
            setAnchor(t) { this._anchor.equals(t) || (this._anchor = t, this._joint && this._joint.setLocalAnchorA(this._joint.getLocalAnchorA().set(t.x, t.y))) }
            getConnectedAnchor() { return this._connectedAnchor.clone() }
            setConnectedAnchor(t) { this._autoConfigureConnectedAnchor || this._connectedAnchor.equals(t) || (this._connectedAnchor = t, this._joint && this._joint.setLocalAnchorB(this._joint.getLocalAnchorB().set(t.x, t.y))) }
            update() {
                if (!this._autoConfigureConnectedAnchor) return;
                const t = this._joint;
                if (!t) return;
                const e = t.getBodyA(),
                    i = t.getBodyB();
                (e._isEntityTransformed || i._isEntityTransformed) && this._resetConnectedAnchor(t, e, i)
            }
            _updateConnectedAnchor() {
                if (!this._autoConfigureConnectedAnchor) return;
                const t = this._joint;
                t && this._resetConnectedAnchor(t, t.getBodyA(), t.getBodyB())
            }
            _resetConnectedAnchor(t, e, i) {
                const n = t.getLocalAnchorB();
                t.setLocalAnchorB(this._getConnectedAnchor(e, i, t.getLocalAnchorA(), n)), this._connectedAnchor.set(n.x, n.y)
            }
            setConnectedBody(t) { this._connectedBody !== t && (s.prototype.setConnectedBody.call(this, t), this.enabled && this._updateConnectedAnchor()) }
            enable() { s.prototype.enable.call(this), this._updateConnectedAnchor() }
        }
        return {
            Joint2DComponent: s,
            AnchoredJoint2DComponent: r,
            SpringJoint2DComponent: class extends r {
                constructor(t) { super(t), this._type = "springJoint2D", t ? (this._frequency = t.frequency, this._dampingRatio = t.dampingRatio, this._distance = t.distance) : (this._autoConfigureConnectedAnchor = !1, this._frequency = 1, this._dampingRatio = 0, this._distance = 0) }
                _initializeCode() { this._code = new UnityEngine.SpringJoint2D(this), this["__UnityEngine.SpringJoint2D"] = this._code, r.prototype._initializeCode.call(this) }
                _createJoint(t, e) { const i = r.prototype._createJoint.call(this, t, e); return i.frequencyHz = this._frequency, i.dampingRatio = this._dampingRatio, i.length = this._distance, this._world.createJoint(new planck.DistanceJoint(i)) }
                getDistance() { return this._distance }
                setDistance(t) { this._distance = t, this._joint && this._joint.setLength(t) }
                getFrequency() { return this._frequency }
                setFrequency(t) { this._frequency = t, this._joint && this._joint.setFrequency(t) }
                getDampingRatio() { return this._dampingRatio }
                setDampingRatio(t) { this._dampingRatio = t, this._joint && this._joint.setDampingRatio(t) }
            },
            DistanceJoint2DComponent: class extends r {
                constructor(t) { super(t), this._type = "distanceJoint2D", t ? (this._maxDistanceOnly = !!t.maxDistanceOnly, this._distance = t.distance, this._autoConfigureDistance = !!t.autoConfigureDistance) : (this._autoConfigureConnectedAnchor = !1, this._maxDistanceOnly = !1, this._distance = .005, this._autoConfigureDistance = !0) }
                _initializeCode() { this._code = new UnityEngine.DistanceJoint2D(this), this["__UnityEngine.DistanceJoint2D"] = this._code, r.prototype._initializeCode.call(this) }
                _createJoint(t, e) { const i = r.prototype._createJoint.call(this, t, e); return this.autoConfigureDistance && (this._distance = this._getDistance(t, e)), this._maxDistanceOnly ? (i.maxLength = this._distance, this._world.createJoint(new planck.RopeJoint(i, t, e))) : (i.frequencyHz = 0, i.dampingRatio = 1, i.length = this._distance, this._world.createJoint(new planck.DistanceJoint(i))) }
                update() {
                    const t = this._joint;
                    if (!t) return;
                    const e = t.getBodyA(),
                        i = t.getBodyB();
                    (e._isEntityTransformed || i._isEntityTransformed) && (r.prototype.update.call(this), this._autoConfigureDistance && this._resetDistance(e, i))
                }
                _updateDistance() {
                    if (!this._autoConfigureDistance) return;
                    const t = this._joint;
                    t && this._resetDistance(t.getBodyA(), t.getBodyB())
                }
                _resetDistance(t, e) {
                    const i = this._distance = this._getDistance(t, e);
                    this._joint.setLength(i), this._joint2 && this._joint2.setLength(i)
                }
                _getDistance(t, e) { return Math.max(planck.Vec2.distance(t.getWorldPoint(this._anchor), e.getWorldPoint(this._connectedAnchor)), .005) }
                getDistance() { return this._distance }
                setDistance(t) { this._autoConfigureDistance || (this._distance = t, this._joint && (this._joint.setLength(t), this._joint2 && this._joint2.setLength(t))) }
                onDestroy() { return !!pc.AnchoredJoint2DComponent.prototype.onDestroy.call(this) && (this._joint2 && (this._world.destroyJoint(this._joint2), this._joint2 = null), !0) }
                getMaxDistanceOnly() { return this._maxDistanceOnly }
                setMaxDistanceOnly(t) {
                    if (t = !!t, this._maxDistanceOnly === t) return;
                    if (this._maxDistanceOnly = t, !this._joint) return;
                    if (this._joint.setActive(!1), !this._joint2) return this._joint2 = this._joint, void(this._joint = this._createJoint(this._joint.getBodyA(), this._joint.getBodyB()));
                    const e = this._joint2;
                    this._joint2 = this._joint, this._joint = e, this._joint.setActive(this.enabled)
                }
                getAutoConfigureDistance() { return this._autoConfigureDistance }
                setAutoConfigureDistance(t) {
                    if (t = !!t, this._autoConfigureDistance === t) return;
                    if (this._autoConfigureDistance = t, !t) return;
                    const e = this._joint;
                    e && this._resetDistance(e, e.getBodyA(), e.getBodyB())
                }
                setConnectedBody(t) { this._connectedBody !== t && (r.prototype.setConnectedBody.call(this, t), this.enabled && this._updateDistance()) }
                enable() { this._updateDistance(), r.prototype.enable.call(this) }
            },
            FixedJoint2DComponent: class extends r {
                constructor(t) { super(t), this._type = "fixedJoint2D", t ? (this._frequency = t.frequency, this._dampingRatio = t.dampingRatio) : (this._frequency = 0, this._dampingRatio = 0) }
                _initializeCode() { this._code = new UnityEngine.FixedJoint2D(this), this["__UnityEngine.FixedJoint2D"] = this._code, r.prototype._initializeCode.call(this) }
                _createJoint(t, e) { const i = r.prototype._createJoint.call(this, t, e); return i.frequencyHz = this._frequency, i.dampingRatio = this._dampingRatio, this._world.createJoint(new planck.WeldJoint(i)) }
                update() {
                    const t = this._joint;
                    if (!t) return;
                    const e = t.getBodyA(),
                        i = t.getBodyB();
                    (e._isEntityTransformed || i._isEntityTransformed) && (r.prototype.update.call(this), this._resetReferenceAngle(t, e, i))
                }
                _updateReferenceAngle() {
                    const t = this._joint;
                    t && this._resetReferenceAngle(t, t.getBodyA(), t.getBodyB())
                }
                _resetReferenceAngle(t, e, i) { t.setReferenceAngle(i.getAngle() - e.getAngle()) }
                setConnectedBody(t) { this._connectedBody !== t && (r.prototype.setConnectedBody.call(this, t), this.enabled && this._updateReferenceAngle()) }
                enable() { this._updateReferenceAngle(), r.prototype.enable.call(this) }
                getFrequency() { return this._frequency }
                setFrequency(t) { this._frequency = t, this._joint && this._joint.setFrequency(t) }
                getDampingRatio() { return this._dampingRatio }
                setDampingRatio(t) { this._dampingRatio = t, this._joint && this._joint.setDampingRatio(t) }
                getReferenceAngle() { return this._joint ? this._joint.getReferenceAngle() * i : 0 }
            },
            HingeJoint2DComponent: class extends r {
                constructor(t) { super(t), this._type = "hingeJoint2D", t ? (this._limits = t.limits, this._useLimits = !!t.useLimits, this._motor = t.motor, this._useMotor = !!t.useMotor) : (this._useLimits = !1, this._useMotor = !1) }
                _initializeCode() { this._code = new UnityEngine.HingeJoint2D(this), this["__UnityEngine.HingeJoint2D"] = this._code, r.prototype._initializeCode.call(this) }
                _createJoint(t, i) { const n = r.prototype._createJoint.call(this, t, i); return n.enableLimit = this._useLimits, this._limits && (n.lowerAngle = this._limits.min * e, n.upperAngle = this._limits.max * e), n.enableMotor = this._useMotor, this._motor && (n.motorSpeed = this._motor.motorSpeed * e, n.maxMotorTorque = this._motor.maxMotorTorque), this._world.createJoint(new planck.RevoluteJoint(n)) }
                getUseLimits() { return this._useLimits }
                setUseLimits(t) { t = !!t, this._useLimits !== t && (this._useLimits = t, this._joint && this._joint.enableLimit(t)) }
                getLimits() { if (this._limits) return this._limits.$clone(); const t = new UnityEngine.JointAngleLimits2D; return t.max = 359, t }
                setLimits(t) { this._limits && this._limits.min === t.min && this._limits.max === t.max || (this._limits = t, this._joint && this._joint.setLimits(t.min * e, t.max * e)) }
                getUseMotor() { return this._useMotor }
                setUseMotor(t) { t = !!t, this._useMotor !== t && (this._useMotor = t, this._joint && this._joint.enableMotor(t)) }
                getMotor() { if (this._motor) return this._motor.$clone(); const t = new UnityEngine.JointMotor2D; return t.maxMotorTorque = 1e4, t }
                setMotor(t) {
                    if (this.setUseMotor(!0), this._motor && this._motor.motorSpeed === t.motorSpeed && this._motor.maxMotorTorque === t.maxMotorTorque) return;
                    this._motor = t;
                    const i = this._joint;
                    i && (i.setMotorSpeed(t.motorSpeed * e), i.setMaxMotorTorque(t.maxMotorTorque))
                }
                getJointAngle() { return this._joint ? this._joint.getJointAngle() * i : 0 }
            },
            WheelJoint2DComponent: class extends r {
                constructor(t) { super(t), this._type = "wheelJoint2D", this._autoConfigureConnectedAnchorMock = this._autoConfigureConnectedAnchor, this._autoConfigureConnectedAnchor = !1, t ? (this._suspension = t.suspension, this._motor = t.motor, this._useMotor = !!t.useMotor) : this._useMotor = !1 }
                _initializeCode() { this._code = new UnityEngine.WheelJoint2D(this), this["__UnityEngine.WheelJoint2D"] = this._code, r.prototype._initializeCode.call(this) }
                _createJoint(t, i) { const n = r.prototype._createJoint.call(this, t, i); return this._suspension && (n.dampingRatio = this._suspension.dampingRatio, n.frequencyHz = this._suspension.frequency, n.localAxisA = this._getAxis(this._suspension.angle)), n.enableMotor = this._useMotor, this._motor && (n.motorSpeed = this._motor.motorSpeed * e, n.maxMotorTorque = this._motor.maxMotorTorque), n.active = !!this._connectedBody, this._world.createJoint(new planck.WheelJoint(n)) }
                _getAxis(t, i) { return t *= e, (i = i || new planck.Vec2).set(Math.cos(t), Math.sin(t)) }
                getAutoConfigureConnectedAnchor() { return this._autoConfigureConnectedAnchorMock }
                setConnectedBody(t) { r.prototype.setConnectedBody.call(this, t), this._joint && this._connectedBody && this.enabled && this._joint.setActive(!0) }
                enable() { r.prototype.enable.call(this), this._joint && this._joint.setActive(!!this._connectedBody) }
                setAutoConfigureConnectedAnchor(t) { this._autoConfigureConnectedAnchorMock = !!t }
                getSuspension() { if (this._suspension) return this._suspension.$clone(); const t = new UnityEngine.JointSuspension2D; return t.dampingRatio = .7, t.frequency = 2, t.angle = 90, t }
                setSuspension(t) {
                    if (this._suspension && this._suspension.dampingRatio === t.dampingRatio && this._suspension.frequency === t.frequency && this._suspension.angle === t.angle) return;
                    this._suspension = t;
                    const e = this._joint;
                    e && (e.setSpringDampingRatio(t.dampingRatio), e.setSpringFrequencyHz(t.frequency), e.setLocalAxisA(this._getAxis(t.angle, n)))
                }
                getUseMotor() { return this._useMotor }
                setUseMotor(t) { t = !!t, this._useMotor !== t && (this._useMotor = t, this._joint && this._joint.enableMotor(t)) }
                getMotor() { if (this._motor) return this._motor.$clone(); const t = new UnityEngine.JointMotor2D; return t.maxMotorTorque = 1e4, t }
                setMotor(t) {
                    if (this.setUseMotor(!0), this._motor && this._motor.motorSpeed === t.motorSpeed && this._motor.maxMotorTorque === t.maxMotorTorque) return;
                    this._motor = t;
                    const i = this._joint;
                    i && (i.setMotorSpeed(t.motorSpeed * e), i.setMaxMotorTorque(t.maxMotorTorque))
                }
                getMotorTorque(t) { return this._joint && t > 0 ? this._joint.getMotorTorque(1 / t) : 0 }
                getJointAngle() { return this._joint ? this._joint.getJointAngle() * i : 0 }
                getJointSpeed() { return this._joint ? this._joint.getJointAngularSpeed() * i : 0 }
                getJointTranslation() { return this._joint ? this._joint.getJointTranslation() : 0 }
                getJointLinearSpeed() { return this._joint ? this._joint.getJointLinearSpeed() : 0 }
            },
            FrictionJoint2DComponent: class extends r {
                constructor(t) { super(t), this._type = "frictionJoint2D", t ? (this._maxForce = t.maxForce, this._maxTorque = t.maxTorque) : (this._maxForce = 1, this._maxTorque = 1) }
                _initializeCode() { this._code = new UnityEngine.FrictionJoint2D(this), this["__UnityEngine.FrictionJoint2D"] = this._code, r.prototype._initializeCode.call(this) }
                _createJoint(t, e) { const i = r.prototype._createJoint.call(this, t, e); return i.maxForce = this._maxForce, i.maxTorque = this._maxTorque, this._world.createJoint(new planck.FrictionJoint(i)) }
                getMaxForce() { return this._maxForce }
                setMaxForce(t) { this._maxForce = t < 0 ? 0 : t > 1e6 ? 1e6 : t, this._joint && this._joint.setMaxForce(this._maxForce) }
                getMaxTorque() { return this._maxTorque }
                setMaxTorque(t) { this._maxTorque = t < 0 ? 0 : t > 1e6 ? 1e6 : t, this._joint && this._joint.setMaxTorque(this._maxTorque) }
            },
            RelativeJoint2DComponent: class extends s {
                constructor(t) { super(t), this._type = "relativeJoint2D", t ? (this._autoConfigureOffset = !!t.autoConfigureOffset, this._linearOffset = t.linearOffset, this._angularOffset = t.angularOffset * e, this._maxForce = t.maxForce, this._maxTorque = t.maxTorque, this._correctionScale = t.correctionScale) : (this._autoConfigureOffset = !0, this._linearOffset = new pc.Vec2, this._angularOffset = 0, this._maxForce = 1e4, this._maxTorque = 1e4, this._correctionScale = .3) }
                _initializeCode() { this._code = new UnityEngine.RelativeJoint2D(this), this["__UnityEngine.RelativeJoint2D"] = this._code, s.prototype._initializeCode.call(this) }
                _createJoint(t, e) {
                    const i = s.prototype._createJoint.call(this, t, e);
                    i.maxForce = this._maxForce, i.maxTorque = this._maxTorque, i.correctionFactor = this._correctionScale;
                    const n = new planck.Vec2(this._linearOffset);
                    return this._autoConfigureOffset ? (i.linearOffset = this._getLinearOffset(t, e, n), this._linearOffset.set(n.x, n.y), i.angularOffset = this._angularOffset = this._getAngularOffset(t, e)) : (i.linearOffset = n, i.angularOffset = this._angularOffset), this._world.createJoint(new planck.MotorJoint(i))
                }
                _getLinearOffset(t, e, i) { return t.getLocalPoint(e.getPosition(), i) }
                _getAngularOffset(t, e) { return e.getAngle() - t.getAngle() }
                update() {
                    if (!this._autoConfigureOffset) return;
                    const t = this._joint;
                    if (!t) return;
                    const e = t.getBodyA(),
                        i = t.getBodyB();
                    (e._isEntityTransformed || i._isEntityTransformed) && this._resetOffsets(t, e, i)
                }
                _updateOffsets() {
                    if (!this._autoConfigureOffset) return;
                    const t = this._joint;
                    t && this._resetOffsets(t, t.getBodyA(), t.getBodyB())
                }
                _resetOffsets(t, e, i) {
                    const n = t.getLinearOffset();
                    t.setLinearOffset(this._getLinearOffset(e, i, n)), this._linearOffset.set(n.x, n.y), t.setAngularOffset(this._angularOffset = this._getAngularOffset(e, i))
                }
                setConnectedBody(t) { this._connectedBody !== t && (s.prototype.setConnectedBody.call(this, t), this.enabled && this._updateOffsets()) }
                enable() { s.prototype.enable.call(this), this._updateOffsets() }
                getAngularOffset() { return this._angularOffset * i }
                setAngularOffset(t) { t *= e, this._angularOffset !== t && (this._angularOffset = t, this._joint && this._joint.setAngularOffset(t)) }
                getLinearOffset() { return this._linearOffset.clone() }
                setLinearOffset(t) { this._linearOffset.equals(t) || (this._linearOffset = t, this._joint && this._joint.setLinearOffset(this._joint.getLinearOffset().set(t.x, t.y))) }
                getAutoConfigureOffset() { return this._autoConfigureOffset }
                setAutoConfigureOffset(t) { this._autoConfigureOffset = !!t }
                getCorrectionScale() { return this._correctionScale }
                setCorrectionScale(t) { this._correctionScale !== t && (this._correctionScale = t < 0 ? 0 : t > 1 ? 1 : t, this._joint && this._joint.setCorrectionFactor(this._correctionScale)) }
                getMaxForce() { return this._maxForce }
                setMaxForce(t) { this._maxForce !== t && (this._maxForce = t < 0 ? 0 : t > 1e6 ? 1e6 : t, this._joint && this._joint.setMaxForce(this._maxForce)) }
                getMaxTorque() { return this._maxTorque }
                setMaxTorque(t) { this._maxTorque !== t && (this._maxTorque = t < 0 ? 0 : t > 1e6 ? 1e6 : t, this._joint && this._joint.setMaxTorque(this._maxTorque)) }
                getTarget() {
                    if (!this._joint) return pc.Vec2.ZERO.clone();
                    const t = -this._angularOffset,
                        e = this._joint.getBodyB();
                    return n.set(e.getLocalCenter()).sub(this._linearOffset).rotate(Math.cos(t), Math.sin(t)), e.getWorldPoint(n, n), new pc.Vec2(n.x, n.y)
                }
            },
            SliderJoint2DComponent: class extends r {
                constructor(t) { super(t), this._type = "sliderJoint2D", t ? (this._autoConfigureAngle = !!t.autoConfigureAngle, this._angle = t.angle * e, this._useMotor = !!t.useMotor, this._motor = t.motor, this._useLimits = !!t.useLimits, this._limits = t.limits) : (this._autoConfigureConnectedAnchor = !1, this._autoConfigureAngle = !0, this._angle = 0, this._useMotor = !1, this._useLimits = !1), this._newConnectedBody = !0 }
                _initializeCode() { this._code = new UnityEngine.SliderJoint2D(this), this["__UnityEngine.SliderJoint2D"] = this._code, r.prototype._initializeCode.call(this) }
                _createJoint(t, e) { const i = r.prototype._createJoint.call(this, t, e); return i.enableMotor = this._useMotor, this._motor && (i.motorSpeed = this._motor.motorSpeed, i.maxMotorForce = this._motor.maxMotorTorque), i.enableLimit = this._useLimits, this._limits && (i.lowerTranslation = this._limits.min, i.upperTranslation = this._limits.max), i.localAxisA = this._getAxis(this._angle), this._world.createJoint(new planck.PrismaticJoint(i)) }
                _getAxis(t, e) { return (e = e || new planck.Vec2).set(Math.cos(t), Math.sin(t)) }
                update() {
                    const t = this._joint;
                    if (!t) return;
                    const e = t.getBodyA(),
                        i = t.getBodyB();
                    (e._isEntityTransformed || i._isEntityTransformed) && (r.prototype.update.call(this), this._resetAngle(t, e, i))
                }
                _updateAngle() {
                    const t = this._joint;
                    t && this._resetAngle(t, t.getBodyA(), t.getBodyB())
                }
                _resetAngle(t, e, i) {
                    if (this._newConnectedBody && (t.setReferenceAngle(i.getAngle() - e.getAngle()), this._newConnectedBody = !1), !this._autoConfigureAngle) return;
                    const s = t.getLocalAxisA(),
                        r = i.getWorldPoint(t.getLocalAnchorB(), s),
                        o = e.getWorldPoint(t.getLocalAnchorA(), n),
                        a = r.sub(o).normal();
                    this._angle = Math.atan2(a.y, a.x), t.setLocalAxisA(a)
                }
                setConnectedBody(t) { this._newConnectedBody = !0, this._connectedBody !== t && (r.prototype.setConnectedBody.call(this, t), this.enabled && this._updateAngle()) }
                enable() { this._updateAngle(), r.prototype.enable.call(this) }
                getAngle() { return this._angle * i }
                setAngle(t) {
                    if (this._autoConfigureAngle) return void this._updateAngle();
                    if (t *= e, this._angle === t) return;
                    this._angle = t;
                    const i = this._joint;
                    i && i.setLocalAxisA(this._getAxis(t, i.getLocalAxisA()))
                }
                getReferenceAngle() { return this._joint ? this._joint.getReferenceAngle() * i : 0 }
                getAutoConfigureAngle() { return this._autoConfigureAngle }
                setAutoConfigureAngle(t) { this._autoConfigureAngle = !!t }
                getUseMotor() { return this._useMotor }
                setUseMotor(t) { t = !!t, this._useMotor !== t && (this._useMotor = t, this._joint && this._joint.enableMotor(t)) }
                getMotor() { if (this._motor) return this._motor.$clone(); const t = new UnityEngine.JointMotor2D; return t.maxMotorTorque = 1e4, t }
                setMotor(t) {
                    if (this.setUseMotor(!0), this._motor && this._motor.motorSpeed === t.motorSpeed && this._motor.maxMotorTorque === t.maxMotorTorque) return;
                    this._motor = t;
                    const e = this._joint;
                    e && (e.setMotorSpeed(t.motorSpeed), e.setMaxMotorForce(t.maxMotorTorque))
                }
                getUseLimits() { return this._useLimits }
                setUseLimits(t) { t = !!t, this._useLimits !== t && (this._useLimits = t, this._joint && this._joint.enableLimit(t)) }
                getLimits() { return this._limits ? this._limits.$clone() : new UnityEngine.JointTranslationLimits2D }
                setLimits(t) { this.setUseLimits(!0), this._limits && this._limits.min === t.min && this._limits.max === t.max || (this._limits = t, this._joint && this._joint.setLimits(t.min, t.max)) }
                getLimitState() {
                    if (!this._joint) return UnityEngine.JointLimitState2D.Inactive;
                    switch (this._joint.getLimitState()) {
                        case 0:
                            return UnityEngine.JointLimitState2D.Inactive;
                        case 1:
                            return UnityEngine.JointLimitState2D.LowerLimit;
                        case 2:
                            return UnityEngine.JointLimitState2D.UpperLimit;
                        case 3:
                            return UnityEngine.JointLimitState2D.EqualLimits;
                        default:
                            return UnityEngine.JointLimitState2D.Inactive
                    }
                }
                getJointTranslation() { return this._joint ? this._joint.getJointTranslation() : 0 }
                getJointSpeed() { return this._joint ? this._joint.getJointSpeed() * i : 0 }
                getMotorForce(t) { return this._joint && t > 0 ? this._joint.getMotorForce(1 / t) : 0 }
            },
            TargetJoint2DComponent: class extends s {
                constructor(t) { super(t), this._type = "targetJoint2D", t ? (this._autoConfigureTarget = !!t.autoConfigureTarget, this._target = t.target, this._anchor = t.anchor, this._maxForce = t.maxForce, this._dampingRatio = t.dampingRatio, this._frequency = t.frequency) : (this._autoConfigureTarget = !0, this._target = new pc.Vec2, this._anchor = new pc.Vec2, this._maxForce = 1e4, this._dampingRatio = 1, this._frequency = 5) }
                _initializeCode() { this._code = new UnityEngine.TargetJoint2D(this), this["__UnityEngine.TargetJoint2D"] = this._code, s.prototype._initializeCode.call(this) }
                _createJoint(t, e) {
                    const i = s.prototype._createJoint.call(this, e, t);
                    i.maxForce = this._maxForce, i.dampingRatio = this._dampingRatio, i.frequencyHz = this._frequency, i.anchorB = new planck.Vec2(this._anchor);
                    const n = new planck.Vec2(this._target);
                    return this._autoConfigureTarget ? (i.target = n.set(t.getPosition()), this._target.set(n.x, n.y)) : i.target = n, this._world.createJoint(new planck.MouseJoint(i))
                }
                update() {
                    if (!this._autoConfigureTarget) return;
                    const t = this._joint;
                    if (!t) return;
                    const e = t.getBodyB();
                    e._isEntityTransformed && this._resetTarget(t, e)
                }
                _updateTarget() {
                    if (!this._autoConfigureOffset) return;
                    const t = this._joint;
                    t && this._resetTarget(t, t.getBodyB())
                }
                _resetTarget(t, e) {
                    const i = t.getTarget();
                    t.setTarget(i.set(e.getPosition())), this._target.set(i.x, i.y)
                }
                setConnectedBody(t) { UnityEngine.Debug.LogWarningFormat("The connected rigidbody for the 'TargetJoint2D' type cannot be set.") }
                enable() { s.prototype.enable.call(this), this._updateTarget() }
                getAutoConfigureTarget() { return this._autoConfigureTarget }
                setAutoConfigureTarget(t) { this._autoConfigureTarget = !!t }
                getTarget() { return this._target.clone() }
                setTarget(t) {
                    this._target.set(t);
                    const e = this._joint;
                    e && e.setTarget(e.getTarget().set(t.x, t.y))
                }
                getAnchor() { return this._anchor.clone() }
                setAnchor(t) {
                    if (this._anchor.equals(t)) return;
                    this._anchor = t;
                    const e = this._joint;
                    e && e.setLocalAnchorB(e.getLocalAnchorB().set(t.x, t.y))
                }
                getMaxForce() { return this._maxForce }
                setMaxForce(t) { this._maxForce !== t && (this._maxForce = t < 0 ? 0 : t > 1e6 ? 1e6 : t, this._joint && this._joint.setMaxForce(this._maxForce)) }
                getFrequency() { return this._frequency }
                setFrequency(t) { this._frequency !== t && (this._frequency = t < 0 ? 0 : t > 1e6 ? 1e6 : t, this._joint && this._joint.setFrequency(this._frequency)) }
                getDampingRatio() { return this._dampingRatio }
                setDampingRatio(t) { this._dampingRatio !== t && (this._dampingRatio = t < 0 ? 0 : t > 1 ? 1 : t, this._joint && this._joint.setDampingRatio(this._dampingRatio)) }
            }
        }
    }()), Object.assign(pc, function() {
        class t extends pc.UnityComponentSystem { constructor(t) { super(t), this.id = "animator", this.performanceSamplerSection = pc.Counters.ANIMATORS } }
        return { AnimatorSystem: t }
    }()), Object.assign(pc, function() {
        class t extends pc.UnityComponent {
            constructor() { super(), this.code = UnityEngine.Object.FromHandle(UnityEngine.Animator, this) }
            onEnable() { return !!pc.UnityComponent.prototype.onEnable.call(this) && (this.code.OnEnable(), !0) }
            onUpdate(t) { this.code.AddTime(t) }
            _queuesToSubscribe() { return ["onUpdate"] }
        }
        return { AnimatorComponent: t }
    }()), Object.assign(pc, function() {
        class t extends pc.UnityComponentSystem { constructor(t) { super(t), this.id = "animation", this.performanceSamplerSection = pc.Counters.ANIMATIONS } }
        return { AnimationSystem: t }
    }()), Object.assign(pc, function() {
        class t extends pc.UnityComponent {
            constructor() { super(), this.code = UnityEngine.Object.FromHandle(UnityEngine.Animation, this) }
            onEnable() { return !!pc.UnityComponent.prototype.onEnable.call(this) && (this.code.OnEnable(), !0) }
            onUpdate(t) { this.code.AddTime(t) }
            _queuesToSubscribe() { return ["onUpdate"] }
        }
        return { AnimationComponent: t }
    }()), Object.assign(pc, function() {
        class t extends pc.UnityComponentSystem { constructor(t) { super(t), this.id = "audiosourceunity" } }
        return { AudioSourceUnitySystem: t }
    }()), Object.assign(pc, function() {
        class t extends pc.UnityComponent {
            constructor(t) { super(), this._soundInstance = new pc.SoundInstance($application.app._audioManager), this._playOnAwake = t && t.playOnAwake, this.loop = t && t.loop, this.sound = t && t.sound }
            get playOnAwake() { return this._playOnAwake }
            set playOnAwake(t) { this._playOnAwake = t }
            get loop() { return this._soundInstance.loop }
            set loop(t) { this._soundInstance.loop = t }
            get volume() { return this._soundInstance.volume }
            set volume(t) { this._soundInstance.volume = t }
            get pitch() { return this._soundInstance.pitch }
            set pitch(t) { this._soundInstance.pitch = t }
            get sound() { return this._soundInstance.sound }
            set sound(t) { this._soundInstance.sound = t }
            get isPlaying() { return this._soundInstance.isPlaying }
            onEnable() { return !!pc.UnityComponent.prototype.onEnable.call(this) && (this._playOnAwake && this.play(), !0) }
            onDisable() { return !!pc.UnityComponent.prototype.onDisable.call(this) && (this._soundInstance.isPlaying && this._soundInstance.stop(), !0) }
            play() { this._soundInstance.sound && this._soundInstance.play() }
            pause() { this._soundInstance.sound && this._soundInstance.pause() }
            resume() { this._soundInstance.sound && this._soundInstance.resume() }
            stop() { this._soundInstance.sound && this._soundInstance.stop() }
        }
        return { AudioSourceUnityComponent: t }
    }()), Object.assign(pc, function() {
        class t extends pc.UnityComponentSystem { constructor(t) { super(t), this.id = "videoPlayer" } }
        return { VideoPlayerSystem: t }
    }()), Object.assign(pc, function() {
        class t extends pc.UnityComponent {
            constructor(t) { super(), this._clip = t ? t.clip : null, this.code = UnityEngine.Object.FromHandle(UnityEngine.Video.VideoPlayer, this) }
            configureForEntity(t) { this._entity = t }
            onEnable() { return !!pc.UnityComponent.prototype.onEnable.call(this) && (this.code.OnEnable(), !0) }
            onDisable() { return !!pc.UnityComponent.prototype.onDisable.call(this) && (this.code.OnDisable && this.code.OnDisable(), !0) }
            onDestroy() { return !!pc.UnityComponent.prototype.onDestroy.call(this) && (this.code.OnDestroy && this.code.OnDestroy(), !0) }
            _queuesToSubscribe() { return [] }
        }
        return { VideoPlayerComponent: t }
    }()), Bridge.assembly("LunaUnity", ((t, e) => {
        const i = /\+/g;
        Bridge.define("LunaUnity.Objects.Request", {
            ctor: function() { this.$initialize(), this.immediateRegistry = null, this.referenceQueue = [], this.pendingQueue = [], this.root = null, LunaUnity.Objects.Request.typeCache = LunaUnity.Objects.Request.typeCache || {} },
            r: function(t, e, i, n, s) {
                const r = { type: null == t ? null : "boolean" == typeof t ? t : Deserializers.types[t], id: e, targetType: i, targetObject: n, targetProperty: s };
                this.immediateRegistry ? this.resolveInstruction(this.immediateRegistry, r) : this.referenceQueue.push(r)
            },
            resolveReferences: function(t) {
                for (let e = 0; e < this.referenceQueue.length; e++) this.resolveInstruction(t, this.referenceQueue[e]);
                this.referenceQueue = this.pendingQueue, this.pendingQueue = []
            },
            resolveInstruction: function(t, e) { if (null === e.type || null === e.id) return void this.applyObject(e, null); const i = t.TryGet(e.id); if (!i) return void this.pendingQueue.push(e); const n = !0 === e.type ? null : this._getTypeByName(e.type); let s = i;!n || s.$kind || s.isPrefabProxy || (s = UnityEngine.Object.FromHandle(n, i)), this.applyObject(e, s) },
            applyObject: function(t, e) { 0 === t.targetType ? t.targetObject[t.targetProperty] = e : 1 === t.targetType ? t.targetObject.add(e) : t.targetObject.push(e) },
            d: function(t, e, i) { return null == e ? null : Deserializers[t](this, e, i) },
            deserializeTo: function(t, e, i) { return Deserializers[i || e.$$fullname](this, t, e) },
            c: function(t) { const e = this._getTypeByName(t); if (!e || !e.$$fullname) return {}; if (e.ctor && 0 === e.ctor.length) return new e.ctor; { const t = Object.create(e.prototype); return t.$initialize && t.$initialize(), t } },
            _getTypeByName: function(t) {
                const e = LunaUnity.Objects.Request.typeCache;
                if (!e.hasOwnProperty(t)) {
                    let n = Bridge.ns(t.replace(i, "."));
                    n.$$fullname || (console.warn("Unknown class found: " + t), n = null), e[t] = n
                }
                return e[t]
            }
        }), Bridge.define("LunaUnity.Objects.ImmediateRequest", {
            inherits: [LunaUnity.Objects.Request],
            ctor: function(t) { LunaUnity.Objects.Request.ctor.call(this), this.registry = t },
            r: function(t, e, i, n, s) {
                if (null === t || null === e) return;
                const r = { type: "boolean" == typeof t ? t : Deserializers.types[t], id: e, targetType: i, targetObject: n, targetProperty: s };
                this.resolveInstruction(this.registry, r)
            }
        })
    })), Bridge._getTypeByName = LunaUnity.Objects.Request.prototype._getTypeByName, Bridge.assembly("LunaUnity", ((t, e) => { Bridge.define("LunaUnity.Objects.Handlers.Base", { ctors: { ctor: function(t) { this.$initialize(), this.application = t, this.network = t.network, this.objectSpace = t.objectSpace, this.app = t.app, this.graphicsDevice = this.app.graphicsDevice, this.registry = this.objectSpace.getRegistry() } }, methods: { loadAsync: function() { throw new Error("Not implemented") } } }) })), Bridge.assembly("LunaUnity", ((t, e) => {
        const i = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Scene.GameObject"],
            n = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Components.Transform"],
            s = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Components.Animator"],
            r = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Components.Animation"],
            o = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Components.Canvas"],
            a = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Components.CanvasGroup"],
            c = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Components.RectTransform"],
            h = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Components.Camera"],
            l = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Components.VideoPlayer"],
            u = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Components.AudioSource"],
            d = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Components.Light"],
            p = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Components.MeshFilter"],
            _ = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Components.MeshRenderer"],
            f = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Components.SkinnedMeshRenderer"],
            m = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Components.SpriteRenderer"],
            y = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Components.SpriteMask"],
            g = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Components.Rigidbody"],
            E = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Components.BoxCollider"],
            A = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Components.SphereCollider"],
            b = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Components.MeshCollider"],
            C = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Components.CapsuleCollider"],
            T = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Components.Rigidbody2D"],
            S = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Components.BoxCollider2D"],
            M = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Components.CircleCollider2D"],
            x = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Components.CapsuleCollider2D"],
            P = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Components.EdgeCollider2D"],
            O = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Components.PolygonCollider2D"],
            R = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Components.SpringJoint2D"],
            v = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Components.DistanceJoint2D"],
            D = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Components.FixedJoint2D"],
            w = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Components.HingeJoint2D"],
            I = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Components.WheelJoint2D"],
            F = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Components.FrictionJoint2D"],
            L = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Components.RelativeJoint2D"],
            B = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Components.SliderJoint2D"],
            U = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Components.TargetJoint2D"],
            N = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Components.LineRenderer"],
            k = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Components.TrailRenderer"],
            z = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Components.PlatformEffector2D"];
        Bridge.define("LunaUnity.Objects.Handlers.GameObject", {
            inherits: [LunaUnity.Objects.Handlers.Base],
            ctor: function(t) { this.$initialize(), LunaUnity.Objects.Handlers.Base.ctor.call(this, t) },
            fork: function() { const t = new LunaUnity.Objects.Handlers.GameObject(this.application); return t.registry = t.registry.Clone().AllowUpdate(), t },
            loadAsync: function(t, e, i, n) { if (!this.app.systems.monoBehaviour.creatingPrefabs || n) { const i = this._loadObject(t, t.root, e, this.registry); return i.isPrefab = !0, i.objectJson = e, { result: i } } const s = { isPrefabProxy: !0, prefab: e }; return this.registry.Put(e.id, s), { result: s } },
            _loadObject: function(t, e, n, s) {
                if (s.Has(n.id) && !s.updatesAllowed) {
                    const t = s.Get(n.id);
                    if (!t.isPrefabProxy) return t;
                    s.Release(n.id)
                }
                const r = n.data,
                    o = new pc.Entity(r[i.name], this.app, this.app.systems.monoBehaviour.creatingPrefabs);
                o.enabled = !!r[i.enabled], o.cullingLayer = r[i.layer], o.static = !!r[i.isStatic], o.tag = r[i.tag], o.isPrefab && (o.objectJson = n);
                const a = n.children;
                for (let e = 0; e < a.length; e++) this._loadObject(t, o, a[e], this.registry);
                const c = n.components,
                    h = Deserializers.typeNameToIdMap["UnityEngine.CanvasRenderer"];
                for (let t = 0; t < c.length; t++) c[t].type === h && t > 1 && ([c[1], c[t]] = [c[t], c[1]]);
                for (let e = 0; e < c.length; e++) this._loadComponent(t, o, c[e], this.registry);
                return null != e && e.addChild(o), s.Put(n.id, o)
            },
            unloadAsync: function(t) { for (let e = 0; e < t.components.length; e++) this.registry.Release(t.components[e].id); for (let e = 0; e < t.children.length; e++) this.unloadAsync(t.children[e]) },
            _loadComponent: function(t, e, i, n) {
                let s = null;
                switch (Deserializers.types[i.type]) {
                    case "UnityEngine.Transform":
                        s = this._loadTransformComponent(t, e, i, n);
                        break;
                    case "UnityEngine.Animator":
                        s = this._loadAnimatorComponent(t, e, i, n);
                        break;
                    case "UnityEngine.Animation":
                        s = this._loadAnimationComponent(t, e, i, n);
                        break;
                    case "UnityEngine.Canvas":
                        s = this._loadCanvasComponent(t, e, i, n);
                        break;
                    case "UnityEngine.CanvasGroup":
                        s = this._loadCanvasGroupComponent(t, e, i, n);
                        break;
                    case "UnityEngine.EventSystems.UIBehaviour":
                        s = this._loadUIBehaviourComponent(t, e, i, n);
                        break;
                    case "UnityEngine.TextMesh":
                        s = this._loadTextMesh(t, e, i, n);
                        break;
                    case "UnityEngine.RectTransform":
                        s = this._loadRectTransformComponent(t, e, i, n);
                        break;
                    case "UnityEngine.Camera":
                        s = this._loadCameraComponent(t, e, i, n);
                        break;
                    case "UnityEngine.Video.VideoPlayer":
                        s = this._loadVideoPlayerComponent(t, e, i, n);
                        break;
                    case "UnityEngine.AudioSource":
                        s = this._loadAudioSourceComponent(t, e, i, n);
                        break;
                    case "UnityEngine.Light":
                        s = this._loadLightComponent(t, e, i, n);
                        break;
                    case "UnityEngine.MeshFilter":
                        s = this._loadMeshFilterComponent(t, e, i, n);
                        break;
                    case "UnityEngine.SkinnedMeshRenderer":
                        s = this._loadSkinnedMeshRendererComponent(t, e, i, n);
                        break;
                    case "UnityEngine.MeshRenderer":
                        s = this._loadMeshRendererComponent(t, e, i, n);
                        break;
                    case "UnityEngine.SpriteRenderer":
                        s = this._loadSpriteRendererComponent(t, e, i, n);
                        break;
                    case "UnityEngine.SpriteMask":
                        s = this._loadSpriteMaskComponent(t, e, i, n);
                        break;
                    case "UnityEngine.MonoBehaviour":
                        s = this._loadMonoBehaviourComponent(t, e, i, n);
                        break;
                    case "UnityEngine.Rigidbody":
                        s = this._loadRigidbodyComponent(t, e, i, n);
                        break;
                    case "UnityEngine.BoxCollider":
                        s = this._loadBoxColliderComponent(t, e, i, n);
                        break;
                    case "UnityEngine.SphereCollider":
                        s = this._loadSphereColliderComponent(t, e, i, n);
                        break;
                    case "UnityEngine.MeshCollider":
                        s = this._loadMeshColliderComponent(t, e, i, n);
                        break;
                    case "UnityEngine.CapsuleCollider":
                        s = this._loadCapsuleColliderComponent(t, e, i, n);
                        break;
                    case "UnityEngine.WheelCollider":
                        s = this._loadWheelColliderComponent(t, e, i, n);
                        break;
                    case "UnityEngine.CharacterController":
                        s = this._loadCharacterControllerComponent(t, e, i, n);
                        break;
                    case "UnityEngine.Rigidbody2D":
                        s = this._loadRigidbody2DComponent(t, e, i, n);
                        break;
                    case "UnityEngine.BoxCollider2D":
                        s = this._loadBoxCollider2DComponent(t, e, i, n);
                        break;
                    case "UnityEngine.CircleCollider2D":
                        s = this._loadCircleCollider2DComponent(t, e, i, n);
                        break;
                    case "UnityEngine.CapsuleCollider2D":
                        s = this._loadCapsuleCollider2DComponent(t, e, i, n);
                        break;
                    case "UnityEngine.EdgeCollider2D":
                        s = this._loadEdgeCollider2DComponent(t, e, i, n);
                        break;
                    case "UnityEngine.PolygonCollider2D":
                        s = this._loadPolygonCollider2DComponent(t, e, i, n);
                        break;
                    case "UnityEngine.SpringJoint2D":
                        s = this._loadSpringJoint2DComponent(t, e, i, n);
                        break;
                    case "UnityEngine.DistanceJoint2D":
                        s = this._loadDistanceJoint2DComponent(t, e, i, n);
                        break;
                    case "UnityEngine.FixedJoint2D":
                        s = this._loadFixedJoint2DComponent(t, e, i, n);
                        break;
                    case "UnityEngine.HingeJoint2D":
                        s = this._loadHingeJoint2DComponent(t, e, i, n);
                        break;
                    case "UnityEngine.WheelJoint2D":
                        s = this._loadWheelJoint2DComponent(t, e, i, n);
                        break;
                    case "UnityEngine.FrictionJoint2D":
                        s = this._loadFrictionJoint2DComponent(t, e, i, n);
                        break;
                    case "UnityEngine.RelativeJoint2D":
                        s = this._loadRelativeJoint2DComponent(t, e, i, n);
                        break;
                    case "UnityEngine.SliderJoint2D":
                        s = this._loadSliderJoint2DComponent(t, e, i, n);
                        break;
                    case "UnityEngine.TargetJoint2D":
                        s = this._loadTargetJoint2DComponent(t, e, i, n);
                        break;
                    case "UnityEngine.PlatformEffector2D":
                        s = this._loadPlatformEffector2DComponent(t, e, i, n);
                        break;
                    case "UnityEngine.ParticleSystem":
                        s = this._loadParticleSystemComponent(t, e, i, n);
                        break;
                    case "UnityEngine.ParticleSystemRenderer":
                        s = this._loadParticleSystemRendererComponent(t, e, i, n);
                        break;
                    case "UnityEngine.LineRenderer":
                        s = this._loadLineRendererComponent(t, e, i, n);
                        break;
                    case "UnityEngine.CanvasRenderer":
                        s = this._loadCanvasRendererComponent(t, e, i, n);
                        break;
                    case "UnityEngine.TrailRenderer":
                        s = this._loadTrailRendererComponent(t, e, i, n);
                        break;
                    case "UnityEngine.ReflectionProbe":
                        s = this._loadReflectionProbeComponent(t, e, i, n);
                        break;
                    case "UnityEngine.SpringJoint":
                    case "UnityEngine.FixedJoint":
                    case "UnityEngine.HingeJoint":
                    case "UnityEngine.CharacterJoint":
                    case "UnityEngine.ConfigurableJoint":
                        s = this._loadJointComponent(t, e, i, n)
                }
                return s && (n.Has(i.id) && n.Release(i.id), n.Put(i.id, s)), s
            },
            _loadTransformComponent: function(t, e, i, s) { const r = i.data; return e.setLocalPosition(r[n.position + 0], r[n.position + 1], r[n.position + 2]), e.setLocalRotation(r[n.rotation + 0], r[n.rotation + 1], r[n.rotation + 2], r[n.rotation + 3]), e.setLocalScale(r[n.scale + 0], r[n.scale + 1], r[n.scale + 2]), e["__UnityEngine.Transform"] = new UnityEngine.Transform(e), e },
            _loadAnimatorComponent: function(t, e, i, n) {
                const r = i.data,
                    o = new pc.AnimatorComponent;
                e.addUnityComponentFromDeserialization("animator", o), o._entity = e;
                const a = new UnityEngine.Animator(o);
                o._enabled = !!r[s.enabled], a.animatorController = n.TryGet(r[s.animatorController + 1]), a.updateMode = r[s.updateMode], o.code = a;
                const c = r[s.humanBones],
                    h = o.code.humanBones;
                for (let e = 0; e < c.length; e += 2) t.r(c[e + 0], c[e + 1], 2, h);
                return o
            },
            _loadAnimationComponent: function(t, e, i, n) {
                const s = i.data,
                    o = new(System.Collections.Generic.List$1(UnityEngine.AnimationClip).ctor),
                    a = s[r.clips];
                for (let t = 0; t < a.length; t += 2) {
                    const e = n.Get(a[t + 1]);
                    o.add(e)
                }
                const c = new pc.AnimationComponent;
                c._enabled = !!s[r.enabled], c._entity = e, e.addUnityComponentFromDeserialization("animation", c);
                const h = c["__UnityEngine.Animation"];
                return h.playAutomatically = s[r.playAutomatically], h.clip = n.TryGet(s[r.clip + 1]), h.clips = o, c.code = h, c
            },
            _loadCanvasComponent: function(t, e, i, n) { const s = pc.MonoBehaviourComponent.create({ type: Deserializers.types[i.type], enabled: i.data[o.enabled], entity: e }); return s.code.ConfigureForEntity(e), e.screen.$id = i.id, e.addUnityComponentFromDeserialization("monoBehaviour", s), e.screen.monoComponent = s, s.code.enabled = i.data[o.enabled], s.code.internalExecutionOrder = 0, t.deserializeTo(i.data, s.code, "Luna.Unity.DTO.UnityEngine.Components.Canvas"), s },
            _loadCanvasGroupComponent: function(t, e, i, n) { const s = pc.MonoBehaviourComponent.create({ type: Deserializers.types[i.type], enabled: i.data[a.enabled], entity: e }); return s.code.code = s.code, t.deserializeTo(i.data, s.code, "Luna.Unity.DTO.UnityEngine.Components.CanvasGroup"), e.addUnityComponentFromDeserialization("monoBehaviour", s), s },
            _loadUIBehaviourComponent: function(t, e, i, n) {
                const s = Deserializers.types[i.class],
                    r = pc.MonoBehaviourComponent.create({ type: s, enabled: i.enabled, entity: e });
                return r ? (r.code.ConfigureForEntity(e), t.deserializeTo(i.data, r.code), e.addUnityComponentFromDeserialization("monoBehaviour", r), r) : null
            },
            _loadTextMesh: function(t, e, i, n) { const s = pc.MonoBehaviourComponent.create({ type: Deserializers.types[i.type], enabled: !0, entity: e }); return s ? (s.code.ConfigureForEntity(e), t.deserializeTo(i.data, s.code, "Luna.Unity.DTO.UnityEngine.Components.TextMesh"), e.addUnityComponentFromDeserialization("monoBehaviour", s), s) : null },
            _loadRectTransformComponent: function(t, e, i, n) {
                const s = i.data;
                e.addComponent("element", { pivot: new pc.Vec2(s[c.pivot + 0], s[c.pivot + 1]), anchor: new pc.Vec4(s[c.anchorMin + 0], s[c.anchorMin + 1], s[c.anchorMax + 0], s[c.anchorMax + 1]), sizeDelta: new pc.Vec2(s[c.sizeDelta + 0], s[c.sizeDelta + 1]), anchoredPosition: new pc.Vec2(s[c.anchoredPosition3D + 0], s[c.anchoredPosition3D + 1]) }), e.element._width = e.element.sizeDelta.x, e.element._height = e.element.sizeDelta.y;
                const r = e.getLocalPosition();
                return e.setLocalPosition(r.x, r.y, s[c.anchoredPosition3D + 2]), e.setLocalRotation(s[c.rotation + 0], s[c.rotation + 1], s[c.rotation + 2], s[c.rotation + 3]), e.setLocalScale(s[c.scale + 0], s[c.scale + 1], s[c.scale + 2]), e["__UnityEngine.Transform"] = new UnityEngine.RectTransform(e), e["__UnityEngine.RectTransform"] = new UnityEngine.RectTransform(e), e
            },
            _loadCameraComponent: function(t, e, i, n) {
                const s = i.data,
                    r = s[h.rect];
                if (e.addComponent("camera", { enabled: !!s[h.enabled], clearColor: new pc.Color(s[h.backgroundColor + 0], s[h.backgroundColor + 1], s[h.backgroundColor + 2], s[h.backgroundColor + 3]), aspectRatio: this.graphicsDevice.width / this.graphicsDevice.height, fov: s[h.fieldOfView], nearClip: s[h.nearClipPlane], farClip: s[h.farClipPlane], clearColorBuffer: s[h.clearFlags] <= UnityEngine.CameraClearFlags.Color, clearDepthBuffer: s[h.clearFlags] <= UnityEngine.CameraClearFlags.Depth, clearStencilBuffer: s[h.clearFlags] <= UnityEngine.CameraClearFlags.Color, clearSkybox: s[h.clearFlags] === UnityEngine.CameraClearFlags.Skybox, projection: s[h.orthographic] ? pc.PROJECTION_ORTHOGRAPHIC : pc.PROJECTION_PERSPECTIVE, orthoHeight: s[h.orthographicSize], priority: s[h.depth], cullingMask: s[h.cullingMask], rect: new pc.Vec4(r[0], r[1], r[2], r[3]) }), s[h.targetTexture + 1]) { const t = UnityEngine.Object.FromHandle(UnityEngine.RenderTexture, this.registry.Get(s[h.targetTexture + 1])); if (t) { UnityEngine.Object.FromHandle(UnityEngine.Camera, e.camera).targetTexture = t, e.camera.aspectRatio = 1 * t.handle.width / t.handle.height } }
                return e.camera
            },
            _loadVideoPlayerComponent: function(t, e, i, n) {
                const s = i.data,
                    r = new pc.VideoPlayerComponent({ enabled: !!s[l.enabled], entity: e }),
                    o = new UnityEngine.Video.VideoPlayer(r);
                return o.ConfigureForEntity(e), r.code = o, t.deserializeTo(s, o, "Luna.Unity.DTO.UnityEngine.Components.VideoPlayer"), e.addUnityComponentFromDeserialization("videoPlayer", r), r
            },
            _loadAudioSourceComponent: function(t, e, i, n) {
                const s = i.data,
                    r = new pc.AudioSourceUnityComponent({ id: i.id, loop: s[u.loop], sound: n.TryGet(s[u.clip + 1]), playOnAwake: s[u.playOnAwake] });
                return e.addUnityComponentFromDeserialization("audiosourceunity", r), r.enabled = !!s[u.enabled], r
            },
            _loadLightComponent: function(t, e, i, n) { const s = i.data; return e.addComponent("light", { type: ["spot", "directional", "point", null][s[d.type]], color: new pc.Color(s[d.color + 0], s[d.color + 1], s[d.color + 2], s[d.color + 3]), intensity: s[d.intensity], outerConeAngle: s[d.spotAngle], range: s[d.range], cullingMask: s[d.cullingMask], castShadows: s[d.shadows] !== UnityEngine.LightShadows.None, shadowType: pc.SHADOW_VSM32, affectDynamic: s[d.lightmapBakeType] !== UnityEngine.LightmapBakeType.Baked, affectLightmapped: s[d.lightmapBakeType] <= UnityEngine.LightmapBakeType.Baked, enabled: !!s[d.enabled], renderMode: s[d.renderMode], cookie: n.TryGet(s[d.cookie + 1]), cookieScale: new pc.Vec2(s[d.cookieSize], s[d.cookieSize]) }), e.light },
            _loadMeshFilterComponent: function(t, e, i, n) {
                const s = i.data,
                    r = new pc.MeshFilterComponent;
                return e.addUnityComponentFromDeserialization("meshFilter", r), r.id = i.id, r.mesh = n.TryGet(s[p.sharedMesh + 1]), r.mesh || console.warn(`GameObject ${e.name} is missing mesh. Check force excluded assets if it got excluded.`), r
            },
            _loadMeshRendererComponent: function(t, e, i, n) {
                const s = i.data,
                    r = this._loadRendererComponent(_, new pc.MeshRendererComponent, t, e, i, n),
                    o = r.code;
                return o.lightProbeUsage = s[_.lightProbeUsage], o.reflectionProbeUsage = s[_.reflectionProbeUsage], r
            },
            _loadSkinnedMeshRendererComponent: function(t, e, i, n) {
                const s = i.data,
                    r = n.TryGet(s[f.sharedMesh + 1]);
                if (null == r) return console.log(`Missing mesh on skinned mesh. GameObject : ${e.name}`), null;
                const o = this._loadRendererComponent(f, new pc.SkinnedMeshRendererComponent, t, e, i, n),
                    a = o.model;
                a.mesh = r;
                const c = o.code;
                c.lightProbeUsage = s[f.lightProbeUsage], c.reflectionProbeUsage = s[f.reflectionProbeUsage];
                const h = s[f.bones];
                if (0 !== h.length) {
                    const e = new Array(h.length / 2),
                        i = new Array(0);
                    for (let n = 0; n < h.length; n += 2) t.r(!0, h[n + 1], 2, i), e.push(h[n + 1]);
                    o.model.bones = i, o.model.skin = new pc.Skin(this.graphicsDevice, r.bindposes, e), o.__renderer = "skinned-mesh";
                    const n = s[f.localBounds];
                    o.model.skin.localBounds = new pc.BoundingBox(new pc.Vec3(n[0], n[1], n[2]), new pc.Vec3(n[3], n[4], n[5])), o.model.skin.updateWhenOffscreen = !!s[f.updateWhenOffscreen], t.r(!0, s[f.rootBone + 1], 0, o.model.skin, "rootBone")
                }
                const l = s[f.blendShapesWeights];
                if (0 !== l.length) {
                    const t = new pc.MorphInstance(r.morph);
                    t._setBaseMesh(r);
                    for (let e = 0; e < l.length; e++) t.setWeight(e, l[e][0]);
                    a.morphInstance = t
                }
                return o
            },
            _loadSpriteRendererComponent: function(t, e, i, n) {
                const s = i.data,
                    r = this._loadRendererComponent(m, new pc.SpriteRendererComponent, t, e, i, n),
                    o = r.code,
                    a = n.TryGet(s[m.sprite + 1]);
                return o.sortingLayerIndex = UnityEngine.SortingLayer.GetLayerValueFromID(s[m.sortingLayerID]), o.sortingOrder = s[m.sortingOrder], o.color = new pc.Color(s[m.color + 0], s[m.color + 1], s[m.color + 2], s[m.color + 3]), o.flipX = s[m.flipX], o.flipY = s[m.flipY], o.drawMode = s[m.drawMode], o.size = new pc.Vec2(s[m.size], s[m.size + 1]), o.tileMode = s[m.tileMode], o.adaptiveModeThreshold = s[m.adaptiveModeThreshold], o.maskInteraction = s[m.maskInteraction], o.spriteSortPoint = s[m.spriteSortPoint], a && (o.sprite = UnityEngine.Object.FromHandle(UnityEngine.Sprite, a)), r.__renderer = "sprite", r
            },
            _loadSpriteMaskComponent: function(t, e, i, n) {
                const s = i.data,
                    r = new pc.SpriteMaskComponent,
                    o = this._loadRendererComponent(y, r, t, e, i, n);
                o._frontSortingLayerID = s[y.frontSortingLayerID], o._frontSortingOrder = s[y.frontSortingOrder], o._backSortingLayerID = s[y.backSortingLayerID], o._backSortingOrder = s[y.backSortingOrder], o._alphaCutoff = s[y.alphaCutoff], o._isCustomRangeActive = s[y.isCustomRangeActive], o._spriteSortPoint = s[y.spriteSortPoint];
                const a = n.TryGet(s[y.sprite + 1]);
                return a && (o.sprite = a), o
            },
            _loadRigidbodyComponent: function(t, e, i, n) {
                const s = i.data,
                    r = new pc.RigidbodyComponent({ enabled: !0, maxAngularVelocity: s[g.maxAngularVelocity], mass: s[g.mass], drag: s[g.drag], angularDrag: s[g.angularDrag], useGravity: !!s[g.useGravity], isKinematic: !!s[g.isKinematic], constraints: s[g.constraints], collisionDetectionMode: s[g.collisionDetectionMode], interpolation: s[g.interpolation] });
                return e.addUnityComponentFromDeserialization("rigidbody", r), r
            },
            _loadBoxColliderComponent: function(t, e, i, n) {
                const s = i.data,
                    r = new pc.BoxColliderComponent({ enabled: !!s[E.enabled], size: new pc.Vec3(s[E.size + 0], s[E.size + 1], s[E.size + 2]), material: n.TryGet(s[E.material + 1]), center: new pc.Vec3(s[E.center + 0], s[E.center + 1], s[E.center + 2]), isTrigger: !!s[E.isTrigger] });
                return e.addUnityComponentFromDeserialization("collider", r), r
            },
            _loadSphereColliderComponent: function(t, e, i, n) {
                const s = i.data,
                    r = new pc.SphereColliderComponent({ enabled: !!s[A.enabled], radius: s[A.radius], material: n.TryGet(s[A.material + 1]), center: new pc.Vec3(s[A.center + 0], s[A.center + 1], s[A.center + 2]), isTrigger: !!s[A.isTrigger] });
                return e.addUnityComponentFromDeserialization("collider", r), r
            },
            _loadMeshColliderComponent: function(t, e, i, n) {
                const s = i.data,
                    r = new pc.MeshColliderComponent({ enabled: !!s[b.enabled], mesh: n.TryGet(s[b.sharedMesh + 1]), material: n.TryGet(s[b.material + 1]), isTrigger: !!s[b.isTrigger], convex: !!s[b.convex] });
                return e.addUnityComponentFromDeserialization("collider", r), r
            },
            _loadCapsuleColliderComponent: function(t, e, i, n) {
                const s = i.data,
                    r = new pc.CapsuleColliderComponent({ enabled: !!s[C.enabled], radius: s[C.radius], material: n.TryGet(s[C.material + 1]), center: new pc.Vec3(s[C.center + 0], s[C.center + 1], s[C.center + 2]), height: s[C.height], direction: s[C.direction], isTrigger: !!s[C.isTrigger] });
                return e.addUnityComponentFromDeserialization("collider", r), r
            },
            _loadWheelColliderComponent: function(t, e, i, n) {
                const s = i.data,
                    r = new pc.WheelColliderComponent,
                    o = UnityEngine.Object.FromHandle(Bridge._getTypeByName(Deserializers.types[i.type]), r);
                return t.deserializeTo(s, o, "Luna.Unity.DTO.UnityEngine.Components.WheelCollider"), e.addUnityComponentFromDeserialization("collider", r), r
            },
            _loadCharacterControllerComponent: function(t, e, i, n) {
                const s = new pc.CharacterControllerComponent,
                    r = UnityEngine.Object.FromHandle(Bridge._getTypeByName(Deserializers.types[i.type]), s);
                return t.deserializeTo(i.data, r, "Luna.Unity.DTO.UnityEngine.Components.CharacterController"), e.addUnityComponentFromDeserialization("collider", s), s
            },
            _loadRigidbody2DComponent: function(t, e, i, n) {
                const s = i.data,
                    r = new pc.Rigidbody2DComponent({ entity: e, enabled: !0, simulated: s[T.simulated], useAutoMass: s[T.useAutoMass], type: s[T.bodyType], mass: s[T.mass], drag: s[T.drag], angularDrag: s[T.angularDrag], gravityScale: s[T.gravityScale], collisionDetectionMode: s[T.collisionDetectionMode], constraints: s[T.constraints], material: n.TryGet(T.material + 1) });
                return e.addUnityComponentFromDeserialization("rigidbody2D", r), r
            },
            _loadBoxCollider2DComponent: function(t, e, i, n) {
                const s = i.data,
                    r = new pc.BoxCollider2DComponent({ enabled: !!s[S.enabled], isTrigger: s[S.isTrigger], usedByEffector: s[S.usedByEffector], density: s[S.density], size: new pc.Vec2(s[S.size + 0], s[S.size + 1]), center: new pc.Vec2(s[S.offset + 0], s[S.offset + 1]), radius: s[S.edgeRadius], material: n.TryGet(s[S.material + 1]) });
                return e.addUnityComponentFromDeserialization("collider2D", r), r
            },
            _loadCircleCollider2DComponent: function(t, e, i, n) {
                const s = i.data,
                    r = new pc.CircleCollider2DComponent({ enabled: !!s[M.enabled], isTrigger: s[M.isTrigger], usedByEffector: s[M.usedByEffector], density: s[M.density], radius: s[M.radius], center: new pc.Vec2(s[M.offset + 0], s[M.offset + 1]), material: n.TryGet(s[M.material + 1]) });
                return e.addUnityComponentFromDeserialization("collider2D", r), r
            },
            _loadCapsuleCollider2DComponent: function(t, e, i, n) {
                const s = i.data,
                    r = new pc.CapsuleCollider2DComponent({ enabled: !!s[x.enabled], isTrigger: s[x.isTrigger], usedByEffector: s[x.usedByEffector], density: s[x.density], center: new pc.Vec2(s[x.offset + 0], s[x.offset + 1]), material: n.TryGet(s[x.material + 1]), direction: s[x.direction], size: new pc.Vec2(s[x.size + 0], s[x.size + 1]) });
                return e.addUnityComponentFromDeserialization("collider2D", r), r
            },
            _loadEdgeCollider2DComponent: function(t, e, i, n) {
                const s = i.data,
                    r = new pc.EdgeCollider2DComponent({ enabled: !!s[P.enabled], isTrigger: s[P.isTrigger], usedByEffector: s[P.usedByEffector], density: s[P.density], points: s[P.points], offset: new pc.Vec2(s[P.offset + 0], s[P.offset + 1]), radius: s[P.edgeRadius], material: n.TryGet(s[P.material + 1]) });
                return e.addUnityComponentFromDeserialization("collider2D", r), r
            },
            _loadPolygonCollider2DComponent: function(t, e, i, n) {
                const s = i.data,
                    r = new pc.PolygonCollider2DComponent({ enabled: !!s[O.enabled], isTrigger: s[O.isTrigger], usedByEffector: s[O.usedByEffector], density: s[O.density], points: s[O.points], offset: new pc.Vec2(s[O.offset + 0], s[O.offset + 1]), material: n.TryGet(s[O.material + 1]) });
                return e.addUnityComponentFromDeserialization("collider2D", r), r
            },
            _loadSpringJoint2DComponent: function(t, e, i, n) { const s = i.data; return this._loadJoint2DComponent(t, e, i, R, new pc.SpringJoint2DComponent({ enabled: !!s[R.enabled], enableCollision: s[R.enableCollision], breakForce: s[R.breakForce], breakTorque: s[R.breakTorque], frequency: s[R.frequency], dampingRatio: s[R.dampingRatio], distance: s[R.distance], autoConfigureConnectedAnchor: s[R.autoConfigureConnectedAnchor], anchor: new pc.Vec2(s[R.anchor + 0], s[R.anchor + 1]), connectedAnchor: new pc.Vec2(s[R.connectedAnchor + 0], s[R.connectedAnchor + 1]) })) },
            _loadDistanceJoint2DComponent: function(t, e, i, n) { const s = i.data; return this._loadJoint2DComponent(t, e, i, v, new pc.DistanceJoint2DComponent({ enabled: !!s[v.enabled], enableCollision: s[v.enableCollision], breakForce: s[v.breakForce], breakTorque: s[v.breakTorque], maxDistanceOnly: s[v.maxDistanceOnly], distance: s[v.distance], autoConfigureDistance: s[v.autoConfigureDistance], autoConfigureConnectedAnchor: s[v.autoConfigureConnectedAnchor], anchor: new pc.Vec2(s[v.anchor + 0], s[v.anchor + 1]), connectedAnchor: new pc.Vec2(s[v.connectedAnchor + 0], s[v.connectedAnchor + 1]) })) },
            _loadFixedJoint2DComponent: function(t, e, i, n) { const s = i.data; return this._loadJoint2DComponent(t, e, i, D, new pc.FixedJoint2DComponent({ enabled: !!s[D.enabled], enableCollision: s[D.enableCollision], breakForce: s[D.breakForce], breakTorque: s[D.breakTorque], frequency: s[D.frequency], dampingRatio: s[D.dampingRatio], autoConfigureConnectedAnchor: s[D.autoConfigureConnectedAnchor], anchor: new pc.Vec2(s[D.anchor + 0], s[D.anchor + 1]), connectedAnchor: new pc.Vec2(s[D.connectedAnchor + 0], s[D.connectedAnchor + 1]) })) },
            _loadHingeJoint2DComponent: function(t, e, i, n) {
                const s = i.data,
                    r = new UnityEngine.JointAngleLimits2D;
                t.deserializeTo(s[w.limits], r);
                const o = new UnityEngine.JointMotor2D;
                return t.deserializeTo(s[w.motor], o), this._loadJoint2DComponent(t, e, i, w, new pc.HingeJoint2DComponent({ enabled: !!s[w.enabled], enableCollision: s[w.enableCollision], breakForce: s[w.breakForce], breakTorque: s[w.breakTorque], autoConfigureConnectedAnchor: s[w.autoConfigureConnectedAnchor], anchor: new pc.Vec2(s[w.anchor + 0], s[w.anchor + 1]), connectedAnchor: new pc.Vec2(s[w.connectedAnchor + 0], s[w.connectedAnchor + 1]), useLimits: s[w.useLimits], limits: r, useMotor: s[w.useMotor], motor: o }))
            },
            _loadWheelJoint2DComponent: function(t, e, i, n) {
                const s = i.data,
                    r = new UnityEngine.JointSuspension2D;
                t.deserializeTo(s[I.suspension], r);
                const o = new UnityEngine.JointMotor2D;
                return t.deserializeTo(s[I.motor], o), this._loadJoint2DComponent(t, e, i, I, new pc.WheelJoint2DComponent({ enabled: !!s[I.enabled], enableCollision: s[I.enableCollision], breakForce: s[I.breakForce], breakTorque: s[I.breakTorque], autoConfigureConnectedAnchor: s[I.autoConfigureConnectedAnchor], anchor: new pc.Vec2(s[I.anchor + 0], s[I.anchor + 1]), connectedAnchor: new pc.Vec2(s[I.connectedAnchor + 0], s[I.connectedAnchor + 1]), suspension: r, useMotor: s[I.useMotor], motor: o }))
            },
            _loadFrictionJoint2DComponent: function(t, e, i, n) { const s = i.data; return this._loadJoint2DComponent(t, e, i, F, new pc.FrictionJoint2DComponent({ enabled: !!s[F.enabled], enableCollision: s[F.enableCollision], breakForce: s[F.breakForce], breakTorque: s[F.breakTorque], autoConfigureConnectedAnchor: s[F.autoConfigureConnectedAnchor], anchor: new pc.Vec2(s[F.anchor + 0], s[F.anchor + 1]), connectedAnchor: new pc.Vec2(s[F.connectedAnchor + 0], s[F.connectedAnchor + 1]), maxForce: s[F.maxForce], maxTorque: s[F.maxTorque] })) },
            _loadRelativeJoint2DComponent: function(t, e, i, n) { const s = i.data; return this._loadJoint2DComponent(t, e, i, L, new pc.RelativeJoint2DComponent({ enabled: !!s[L.enabled], enableCollision: s[L.enableCollision], breakForce: s[L.breakForce], breakTorque: s[L.breakTorque], autoConfigureOffset: s[L.autoConfigureOffset], linearOffset: new pc.Vec2(s[L.linearOffset + 0], s[L.linearOffset + 1]), angularOffset: s[L.angularOffset], maxForce: s[L.maxForce], maxTorque: s[L.maxTorque], correctionScale: s[L.correctionScale] })) },
            _loadSliderJoint2DComponent: function(t, e, i, n) {
                const s = i.data,
                    r = new UnityEngine.JointTranslationLimits2D;
                t.deserializeTo(s[B.limits], r);
                const o = new UnityEngine.JointMotor2D;
                return t.deserializeTo(s[B.motor], o), this._loadJoint2DComponent(t, e, i, B, new pc.SliderJoint2DComponent({ enabled: !!s[B.enabled], enableCollision: s[B.enableCollision], breakForce: s[B.breakForce], breakTorque: s[B.breakTorque], autoConfigureConnectedAnchor: s[B.autoConfigureConnectedAnchor], anchor: new pc.Vec2(s[B.anchor + 0], s[B.anchor + 1]), connectedAnchor: new pc.Vec2(s[B.connectedAnchor + 0], s[B.connectedAnchor + 1]), autoConfigureAngle: s[B.autoConfigureAngle], angle: s[B.angle], useLimits: s[B.useLimits], limits: r, useMotor: s[B.useMotor], motor: o }))
            },
            _loadTargetJoint2DComponent: function(t, e, i, n) { const s = i.data; return this._loadJoint2DComponent(t, e, i, U, new pc.TargetJoint2DComponent({ enabled: !!s[U.enabled], enableCollision: s[U.enableCollision], breakForce: s[U.breakForce], breakTorque: s[U.breakTorque], autoConfigureTarget: s[U.autoConfigureTarget], target: new pc.Vec2(s[U.target + 0], s[U.target + 1]), anchor: new pc.Vec2(s[U.anchor + 0], s[U.anchor + 1]), maxForce: s[U.maxForce], dampingRatio: s[U.dampingRatio], frequency: s[U.frequency] })) },
            _loadPlatformEffector2DComponent: function(t, e, i, n) {
                const s = i.data,
                    r = new pc.PlatformEffector2DComponent({ enabled: !!s[z.enabled] });
                return e.addUnityComponentFromDeserialization("effector2D", r), r
            },
            _loadJoint2DComponent: function(t, e, i, n, s) {
                const r = i.data,
                    o = Deserializers.types[i.type],
                    a = UnityEngine.Object.FromHandle(Bridge._getTypeByName(o), s);
                return t.r(r[n.connectedBody + 0], r[n.connectedBody + 1], 0, a, "connectedBody"), e.addUnityComponentFromDeserialization("joint2D", s), s
            },
            _loadParticleSystemComponent: function(t, e, i, n) {
                const s = new pc.ParticleSystem,
                    r = new pc.ParticleSystemComponent({ particleSystem: s });
                return t.deserializeTo(i.data, s, "Luna.Unity.DTO.UnityEngine.Components.ParticleSystem"), e.addUnityComponentFromDeserialization("particlesystem", r), r
            },
            _loadParticleSystemRendererComponent: function(t, e, i, n) {
                const s = new pc.ParticleSystemRenderer;
                t.deserializeTo(i.data, s, "Luna.Unity.DTO.UnityEngine.Components.ParticleSystemRenderer"), s.sortingLayerIndex = UnityEngine.SortingLayer.GetLayerValueFromID(s.sortingLayerID), s.sortingOrder = s.sortingOrder;
                const r = new pc.ParticleSystemRendererComponent({ particleSystemRenderer: s });
                return e.addUnityComponentFromDeserialization("particleSystemRenderer", r), r.enabled = s.enabled, r
            },
            _loadJointComponent: function(t, e, i, n) {
                const s = i.data,
                    r = new pc.JointComponent({ type: Deserializers.types[i.type] }),
                    o = UnityEngine.Object.FromHandle(Bridge._getTypeByName(Deserializers.types[i.type]), r);
                return t.deserializeTo(s, o, Deserializers.types[i.type].replace("UnityEngine.", "Luna.Unity.DTO.UnityEngine.Components.")), e.addUnityComponentFromDeserialization("joint", r), r
            },
            _loadMonoBehaviourComponent: function(t, e, i, n) {
                const s = Deserializers.types[i.class],
                    r = pc.MonoBehaviourComponent.create({ type: s, enabled: !!i.enabled, entity: e });
                return r ? (t.deserializeTo(i.data, r.code), e.addUnityComponentFromDeserialization("monoBehaviour", r), r) : null
            },
            _loadRendererComponent: function(t, e, i, n, s, r) {
                const o = s.data,
                    a = e;
                n.addUnityComponentFromDeserialization("renderer", a);
                const c = o[t.sharedMaterials],
                    h = [];
                for (let t = 0; t < c.length; t += 2) {
                    let e = r.TryGet(c[t + 1]);
                    e || (e = UnityEngine.Graphics.InternalErrorShaderMaterial.handle), h.push(e)
                }
                return a.model.materials = h, a.model.sortingLayerIndex = UnityEngine.SortingLayer.GetLayerValueFromID(o[t.sortingLayerID]), a.model.sortingOrder = o[t.sortingOrder], a.model.cullingLayer = n.cullingLayer, a.enabled = !!o[t.enabled], a.castShadows = o[t.shadowCastingMode] > UnityEngine.Rendering.ShadowCastingMode.Off, a.receiveShadows = !!o[t.receiveShadows], a.id = s.id, a.model._lightmapSceneIndex = o[t.lightmapSceneIndex], a.model._lightmapIndex = o[t.lightmapIndex], a.model.lightmapScaleOffset = new pc.Vec4(o[t.lightmapScaleOffset + 0], o[t.lightmapScaleOffset + 1], o[t.lightmapScaleOffset + 2], o[t.lightmapScaleOffset + 3]), a
            },
            _loadLineRendererComponent: function(t, e, i, n) {
                const s = this._loadRendererComponent(N, new pc.LineRendererComponent, t, e, i, n),
                    r = s.code;
                return t.deserializeTo(i.data, r, "Luna.Unity.DTO.UnityEngine.Components.LineRenderer"), s
            },
            _loadCanvasRendererComponent: function(t, e, i, n) { const s = new pc.CanvasRendererComponent; return t.deserializeTo(i.data, s.code, "Luna.Unity.DTO.UnityEngine.Components.CanvasRenderer"), e.addUnityComponentFromDeserialization("canvasRenderer", s), s },
            _loadTrailRendererComponent: function(t, e, i, n) {
                const s = this._loadRendererComponent(k, new pc.TrailRendererComponent, t, e, i, n),
                    r = s.code;
                return t.deserializeTo(i.data, r, "Luna.Unity.DTO.UnityEngine.Components.TrailRenderer"), s
            },
            _loadReflectionProbeComponent: function(t, e, i, n) {
                const s = i.data,
                    r = new pc.ReflectionProbeComponent,
                    o = UnityEngine.Object.FromHandle(UnityEngine.ReflectionProbe, r);
                return t.deserializeTo(s, o, "Luna.Unity.DTO.UnityEngine.Components.ReflectionProbe"), e.addUnityComponentFromDeserialization("reflectionprobe", r), r
            }
        })
    })), Bridge.assembly("LunaUnity", ((t, e) => {
        Bridge.define("LunaUnity.Objects.Handlers.AudioMixer", {
            inherits: [LunaUnity.Objects.Handlers.Base],
            ctor: function(t) { this.$initialize(), LunaUnity.Objects.Handlers.Base.ctor.call(this, t) },
            loadAsync: function(t, e, i) {
                const n = t.d("Luna.Unity.DTO.UnityEngine.Audio.AudioMixer", e.data),
                    s = new UnityEditor.Audio.AudioMixerController(n);
                this.registry.Put(e.id, s);
                for (let t = 0; t < s.groups.length; t++) this.registry.Put(s.groups[t].id, s.groups[t]);
                return { result: s }
            },
            unloadAsync: function(t) { this.registry.Release(t.id) }
        })
    })), Bridge.assembly("LunaUnity", ((t, e) => {
        Bridge.define("LunaUnity.Objects.Handlers.AudioMixerSnapshot", {
            inherits: [LunaUnity.Objects.Handlers.Base],
            ctor: function(t) { this.$initialize(), LunaUnity.Objects.Handlers.Base.ctor.call(this, t) },
            loadAsync: function(t, e, i) {
                const n = t.d("Luna.Unity.DTO.UnityEngine.Audio.AudioMixerSnapshot", e.data),
                    s = new UnityEngine.Audio.AudioMixerSnapshot(n);
                return this.registry.Put(e.id, s), { result: s }
            },
            unloadAsync: function(t) { this.registry.Release(t.id) }
        })
    })), Bridge.assembly("LunaUnity", ((t, e) => {
        const i = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Assets.ProjectSettings"],
            n = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Assets.ProjectSettings+ScriptsExecutionOrder"],
            s = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Assets.ProjectSettings+SortingLayer"],
            r = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Assets.ProjectSettings+CullingLayer"],
            o = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Assets.ProjectSettings+TimeSettings"],
            a = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Assets.ProjectSettings+PhysicsSettings"],
            c = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Assets.ProjectSettings+PhysicsSettings+CollisionMask"],
            h = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Assets.ProjectSettings+Physics2DSettings"];
        Bridge.define("LunaUnity.Objects.Handlers.ProjectSettings", {
            inherits: [LunaUnity.Objects.Handlers.Base],
            ctor: function(t) { this.$initialize(), LunaUnity.Objects.Handlers.Base.ctor.call(this, t) },
            loadAsync: function(t, e, l) {
                const u = e.data,
                    d = u[i.scriptsExecutionOrder],
                    p = [];
                for (let t = 0; t < d.length; t++) {
                    const e = d[t];
                    p[e[n.name]] = e[n.value]
                }
                this.app.systems.monoBehaviour.scriptsExecutionOrder = p;
                const _ = u[i.sortingLayers];
                pc.Application.getApplication().renderer.removeShadows = !!u[i.removeShadows], this.autoInstantiatePrefabs = !!u[i.autoInstantiatePrefabs];
                for (let t = 0; t < _.length; t++) {
                    const e = new UnityEngine.SortingLayer,
                        i = _[t];
                    e.id = i[s.id], e.name = i[s.name], e.value = i[s.value], UnityEngine.SortingLayer.layers.push(e)
                }
                const f = u[i.cullingLayers];
                for (let t = 0; t < f.length; t++) {
                    const e = new UnityEngine.LayerMask.CullingLayer,
                        i = f[t];
                    e.id = i[r.id], e.name = i[r.name], UnityEngine.LayerMask.layers.push(e)
                }
                const m = u[i.timeSettings];
                this.app.systems.unitymanager.fixedTimeStep = m[o.fixedDeltaTime], this.app.systems.unitymanager.maximumAllowedTimeStep = m[o.maximumDeltaTime], this.app.systems.unitymanager.timeScale = m[o.timeScale], this.app.systems.unitymanager.maximumParticleTimestep = m[o.maximumParticleTimestep];
                const y = u[i.physicsSettings];
                this.app.systems.physics.gravity = new pc.Vec3(y[a.gravity + 0], y[a.gravity + 1], y[a.gravity + 2]);
                const g = y[a.collisionMatrix];
                for (let t = 0; t < g.length; t++) {
                    const e = g[t];
                    this.app.systems.physics.setIgnoreCollisionBetweenLayers(e[c.layerId], e[c.otherLayerId], e[c.enabled])
                }
                this.app.systems.physics.defaultSolverIterations = y[a.defaultSolverIterations], this.app.systems.physics.autoSyncTransforms = !!y[a.autoSyncTransforms], this.app.systems.physics.autoSimulation = !!y[a.autoSimulation];
                const E = this.app.systems.physics2D,
                    A = u[i.physics2DSettings];
                E.gravity = new pc.Vec2(A[h.gravity + 0], A[h.gravity + 1]), E.autoSyncTransforms = A[h.autoSyncTransforms], E.positionIterations = A[h.positionIterations], E.velocityIterations = A[h.velocityIterations], t.r(!0, A[h.material + 1], 0, E, "defaultMaterial");
                const b = A[h.collisionMatrix];
                for (let t = 0; t < b.length; t++) {
                    const e = b[t];
                    E.setIgnoreCollisionBetweenLayers(e[c.layerId], e[c.otherLayerId], e[c.enabled])
                }
                return UnityEngine.Graphics.graphicsDevice.enableAutoInstancing = !!u[i.enableAutoInstancing], UnityEngine.LightmapSettings.lightmapEncodingQuality = u[i.lightmapEncodingQuality], UnityEngine.LightmapSettings.bakedColorSpace = u[i.desiredColorSpace], {}
            },
            unloadAsync: function(t) { this.registry.Release(t.id) }
        })
    })), Bridge.assembly("LunaUnity", ((t, e) => {
        const i = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Assets.Material"];
        Bridge.define("LunaUnity.Objects.Handlers.Material", { inherits: [LunaUnity.Objects.Handlers.Base], ctor: function(t) { this.$initialize(), LunaUnity.Objects.Handlers.Base.ctor.call(this, t), this.request = new LunaUnity.Objects.ImmediateRequest(null) }, loadAsync: function(t, e, n) { this.request.registry = this.registry; const s = this.request.d("Luna.Unity.DTO.UnityEngine.Assets.Material", e.data); return s.shader = this.registry.TryGet(e.data[i.shader + 1]), s.setup(), "Default UI Material" === s.name && (UnityEngine.Canvas.DefaultCanvasMaterial = UnityEngine.Object.FromHandle(UnityEngine.Material, s)), "Sprites-Default" === s.name && (UnityEngine.Material.SpritesDefault = UnityEngine.Object.FromHandle(UnityEngine.Material, s)), "Sprites-Mask" === s.name && (UnityEngine.Material.SpriteMasksDefault = UnityEngine.Object.FromHandle(UnityEngine.Material, s)), "Font Material" === s.name && (UnityEngine.Material.FontDefault = UnityEngine.Object.FromHandle(UnityEngine.Material, s)), this.registry.Put(e.id, s), System.Threading.Tasks.Task.fromResult(s) }, unloadAsync: function(t) { this.registry.Release(t.id) } })
    })), Bridge.assembly("LunaUnity", ((t, e) => {
        Bridge.define("LunaUnity.Objects.Handlers.PhysicMaterial", {
            inherits: [LunaUnity.Objects.Handlers.Base],
            ctor: function(t) { this.$initialize(), LunaUnity.Objects.Handlers.Base.ctor.call(this, t) },
            loadAsync: function(t, e) {
                const i = t.d("Luna.Unity.DTO.UnityEngine.Assets.PhysicMaterial", e.data),
                    n = new Goblin.PhysicMaterial(i);
                return this.registry.Put(e.id, n), { result: n }
            },
            unloadAsync: function(t) { this.registry.Release(t.id) }
        })
    })), Bridge.assembly("LunaUnity", ((t, e) => { Bridge.define("LunaUnity.Objects.Handlers.PhysicsMaterial2D", { inherits: [LunaUnity.Objects.Handlers.Base], ctor: function(t) { this.$initialize(), LunaUnity.Objects.Handlers.Base.ctor.call(this, t) }, loadAsync: function(t, e) { const i = t.d("Luna.Unity.DTO.UnityEngine.Assets.PhysicsMaterial2D", e.data); return this.registry.Put(e.id, i), { result: i } }, unloadAsync: function(t) { this.registry.Release(t.id) } }) })), Bridge.assembly("LunaUnity", ((t, e) => {
        const i = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Assets.Mesh"],
            n = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Assets.Mesh+SubMesh"],
            s = new Blob;
        Bridge.define("LunaUnity.Objects.Handlers.Mesh", {
            inherits: [LunaUnity.Objects.Handlers.Base],
            ctor: function(t) { this.$initialize(), LunaUnity.Objects.Handlers.Base.ctor.call(this, t) },
            loadAsync: function(t, e, r) {
                const o = e.data,
                    a = new pc.Mesh(!0),
                    c = r.find((t => t.manifest.id === e.assetBundleId)).blob || s;
                a.name = o[i.name];
                const h = o[i.vertices];
                let l = c.slice(h[0], h[0] + h[1]);
                const u = o[i.halfPrecision] ? pc.Conversion.fromFloat16ToFloat32(new Uint16Array(l)) : new Float32Array(l),
                    d = a.defaultVertexBuffer(o[i.streams], o[i.vertexCount], u.buffer);
                o[i.vertices] = null, a.vertexBuffer = d, a.subMeshes = [];
                const p = o[i.subMeshes],
                    _ = o[i.aabb];
                for (let t = 0; t < p.length; t++) {
                    const i = p[t][n.triangles],
                        s = new Uint16Array(c.slice(i[0], i[0] + i[1])),
                        r = new pc.Mesh;
                    r.aabb = new pc.BoundingBox(new pc.Vec3(_[0], _[1], _[2]), new pc.Vec3(_[3], _[4], _[5])), r.$id = e.id;
                    const o = a.defaultIndexBuffer(s.length, s);
                    r.vertexBuffer = d, r.indexBuffer[0] = o, r.primitive[0].type = pc.gfx.PRIMITIVE_TRIANGLES, r.primitive[0].base = 0, r.primitive[0].count = s.length, r.primitive[0].indexed = !0, a.subMeshes.push(r)
                }
                a.indexBuffer = a.subMeshes[0].indexBuffer, a.primitive[0].type = pc.gfx.PRIMITIVE_TRIANGLES, a.primitive[0].base = 0, a.primitive[0].count = p[0].length, a.primitive[0].indexed = !0, a.aabb = new pc.BoundingBox(new pc.Vec3(_[0], _[1], _[2]), new pc.Vec3(_[3], _[4], _[5]));
                const f = o[i.bindposes];
                for (let t = 0; t < f.length; t += 16) a.bindposes.push((new pc.Mat4).setData(f[t + 0], f[t + 1], f[t + 2], f[t + 3], f[t + 4], f[t + 5], f[t + 6], f[t + 7], f[t + 8], f[t + 9], f[t + 10], f[t + 11], f[t + 12], f[t + 13], f[t + 14], f[t + 15]));
                const m = o[i.blendShapes];
                if (0 !== m.length) {
                    a.morph = new pc.Morph([]);
                    for (let t = 0; t < m.length; t++) {
                        const e = m[t],
                            n = e[1],
                            s = {};
                        s.name = e[0], s.frames = [];
                        for (let t = 0; t < n.length; t++) {
                            const n = {};
                            n.weight = e[1][t][0], l = c.slice(e[1][t][1][0], e[1][t][1][0] + e[1][t][1][1]), n.deltaPositions = o[i.halfPrecision] ? pc.Conversion.fromFloat16ToFloat32(new Uint16Array(l)) : e[1][t][1], l = c.slice(e[1][t][2][0], e[1][t][2][0] + e[1][t][2][1]), n.deltaNormals = o[i.halfPrecision] ? pc.Conversion.fromFloat16ToFloat32(new Uint16Array(l)) : e[1][t][2], l = c.slice(e[1][t][3][0], e[1][t][3][0] + e[1][t][3][1]), n.deltaTangents = o[i.halfPrecision] ? pc.Conversion.fromFloat16ToFloat32(new Uint16Array(l)) : e[1][t][3];
                            const r = new pc.MorphTargetFrame(n);
                            s.frames[t] = r
                        }
                        const r = new pc.MorphTarget(s);
                        a.morph.addTarget(r), a.morph._setBaseMesh(a)
                    }
                }
                return this.registry.Put(e.id, a), { result: a }
            },
            unloadAsync: function(t) {
                const e = this.registry.Release(t.id);
                e && e.destroy()
            }
        })
    })), Bridge.assembly("LunaUnity", ((t, e) => {
        const i = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Scene.Scene"],
            n = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Assets.RenderSettings"],
            s = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Assets.RenderSettings+LightProbes"];
        Bridge.define("LunaUnity.Objects.Handlers.Scene", {
            inherits: [LunaUnity.Objects.Handlers.Base],
            ctor: function(t) { this.$initialize(), LunaUnity.Objects.Handlers.Base.ctor.call(this, t) },
            loadAsync: function(t, e, s) {
                const r = e.data,
                    o = (new LunaUnity.Objects.Scene).initializeAsTemplate({ renderSettings: t.d("Luna.Unity.DTO.UnityEngine.Assets.RenderSettings", e.render_settings.data), rootJsons: e.objects, name: r[i.name], index: r[i.index], lightmaps: r[i.lightmaps] }),
                    a = s.find((t => t.manifest.id === e.assetBundleId)).blob,
                    c = e.render_settings.data[n.lightProbes];
                return this.parseLightProbeData(a, c, o.renderSettings.lightProbes), UnityEngine.SceneManagement.SceneManager.scenes.push(o), this.registry.Put("scenes/" + e.name, o), { result: o }
            },
            parseLightProbeData: function(t, e, i) {
                let n = [],
                    r = 0,
                    o = this.getTypedArrayFromBlobAndMarker(Float32Array, t, e[s.bakedProbes]);
                for (r = 0; r < o.length; r += 27) n.push(pc.SphericalHarmonicsL2.fromArray(o.subarray(r, r + 27)));
                for (i.bakedProbes = n, n = [], o = this.getTypedArrayFromBlobAndMarker(Float32Array, t, e[s.positions]), r = 0; r < o.length; r += 3) n.push(new pc.Vec3(o[r + 0], o[r + 1], o[r + 2]));
                for (i.positions = n, n = [], o = this.getTypedArrayFromBlobAndMarker(Float32Array, t, e[s.hullRays]), r = 0; r < o.length; r += 3) n.push(new pc.Vec3(o[r + 0], o[r + 1], o[r + 2]));
                for (i.hullRays = n, n = [], o = this.getTypedArrayFromBlobAndMarker(Float32Array, t, e[s.matrices]), r = 0; r < o.length; r += 16) n.push(pc.Mat4.fromArray(o.subarray(r, r + 16)));
                i.matrices = n, i.tetrahedra = this.getTypedArrayFromBlobAndMarker(Int16Array, t, e[s.tetrahedra]), i.neighbours = this.getTypedArrayFromBlobAndMarker(Int16Array, t, e[s.neighbours])
            },
            getTypedArrayFromBlobAndMarker: function(t, e, i) { return new t(e ? e.slice(i[0], i[0] + i[1]) : 0) },
            unloadAsync: function(t) { this.registry.Release(t.id) }
        })
    })), Bridge.assembly("LunaUnity", ((t, e) => {
        const i = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Assets.Shader"];
        Bridge.define("LunaUnity.Objects.Handlers.Shader", {
            inherits: [LunaUnity.Objects.Handlers.Base],
            ctor: function(t) { this.$initialize(), LunaUnity.Objects.Handlers.Base.ctor.call(this, t) },
            loadAsync: function(t, e, i) { const n = new pc.UnityShader(this.graphicsDevice); return t.d("Luna.Unity.DTO.UnityEngine.Assets.Shader", e.data, n), n.setup(), this.registry.Put(e.id, n), UnityEngine.Shader.shaderIndex[n.name] = n, System.Threading.Tasks.Task.fromResult(n) },
            _loadRenderState: function(t, e) {
                const i = t.d("Luna.Unity.DTO.UnityEngine.Assets.Shader+Pass", e),
                    n = [];
                return this._collectBoundParameters(i, n), i.boundParameters = n, i
            },
            _collectBoundParameters: function(t, e) {
                for (const i in t) {
                    if (!t.hasOwnProperty(i)) continue;
                    const n = t[i];
                    n && n.$$fullname && ("Luna.Unity.DTO.UnityEngine.Assets.Shader.Pass+Value" === n.$$fullname && n.name ? e.push(n) : this._collectBoundParameters(n, e))
                }
            },
            _getDefaultTextureNamed: function(t) { const e = UnityEngine.Texture2D[t + "Texture"]; return e ? e.handle : null },
            _loadShaderForStandardMaterialAsync: function(t, e) { return this.registry.Put(e.id, { name: e.data[i.name], renderState: this._loadRenderState(t, e.data[i.passes][0]) }), System.Threading.Tasks.Task.fromResult(!0) },
            _loadCustomShaderAsync: function(t, e) {
                const n = [];
                let s = pc.MultipassShader;
                const r = e.data,
                    o = r[i.passes];
                let a = null;
                for (let c = 0; c < o.length; c++) {
                    const o = r[i.vertexPrograms][c],
                        h = r[i.fragmentPrograms][c];
                    o && h ? a = new s(this.graphicsDevice, { attributes: { vertex_position: pc.SEMANTIC_POSITION, vertex_normal: pc.SEMANTIC_NORMAL, vertex_tangent: pc.SEMANTIC_TANGENT, vertex_texCoord0: pc.SEMANTIC_TEXCOORD0, vertex_texCoord1: pc.SEMANTIC_TEXCOORD1, vertex_color: pc.SEMANTIC_COLOR, instancing_translation: pc.SEMANTIC_TEXCOORD7, instancing_rotation: pc.SEMANTIC_BLENDWEIGHT, instancing_scale: pc.SEMANTIC_BLENDINDICES, instancing_color: pc.SEMANTIC_ATTR0, instancing_st: pc.SEMANTIC_ATTR1, _glesVertex: pc.SEMANTIC_POSITION, _glesNormal: pc.SEMANTIC_NORMAL, _glesTangent: pc.SEMANTIC_TANGENT, _glesMultiTexCoord0: pc.SEMANTIC_TEXCOORD0, _glesMultiTexCoord1: pc.SEMANTIC_TEXCOORD1, _glesMultiTexCoord2: pc.SEMANTIC_TEXCOORD2, _glesMultiTexCoord3: pc.SEMANTIC_TEXCOORD3, _glesColor: pc.SEMANTIC_COLOR, in_POSITION0: pc.SEMANTIC_POSITION, in_NORMAL0: pc.SEMANTIC_NORMAL, in_TANGENT0: pc.SEMANTIC_TANGENT, in_TEXCOORD0: pc.SEMANTIC_TEXCOORD0, in_TEXCOORD1: pc.SEMANTIC_TEXCOORD1, in_TEXCOORD2: pc.SEMANTIC_TEXCOORD2, in_TEXCOORD3: pc.SEMANTIC_TEXCOORD3, in_COLOR0: pc.SEMANTIC_COLOR, _patched_POSITION: pc.SEMANTIC_POSITION, _patched_COLOR: pc.SEMANTIC_COLOR, _patched_NORMAL: pc.SEMANTIC_NORMAL, _patched_TANGENT: pc.SEMANTIC_TANGENT, _patched_TEXCOORD0: pc.SEMANTIC_TEXCOORD0, vertex_boneWeights: pc.SEMANTIC_BLENDWEIGHT, vertex_boneIndices: pc.SEMANTIC_BLENDINDICES }, vshader: o, fshader: h }) : (a = pc._createMissingShader(e.data[i.name], e.id), a.name = e.data[i.name]), a._supportsKeywords = !0, a.renderState = this._loadRenderState(t, r[i.passes][c]), n.push(a), s = pc.Shader
                }
                return a = n[0], a.shaders = n, a.defaultParameters = {}, this.registry.Put(e.id, a), UnityEngine.Shader.shaderIndex[e.name] = a, System.Threading.Tasks.Task.fromResult(a)
            },
            unloadAsync: function(t) { this.registry.Release(t.id) }
        })
    })), Bridge.assembly("LunaUnity", ((t, e) => {
        const i = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Assets.VideoClip"];
        Bridge.define("LunaUnity.Objects.Handlers.Video", {
            inherits: [LunaUnity.Objects.Handlers.Base],
            ctor: function(t) { this.$initialize(), this.playgroundAssetOverrides = window.playgroundAssetOverrides || {}, LunaUnity.Objects.Handlers.Base.ctor.call(this, t) },
            loadAsync: function(t, e, n) {
                const s = new System.Threading.Tasks.TaskCompletionSource,
                    r = e.data,
                    o = { name: r[i.name], width: r[i.width], height: r[i.height], frameRate: r[i.frameRate], frameCount: r[i.frameCount] },
                    a = new pc.VideoTexture(this.app.graphicsDevice, o);
                return this.registry.Put(e.id, a), this.network.GetVideoAsync(this._getVideoUrl(e)).continueWith(Bridge.fn.bind(this, (t => {
                    if (t.status === System.Threading.Tasks.TaskStatus.ranToCompletion) {
                        const e = t.result;
                        a.setSource(e), s.setResult(a)
                    } else s.setCanceled()
                }))), s.task
            },
            _getVideoUrl: function(t) { return "external" === this.network.resourceConfig.video && t.id in this.playgroundAssetOverrides ? this.playgroundAssetOverrides[t.id] : "assets/bundles/" + t.assetBundleId + "/" + t.id + (t.ext || ".mp4") },
            unloadAsync: function(t) {
                const e = this.registry.Release(t.id);
                e && e.destroy()
            }
        })
    })), Bridge.assembly("LunaUnity", ((t, e) => {
        const i = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Assets.AudioClip"];
        Bridge.define("LunaUnity.Objects.Handlers.Sound", {
            inherits: [LunaUnity.Objects.Handlers.Base],
            ctor: function(t) { this.$initialize(), this.playgroundAssetOverrides = window.playgroundAssetOverrides || {}, LunaUnity.Objects.Handlers.Base.ctor.call(this, t) },
            loadAsync: function(t, e, n) {
                const s = new System.Threading.Tasks.TaskCompletionSource,
                    r = new pc.Sound;
                r.name = e.data[i.name];
                const o = this._getSoundUrl(e),
                    a = function(t) { r.buffer = t, s.setResult(r) },
                    c = function(t) { t = t || "Error loading audio url: " + o, console.error(t), s.setCancelled() },
                    h = this.app._audioManager;
                return this.registry.Put(e.id, r), this.network.GetSoundAsync(this._getSoundUrl(e)).continueWith((t => { t.status === System.Threading.Tasks.TaskStatus.ranToCompletion ? h.context.decodeAudioData(t.result, a, c) : c(t.error) })), s.task
            },
            _getSoundUrl: function(t) { return "external" === this.network.resourceConfig.sound && t.id in this.playgroundAssetOverrides ? this.playgroundAssetOverrides[t.id] : "assets/bundles/" + t.assetBundleId + "/" + t.id + (t.ext || ".mp3") },
            unloadAsync: function(t) {
                const e = this.registry.Release(t.id);
                e && (e.buffer = null)
            }
        })
    })), Bridge.assembly("LunaUnity", ((t, e) => {
        const i = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Textures.Sprite"];
        Bridge.define("LunaUnity.Objects.Handlers.Sprite", {
            inherits: [LunaUnity.Objects.Handlers.Base],
            ctor: function(t) { this.$initialize(), LunaUnity.Objects.Handlers.Base.ctor.call(this, t) },
            loadAsync: function(t, e, n) {
                const s = e.data,
                    r = this.registry.Get(s[i.texture + 1]),
                    o = new pc.Sprite({}),
                    a = s[i.textureWidth] / r.width;
                return o.attributes.transparency = new pc.Vec4((s[i.packedRect + 0] - s[i.textureRect + 0]) * r.width, (s[i.packedRect + 1] - s[i.textureRect + 1]) * r.height, (s[i.textureRect + 2] - s[i.packedRect + 2]) * r.width, (s[i.textureRect + 3] - s[i.packedRect + 3]) * r.height), o.attributes.textureRect = new pc.Vec4(s[i.packedRect + 0] * r.width, s[i.packedRect + 1] * r.height, s[i.packedRect + 2] * r.width, s[i.packedRect + 3] * r.height), o.attributes.graphicsDevice = this.graphicsDevice, o.attributes.texture = r, o.attributes.border = new pc.Vec4(Math.max(0, s[i.border + 0] * r.width - o.attributes.transparency.x), Math.max(0, s[i.border + 1] * r.height - o.attributes.transparency.y), Math.max(0, s[i.border + 2] * r.width - o.attributes.transparency.z), Math.max(0, s[i.border + 3] * r.height - o.attributes.transparency.w)), o.attributes.bounds = s[i.bounds], o.attributes.pixelsPerUnit = s[i.pixelsPerUnit] / a, o.attributes.aabb = s[i.aabb], o.attributes.vertices = s[i.vertices], o.attributes.triangles = s[i.triangles], o.attributes.nativeSize = new pc.Vec2(s[i.nativeSize], s[i.nativeSize + 1]), o.attributes.pivot = new pc.Vec2(s[i.pivot + 0], s[i.pivot + 1]), o.attributes.textureRectOffset = new pc.Vec2(s[i.textureRectOffset + 0], s[i.textureRectOffset + 1]), this.registry.Put(e.id, o), { result: o }
            },
            unloadAsync: function(t) {
                const e = this.registry.Release(t.id);
                e && e.mesh && e.mesh.destroy()
            }
        })
    })), Bridge.assembly("LunaUnity", ((t, e) => {
        const i = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Textures.Texture2D"],
            n = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Textures.RenderTexture"],
            s = [pc.PIXELFORMAT_R8_G8_B8_A8, pc.PIXELFORMAT_A8, pc.PIXELFORMAT_R4_G4_B4_A4, pc.PIXELFORMAT_R8_G8_B8, pc.PIXELFORMAT_R8_G8_B8_A8, pc.PIXELFORMAT_R8_G8_B8_A8, pc.PIXELFORMAT_R8_G8_B8_A8, pc.PIXELFORMAT_R5_G6_B5, pc.PIXELFORMAT_R8_G8_B8_A8, pc.PIXELFORMAT_R8_G8_B8_A8, pc.PIXELFORMAT_R8_G8_B8_A8, pc.PIXELFORMAT_R8_G8_B8_A8, pc.PIXELFORMAT_R8_G8_B8_A8, pc.PIXELFORMAT_R8_G8_B8_A8, pc.PIXELFORMAT_R8_G8_B8_A8, pc.PIXELFORMAT_R8_G8_B8_A8, pc.PIXELFORMAT_R8_G8_B8_A8, pc.PIXELFORMAT_R8_G8_B8_A8, pc.PIXELFORMAT_R8_G8_B8_A8, pc.PIXELFORMAT_R8_G8_B8_A8, pc.PIXELFORMAT_RGBA32F, pc.PIXELFORMAT_R8_G8_B8_A8, pc.PIXELFORMAT_R8_G8_B8_A8, pc.PIXELFORMAT_R8_G8_B8_A8, pc.PIXELFORMAT_R8_G8_B8_A8, pc.PIXELFORMAT_R8_G8_B8_A8, pc.PIXELFORMAT_R8_G8_B8_A8, pc.PIXELFORMAT_R8_G8_B8_A8, pc.PIXELFORMAT_R8_G8_B8_A8, pc.PIXELFORMAT_R8_G8_B8_A8, pc.PIXELFORMAT_R8_G8_B8_A8, pc.PIXELFORMAT_PVRTC_2BPP_RGBA_1, pc.PIXELFORMAT_R8_G8_B8_A8, pc.PIXELFORMAT_R8_G8_B8_A8, pc.PIXELFORMAT_R8_G8_B8_A8, pc.PIXELFORMAT_R8_G8_B8_A8, pc.PIXELFORMAT_R8_G8_B8_A8, pc.PIXELFORMAT_R8_G8_B8_A8, pc.PIXELFORMAT_R8_G8_B8_A8, pc.PIXELFORMAT_R8_G8_B8_A8, pc.PIXELFORMAT_R8_G8_B8_A8, pc.PIXELFORMAT_R8_G8_B8_A8, pc.PIXELFORMAT_R8_G8_B8_A8, pc.PIXELFORMAT_R8_G8_B8_A8, pc.PIXELFORMAT_R8_G8_B8_A8, pc.PIXELFORMAT_R8_G8_B8_A8, pc.PIXELFORMAT_R8_G8_B8_A8, pc.PIXELFORMAT_R8_G8_B8_A8, pc.PIXELFORMAT_R8_G8_B8_A8, pc.PIXELFORMAT_R8_G8_B8_A8, pc.PIXELFORMAT_R8_G8_B8_A8, pc.PIXELFORMAT_R8_G8_B8_A8, pc.PIXELFORMAT_R8_G8_B8_A8, pc.PIXELFORMAT_R8_G8_B8_A8, pc.PIXELFORMAT_R8_G8_B8_A8, pc.PIXELFORMAT_R8_G8_B8_A8, pc.PIXELFORMAT_R8_G8_B8_A8, pc.PIXELFORMAT_R8_G8_B8_A8, pc.PIXELFORMAT_R8_G8_B8_A8, pc.PIXELFORMAT_R8_G8_B8_A8, pc.PIXELFORMAT_R8_G8_B8_A8, pc.PIXELFORMAT_R8_G8_B8_A8];
        Bridge.define("LunaUnity.Objects.Handlers.Texture", {
            inherits: [LunaUnity.Objects.Handlers.Base],
            ctor: function(t) { this.$initialize(), this.playgroundAssetOverrides = window.playgroundAssetOverrides || {}, LunaUnity.Objects.Handlers.Base.ctor.call(this, t) },
            loadAsync: function(t, e, i) { if (0 === e.type) return this._loadTexture2dAsync(e); if (1 === e.type) return this._loadTexture3dAsync(e); if (2 === e.type) return System.Threading.Tasks.Task.fromResult(!0); if (3 === e.type) return this._loadRenderTextureAsync(e); throw new Error("Unknown texture type: " + e.type) },
            _loadRenderTextureAsync: function(t) { const e = new UnityEngine.RenderTexture.Create(t.data[n.width], t.data[n.height], 16, 0); return this.registry.Put(t.id, e.handle), System.Threading.Tasks.Task.fromResult(e.handle) },
            _loadTexture3dAsync: function(t) { throw new Error("NotImplemented") },
            _getDummyTexture: function() {
                if (this._dummyTexture) return this._dummyTexture;
                this._dummyTexture = new pc.Texture(this.app.graphicsDevice, { width: 16, height: 16, format: pc.PIXELFORMAT_R8_G8_B8_A8 });
                const t = this._dummyTexture.lock();
                for (let e = 0; e < t.length; e += 3) t[e + 0] = 255, t[e + 1] = 0, t[e + 2] = 255, t[e + 4] = 127;
                return this._dummyTexture.unlock(), this._dummyTexture
            },
            _loadTexture2dAsync: function(t) {
                const e = new System.Threading.Tasks.TaskCompletionSource,
                    n = t.data,
                    r = n[i.filterMode],
                    o = n[i.mipmapCount] > 1;
                let a = o ? pc.FILTER_NEAREST_MIPMAP_NEAREST : pc.FILTER_NEAREST,
                    c = pc.FILTER_NEAREST;
                r === UnityEngine.FilterMode.Bilinear ? (a = o ? pc.FILTER_LINEAR_MIPMAP_NEAREST : pc.FILTER_LINEAR, c = pc.FILTER_LINEAR) : r === UnityEngine.FilterMode.Trilinear && (a = o ? pc.FILTER_LINEAR_MIPMAP_LINEAR : pc.FILTER_LINEAR, c = pc.FILTER_LINEAR);
                const h = n[i.wrapMode] === UnityEngine.TextureWrapMode.Repeat ? pc.ADDRESS_REPEAT : pc.ADDRESS_CLAMP_TO_EDGE,
                    l = { name: n[i.name] || "", width: n[i.width], height: n[i.height], addressU: h, addressV: h, mipmaps: o, minFilter: a, magFilter: c, autoMipmap: o, rgbm: !!n[i.hdr], anisotropy: Math.min(this.graphicsDevice.maxAnisotropy, n[i.anisoLevel]), format: s[n[i.format]] };
                if (t.dummy) { const e = this._getDummyTexture(); return this.registry.Put(t.id, e), System.Threading.Tasks.Task.fromResult(e) }
                const u = new pc.Texture(this.app.graphicsDevice, l);
                return this.registry.Put(t.id, u), this.network.GetImageAsync(this._getTextureUrl(t)).continueWith(Bridge.fn.bind(this, (t => {
                    if (t.status === System.Threading.Tasks.TaskStatus.ranToCompletion) {
                        const i = t.result;
                        u.setSource(i), i.remove(), u.mipmaps = l.mipmaps, u.minFilter = l.minFilter, u.magFilter = l.magFilter, u.anisotropy = l.anisotropy, e.setResult(u)
                    } else e.setCanceled()
                }))), e.task
            },
            _getTextureUrl: function(t) { return "external" === this.network.resourceConfig.image && t.id in this.playgroundAssetOverrides ? this.playgroundAssetOverrides[t.id] : "assets/bundles/" + t.assetBundleId + "/" + t.id + (t.ext || ".png") },
            unloadAsync: function(t) {
                const e = this.registry.Release(t.id);
                e && e.destroy()
            }
        })
    })), Bridge.assembly("LunaUnity", ((t, e) => {
        const i = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Textures.Cubemap"];
        Bridge.define("LunaUnity.Objects.Handlers.Cubemap", {
            inherits: [LunaUnity.Objects.Handlers.Base],
            ctor: function(t) { this.$initialize(), LunaUnity.Objects.Handlers.Base.ctor.call(this, t) },
            loadAsync: function(t, e, i) { return 2 === e.type ? this._loadCubemapAsync(e) : System.Threading.Tasks.Task.fromResult(null) },
            _loadCubemapAsync: function(t) {
                const e = t.data,
                    n = e[i.size],
                    s = e[i.filterMode],
                    r = e[i.mipmapCount] > 0;
                let o = r ? pc.FILTER_NEAREST_MIPMAP_NEAREST : pc.FILTER_NEAREST,
                    a = pc.FILTER_NEAREST;
                s === UnityEngine.FilterMode.Bilinear ? (o = r ? pc.FILTER_LINEAR_MIPMAP_NEAREST : pc.FILTER_LINEAR, a = pc.FILTER_LINEAR) : s === UnityEngine.FilterMode.Trilinear && (o = r ? pc.FILTER_LINEAR_MIPMAP_LINEAR : pc.FILTER_LINEAR, a = pc.FILTER_LINEAR);
                const c = e[i.wrapMode] === UnityEngine.TextureWrapMode.Repeat ? pc.ADDRESS_REPEAT : pc.ADDRESS_CLAMP_TO_EDGE,
                    h = new pc.Texture(this.graphicsDevice, { width: n, height: n, minFilter: o, magFilter: a, addressU: c, addressV: c, anisotropy: Math.min(this.graphicsDevice.maxAnisotropy, e[i.anisoLevel]), cubemap: !0, mipmaps: r, rgbm: !!e[i.hdr], flipY: !0, atlas: this.registry.Get(e[i.atlasId]), rects: e[i.rects] });
                return h.upload(), this.registry.Put(t.id, h), System.Threading.Tasks.Task.fromResult(h)
            },
            unloadAsync: function(t) {
                const e = this.registry.Release(t.id);
                e && e.destroy()
            }
        })
    })), Bridge.assembly("LunaUnity", ((t, e) => { Bridge.define("LunaUnity.Objects.Handlers.Resources", { inherits: [LunaUnity.Objects.Handlers.Base], ctor: function(t) { this.$initialize(), LunaUnity.Objects.Handlers.Base.ctor.call(this, t) }, loadAsync: function(t, e, i) { t.deserializeTo(e.data, UnityEngine.Resources, "Luna.Unity.DTO.UnityEngine.Assets.Resources"); const n = LunaUnity.Objects.Bundle.handlers.project_settings; return LunaUnity.Objects.Bundle.handlers.prefab_component.load(n.autoInstantiatePrefabs), {} }, unloadAsync: function(t) { this.registry.Release(t.id) } }) })), Bridge.assembly("LunaUnity", ((t, e) => {
        const i = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Assets.TextAsset"];
        Bridge.define("LunaUnity.Objects.Handlers.TextAsset", { inherits: [LunaUnity.Objects.Handlers.Base], ctor: function(t) { this.$initialize(), LunaUnity.Objects.Handlers.Base.ctor.call(this, t) }, loadAsync: function(t, e, n) { const s = new UnityEngine.TextAsset; return s.data = e.data[i.data], s.name = e.data[i.name], s.bytes64 = e.data[i.bytes64], this.registry.Put(e.id, s), { result: s } }, unloadAsync: function(t) { this.registry.Release(t.id) } })
    })), Bridge.assembly("LunaUnity", ((t, e) => {
        Bridge.define("LunaUnity.Objects.Handlers.ScriptableObject", {
            inherits: [LunaUnity.Objects.Handlers.Base],
            ctor: function(t) { this.$initialize(), LunaUnity.Objects.Handlers.Base.ctor.call(this, t) },
            loadAsync: function(t, e, i) {
                try {
                    const i = Deserializers.types[e.class],
                        n = t.d(i, e.data);
                    return n.name = e.name, n ? (this.registry.Put(e.id, n), { result: n }) : (console.warn("Failed to instantiate ScriptableObject of type " + i), System.Threading.Tasks.Task.fromResult(!0))
                } catch (t) { return console.warn("Cannot put scriptable object with id " + e.id + ": " + t), null }
            },
            unloadAsync: function(t) { this.registry.Release(t.id) }
        })
    })), Bridge.assembly("LunaUnity", ((t, e) => {
        const i = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Animation.Data.AnimationClip"],
            n = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Animation.Data.AnimationCurve"],
            s = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Animation.Data.AnimationEvent"];
        Bridge.define("LunaUnity.Objects.Handlers.AnimationClip", {
            inherits: [LunaUnity.Objects.Handlers.Base],
            ctor: function(t) { this.$initialize(), LunaUnity.Objects.Handlers.Base.ctor.call(this, t) },
            loadAsync: function(t, e, r) {
                const o = e.data,
                    a = new UnityEngine.AnimationClip,
                    c = r.find((t => t.manifest.id === e.assetBundleId)).blob;
                a.name = o[i.name], a.length = o[i.length], a.wrapMode = o[i.wrapMode], a.isLooping = o[i.isLooping];
                const h = o[i.curves];
                a.curves = new Array(h.length);
                for (let e = 0; e < h.length; e++) {
                    const s = h[e],
                        r = s[n.keys],
                        l = c.slice(r[0], r[0] + r[1]),
                        u = o[i.halfPrecision] ? pc.Conversion.fromFloat16ToFloat32(new Uint16Array(l)) : new Float32Array(l) || [],
                        d = s[n.objectReferenceKeys] || [],
                        p = new Array(Math.floor(u.length / 7) + d.length);
                    for (let t = 0; t < u.length; t += 7) p[t / 7] = new pc.Keyframe(u[t], u[t + 1], u[t + 2], u[t + 3], u[t + 4], u[t + 5], u[t + 6]);
                    for (let e = 0; e < d.length; e++) {
                        const i = d[e];
                        p[e + u.length / 7] = t.deserializeTo(i, new pc.Keyframe, "Luna.Unity.DTO.UnityEngine.Animation.Data.AnimationCurve+ObjectReferenceKey")
                    }
                    const _ = { path: s[n.path], componentType: s[n.componentType], property: s[n.property], keyframes: p };
                    a.curves[e] = new pc.AnimationCurve(_), d.length > 0 && (a.curves[e].objectCurve = !0)
                }
                const l = o[i.events];
                a.events = new Array(l.length);
                for (let e = 0; e < l.length; e++) {
                    const i = l[e],
                        n = new UnityEngine.AnimationEvent;
                    n.functionName = i[s.functionName], n.floatParameter = i[s.floatParameter], n.intParameter = i[s.intParameter], n.stringParameter = i[s.stringParameter], n.time = i[s.time], t.r(i[s.objectReferenceParameter], i[s.objectReferenceParameter + 1], 0, n, "objectReferenceParameter"), a.events[e] = n
                }
                return this.registry.Put(e.id, a), { result: a }
            },
            unloadAsync: function(t) { this.registry.Release(t.id) }
        })
    })), Bridge.assembly("LunaUnity", ((t, e) => {
        const i = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Animations.BlendTree"],
            n = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Animations.ChildMotion"];
        Bridge.define("LunaUnity.Objects.Handlers.BlendTree", {
            inherits: [LunaUnity.Objects.Handlers.Base],
            ctor: function(t) { this.$initialize(), LunaUnity.Objects.Handlers.Base.ctor.call(this, t) },
            loadAsync: function(t, e, s) {
                const r = e.data,
                    o = new UnityEditor.Animations.BlendTree;
                o.name = r[i.name], o.blendParameter = r[i.blendParameter], o.blendParameterY = r[i.blendParameterY], o.blendType = r[i.blendType], o.children = r[i.children], o.useAutomaticThresholds = r[i.useAutomaticThresholds], o.minThreshold = r[i.minThreshold], o.maxThreshold = r[i.maxThreshold];
                const a = r[i.children];
                o.children = new Array(a.length);
                for (let e = 0; e < a.length; ++e) {
                    const i = new UnityEditor.Animations.ChildMotion,
                        s = a[e];
                    t.r(!0, s[n.motion + 1], 0, i, "motion"), i.position = new pc.Vec2, i.position.x = s[n.position + 0], i.position.y = s[n.position + 1], i.threshold = s[n.threshold], i.timeScale = s[n.timeScale], i.cycleOffset = s[n.cycleOffset], i.directBlendParameter = s[n.directBlendParameter], i.mirror = s[n.mirror], o.children[e] = i
                }
                return this.registry.Put(e.id, o), { result: o }
            },
            unloadAsync: function(t) { this.registry.Release(t.id) }
        })
    })), Bridge.assembly("LunaUnity", ((t, e) => {
        Bridge.define("LunaUnity.Objects.Handlers.AnimatorController", {
            inherits: [LunaUnity.Objects.Handlers.Base],
            ctor: function(t) { this.$initialize(), LunaUnity.Objects.Handlers.Base.ctor.call(this, t) },
            loadAsync: function(t, e, i) {
                const n = t.d("Luna.Unity.DTO.UnityEngine.Animation.Mecanim.AnimatorController", e.data),
                    s = new UnityEditor.Animations.AnimatorController.$ctor1(n, this.registry);
                return this.registry.Put(e.id, s), { result: s }
            },
            unloadAsync: function(t) { this.registry.Release(t.id) }
        })
    })), Bridge.assembly("LunaUnity", ((t, e) => {
        const i = Deserializers.fields["Luna.Unity.DTO.UnityEngine.Assets.Font"];
        Bridge.define("LunaUnity.Objects.Handlers.Font", {
            inherits: [LunaUnity.Objects.Handlers.Base],
            ctor: function(t) { this.$initialize(), LunaUnity.Objects.Handlers.Base.ctor.call(this, t) },
            loadAsync: function(t, e, n) {
                const s = e.data,
                    r = { name: s[i.name], ascent: s[i.ascent], originalLineHeight: s[i.originalLineHeight], fontSize: s[i.fontSize], originalFontSize: s[i.originalFontSize], characterInfo: s[i.characterInfo], texture: this.registry.TryGet(e.data[i.texture + 1]) },
                    o = new pc.Font(e.font, r);
                return this.registry.Put(e.id, o), pc.Font.fonts = pc.Font.fonts || {}, pc.Font.fonts[e.data[i.name]] = o, pc.Font.fonts[e.data[i.name].replace("-Regular", "")] = o, UnityEngine.Font.FontDefault && "Arial" !== e.data[i.name] || (UnityEngine.Font.FontDefault = new UnityEngine.Font(o)), { result: o }
            },
            unloadAsync: function(t) { this.registry.Release(t.id) }
        })
    })), Bridge.assembly("LunaUnity", ((t, e) => {
        Bridge.define("LunaUnity.Objects.Handlers.PrefabComponent", {
            inherits: [LunaUnity.Objects.Handlers.Base],
            ctor: function(t) { this.$initialize(), LunaUnity.Objects.Handlers.Base.ctor.call(this, t) },
            load: function(t) {
                if (t) return;
                const e = UnityEngine.Resources.componentToPrefabIds;
                for (let t = 0; t < e.length; t += 2) {
                    const i = e[t].toString(),
                        n = e[t + 1].toString();
                    this.registry.Put(i, { isPrefabProxy: !0, componentId: i, prefabId: n })
                }
            }
        })
    })), window.System$Collections$Generic$ICollection$1$Function$contains = "contains", window.System$Collections$Generic$ICollection$1$Function$getItem = "getItem", window.System$Collections$Generic$ICollection$1$Function$setItem = "setItem", window.System$Collections$Generic$ICollection$1$Function$removeItem = "removeItem", window.System$Collections$Generic$IDictionary$2$Function$Function$add = "add", window.System$Collections$Generic$IDictionary$2$Function$Function$containsKey = "containsKey", window.System$Collections$Generic$IDictionary$2$Function$Function$getItem = "getItem", window.System$Collections$Generic$IDictionary$2$Function$Function$setItem = "setItem", window.System$Collections$Generic$IDictionary$2$Function$Function$removeItem = "removeItem", Bridge.ns = function(t, e) { const i = t.split("."); let n = 0; if (e || (e = Bridge.global), e === Bridge.global && (window.$typeCache = window.$typeCache || {}, window.$typeCache[t])) return window.$typeCache[t]; for (n = 0; n < i.length; n++) void 0 === e[i[n]] && (e[i[n]] = {}), e = e[i[n]]; return e === Bridge.global && (window.$typeCache[t] = e), e }, System.Threading.Tasks.Task.prototype.setSynchronous = function(t) { this._synchrounous = t }, System.Threading.Tasks.Task.prototype.continueWith = function(t, e) {
        const i = new System.Threading.Tasks.TaskCompletionSource,
            n = this,
            s = e ? function() { i.setResult(t(n)) } : function() { try { i.setResult(t(n)) } catch (t) { i.setException(System.Exception.create(t)) } };
        return this.isCompleted() ? this._synchrounous ? s() : setTimeout(s, 0) : this.callbacks.push(s), i.task
    }, window.utf8ArrayToStr = function() {
        const t = new Array(128),
            e = String.fromCodePoint || String.fromCharCode,
            i = [];
        return "undefined" != typeof TextEncoder ? function(t) { return t ? new TextDecoder("utf-8").decode(t) : "" } : function(n) {
            let s, r;
            const o = n.length;
            i.length = 0;
            for (let a = 0; a < o;) r = n[a++], r <= 127 ? s = r : r <= 223 ? s = (31 & r) << 6 | 63 & n[a++] : r <= 239 ? s = (15 & r) << 12 | (63 & n[a++]) << 6 | 63 & n[a++] : String.fromCodePoint ? s = (7 & r) << 18 | (63 & n[a++]) << 12 | (63 & n[a++]) << 6 | 63 & n[a++] : (s = 63, a += 3), i.push(t[s] || (t[s] = e(s)));
            return i.join("")
        }
    }(), pc.extend(pc, function() { const t = function() { this.boxProjection = !1, this.cubemap = new pc.Texture(UnityEngine.Graphics.graphicsDevice, { cubemap: !0, rgbm: !1 }), this.position = new pc.Vec4, this.min = new pc.Vec4, this.max = new pc.Vec4, this.box = { min: new pc.Vec4, max: new pc.Vec4, position: new pc.Vec4 } }; return pc.extend(t.prototype, { getBox: function(t) { return this.box.min.copy(this.min), this.box.max.copy(this.max), this.box.position.copy(this.position), this.boxProjection, this.box } }), { ReflectionProbeData: t } }()),
    function() {
        if (!DEBUG) return;
        const t = function() {
                const t = this;
                if (!(t instanceof pc.Vec2 && !Number.isNaN(t.x) && !Number.isNaN(t.y))) {
                    const t = new Error("NaN in Vec2");
                    console.error(t.stack)
                }
            },
            e = function() {
                const t = this;
                if (!(t instanceof pc.Vec3 && !Number.isNaN(t.x) && !Number.isNaN(t.y) && !Number.isNaN(t.z))) {
                    const t = new Error("NaN in Vec3");
                    console.error(t.stack)
                }
            },
            i = function() {
                const t = this;
                if (!(t instanceof pc.Vec4 && !Number.isNaN(t.x) && !Number.isNaN(t.y) && !Number.isNaN(t.z) && !Number.isNaN(t.w))) {
                    const t = new Error("NaN in Vec4");
                    console.error(t.stack)
                }
            },
            n = function() {
                const t = this;
                if (!(t instanceof pc.Quat && !Number.isNaN(t.x) && !Number.isNaN(t.y) && !Number.isNaN(t.z) && !Number.isNaN(t.w))) {
                    const t = new Error("NaN in Quat");
                    console.error(t.stack)
                }
            },
            s = function(t, e, i) {
                const n = t[e];
                t[e] = function(...t) { const e = n.apply(this, t); return i.call(this), e }
            };
        s(pc.Vec2.prototype, "add", t), s(pc.Vec2.prototype, "add2", t), s(pc.Vec2.prototype, "sub", t), s(pc.Vec2.prototype, "sub2", t), s(pc.Vec2.prototype, "set", t), s(pc.Vec2.prototype, "copy", t), s(pc.Vec2.prototype, "lerp", t), s(pc.Vec2.prototype, "mul", t), s(pc.Vec2.prototype, "mul2", t), s(pc.Vec2.prototype, "normalize", t), s(pc.Vec2.prototype, "scale", t), s(pc.Vec3.prototype, "add", e), s(pc.Vec3.prototype, "add2", e), s(pc.Vec3.prototype, "sub", e), s(pc.Vec3.prototype, "sub2", e), s(pc.Vec3.prototype, "set", e), s(pc.Vec3.prototype, "copy", e), s(pc.Vec3.prototype, "cross", e), s(pc.Vec3.prototype, "lerp", e), s(pc.Vec3.prototype, "mul", e), s(pc.Vec3.prototype, "mul2", e), s(pc.Vec3.prototype, "normalize", e), s(pc.Vec3.prototype, "project", e), s(pc.Vec3.prototype, "scale", e), s(pc.Vec4.prototype, "add", i), s(pc.Vec4.prototype, "add2", i), s(pc.Vec4.prototype, "sub", i), s(pc.Vec4.prototype, "sub2", i), s(pc.Vec4.prototype, "set", i), s(pc.Vec4.prototype, "copy", i), s(pc.Vec4.prototype, "lerp", i), s(pc.Vec4.prototype, "mul", i), s(pc.Vec4.prototype, "mul2", i), s(pc.Vec4.prototype, "normalize", i), s(pc.Vec4.prototype, "scale", i), s(pc.Quat.prototype, "clone", n), s(pc.Quat.prototype, "copy", n), s(pc.Quat.prototype, "conjugate", n), s(pc.Quat.prototype, "negate", n), s(pc.Quat.prototype, "invert", n), s(pc.Quat.prototype, "mul", n), s(pc.Quat.prototype, "mul2", n), s(pc.Quat.prototype, "nearest", n), s(pc.Quat.prototype, "normalize", n), s(pc.Quat.prototype, "set", n), s(pc.Quat.prototype, "fromTo", n), s(pc.Quat.prototype, "setFromAxisAngle", n), s(pc.Quat.prototype, "setFromEulerAngles", n), s(pc.Quat.prototype, "setFromMat4", n), s(pc.Quat.prototype, "slerp", n), s(pc.Quat.prototype, "slerpUnclamped", n), s(pc.Quat.prototype, "setLookAt", n)
    }();